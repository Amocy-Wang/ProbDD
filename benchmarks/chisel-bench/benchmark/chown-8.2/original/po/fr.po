# translation of coreutils-7.1.fr.po to Français
# Messages français pour GNU concernant coreutils.
# Copyright © 2004, 2008, 2009 Free Software Foundation, Inc.
# This file is distributed under the same license as the coreutils package.
# Michel Robitaille <robitail@IRO.UMontreal.CA>, traducteur depuis/since 1996.
#
# kerb <y.kerb@laposte.net>, 2008, 2009.
msgid ""
msgstr ""
"Project-Id-Version: coreutils-7.1\n"
"Report-Msgid-Bugs-To: bug-coreutils@gnu.org\n"
"POT-Creation-Date: 2009-12-11 14:25+0100\n"
"PO-Revision-Date: 2009-03-01 19:52+0100\n"
"Last-Translator: y.kerb <y.kerb@laposte.net>\n"
"Language-Team: French <traduc@traduc.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: KBabel 1.11.4\n"

#: lib/argmatch.c:133
#, c-format
msgid "invalid argument %s for %s"
msgstr "argument %s invalide pour %s"

#: lib/argmatch.c:134
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "argument %s ambigu pour %s"

#: lib/argmatch.c:153
#, c-format
msgid "Valid arguments are:"
msgstr "Arguments valides sont:"

#: lib/closein.c:99
msgid "error closing file"
msgstr "erreur à la fermeture du fichier"

#: lib/closeout.c:112 src/base64.c:110 src/base64.c:122 src/base64.c:128
#: src/base64.c:169 src/base64.c:225 src/cat.c:187 src/cat.c:203 src/cat.c:287
#: src/cksum.c:248 src/expand.c:329 src/expand.c:354 src/head.c:301
#: src/head.c:351 src/head.c:759 src/head.c:800 src/mktemp.c:348 src/od.c:919
#: src/paste.c:159 src/shuf.c:405 src/tail.c:342 src/tail.c:1130
#: src/tail.c:1209 src/tail.c:2038 src/tr.c:1549 src/tr.c:1772 src/tr.c:1886
#: src/unexpand.c:426 src/unexpand.c:442
#, c-format
msgid "write error"
msgstr "Erreur d'écriture."

#: lib/copy-acl.c:547 src/copy.c:883 src/copy.c:2217
#, c-format
msgid "preserving permissions for %s"
msgstr "préserve les permissions pour %s"

#: lib/error.c:153
msgid "Unknown system error"
msgstr "Erreur système inconnue"

#: lib/euidaccess-stat.c:129 src/copy.c:1267 src/copy.c:1319 src/copy.c:1901
#: src/copy.c:2204 src/df.c:574 src/install.c:737 src/stat.c:915
#: src/truncate.c:367
#, c-format
msgid "cannot stat %s"
msgstr "ne peut évaluer %s"

#: lib/file-type.c:38
msgid "regular empty file"
msgstr "fichier régulier vide"

#: lib/file-type.c:38
msgid "regular file"
msgstr "fichier régulier"

#: lib/file-type.c:41
msgid "directory"
msgstr "répertoire"

#: lib/file-type.c:44
msgid "block special file"
msgstr "fichier spécial de bloc"

#: lib/file-type.c:47
msgid "character special file"
msgstr "fichier spécial de caractères"

#: lib/file-type.c:50
msgid "fifo"
msgstr "PEPS (FIFO)"

#: lib/file-type.c:53
msgid "symbolic link"
msgstr "lien symbolique"

#: lib/file-type.c:56
msgid "socket"
msgstr "socket"

#: lib/file-type.c:59
msgid "message queue"
msgstr "queue de messages"

#: lib/file-type.c:62
msgid "semaphore"
msgstr "sémaphore"

#: lib/file-type.c:65
msgid "shared memory object"
msgstr "objet de mémoire partagée"

#: lib/file-type.c:68
msgid "typed memory object"
msgstr "objet mémoire typée"

#: lib/file-type.c:70
msgid "weird file"
msgstr "fichier bizarre"

#: lib/gai_strerror.c:44
msgid "Address family for hostname not supported"
msgstr "La famille d'adresses pour le nom de l'hôte n'est pas supporté."

#: lib/gai_strerror.c:45
msgid "Temporary failure in name resolution"
msgstr "Échec temporaire dans la résolution de nom"

#: lib/gai_strerror.c:46
msgid "Bad value for ai_flags"
msgstr "Valeur erronée pour ai_flags"

#: lib/gai_strerror.c:47
msgid "Non-recoverable failure in name resolution"
msgstr "Échec non récupérable dans la résolution de nom"

#: lib/gai_strerror.c:48
msgid "ai_family not supported"
msgstr "ai_family non supporté"

#: lib/gai_strerror.c:49
msgid "Memory allocation failure"
msgstr "Échec d'allocation mémoire"

#: lib/gai_strerror.c:50
msgid "No address associated with hostname"
msgstr "Aucune adresse associé avec le nom de l'hôte"

#: lib/gai_strerror.c:51
msgid "Name or service not known"
msgstr "Nom ou service inconnu"

#: lib/gai_strerror.c:52
msgid "Servname not supported for ai_socktype"
msgstr "Servname n'est pas supporté avec ai_socktype"

#: lib/gai_strerror.c:53
msgid "ai_socktype not supported"
msgstr "ai_socktype n'est pas supporté."

#: lib/gai_strerror.c:54
msgid "System error"
msgstr "Erreur système"

#: lib/gai_strerror.c:55
msgid "Argument buffer too small"
msgstr "Le tampon de l'argument est trop petit"

#: lib/gai_strerror.c:57
msgid "Processing request in progress"
msgstr "Requête de traitement en cours"

#: lib/gai_strerror.c:58
msgid "Request canceled"
msgstr "Requête annulée"

#: lib/gai_strerror.c:59
msgid "Request not canceled"
msgstr "Requête non annulée"

#: lib/gai_strerror.c:60
msgid "All requests done"
msgstr "Toutes les requêtes ont été traitées"

#: lib/gai_strerror.c:61
msgid "Interrupted by a signal"
msgstr "Interrompu par un signal"

#: lib/gai_strerror.c:62
msgid "Parameter string not correctly encoded"
msgstr "Paramètre de chaîne n'est pas correctement encodé"

#: lib/gai_strerror.c:74
msgid "Unknown error"
msgstr "Erreur inconnue"

#: lib/getopt.c:527 lib/getopt.c:543
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: l'option « %s » est ambiguë\n"

#: lib/getopt.c:576 lib/getopt.c:580
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: l'option « --%s » ne requiert pas un argument.\n"

#: lib/getopt.c:589 lib/getopt.c:594
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: l'option « %c%s » ne requiert pas un argument.\n"

#: lib/getopt.c:637 lib/getopt.c:656 lib/getopt.c:972 lib/getopt.c:991
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: l'option « %s » requiert un argument.\n"

#: lib/getopt.c:694 lib/getopt.c:697
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: option non reconnue « --%s »\n"

#: lib/getopt.c:705 lib/getopt.c:708
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: option non reconnue « %c%s »\n"

#: lib/getopt.c:760 lib/getopt.c:763
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: option illégale --%c\n"

#: lib/getopt.c:769 lib/getopt.c:772
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: option invalide --%c\n"

#: lib/getopt.c:824 lib/getopt.c:840 lib/getopt.c:1044 lib/getopt.c:1062
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: l'option requiert un argument --%c\n"

#: lib/getopt.c:893 lib/getopt.c:909
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: l'option « -W %s » est ambiguë\n"

#: lib/getopt.c:933 lib/getopt.c:951
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: l'option « -W %s » ne permet pas un argument.\n"

#: lib/mkdir-p.c:196 src/install.c:808
#, c-format
msgid "cannot change permissions of %s"
msgstr "Ne peut changer les permissions de %s"

#: lib/mkdir-p.c:206 src/copy.c:1890 src/install.c:705 src/install.c:718
#, c-format
msgid "cannot create directory %s"
msgstr "ne peut créer le répertoire %s"

#: lib/obstack.c:423 lib/obstack.c:425 lib/xalloc-die.c:34 src/csplit.c:220
msgid "memory exhausted"
msgstr "Mémoire épuisée"

#: lib/openat-die.c:34
#, c-format
msgid "unable to record current working directory"
msgstr "incapable d'enregistrer le répertoire de travail courant"

#: lib/openat-die.c:52 src/df.c:597
#, c-format
msgid "failed to return to initial working directory"
msgstr "échec de retour au répertoire initial de travail"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  If the catalog has no translation,
#. locale_quoting_style quotes `like this', and
#. clocale_quoting_style quotes "like this".
#.
#. For example, an American English Unicode locale should
#. translate "`" to U+201C (LEFT DOUBLE QUOTATION MARK), and
#. should translate "'" to U+201D (RIGHT DOUBLE QUOTATION
#. MARK).  A British English Unicode locale should instead
#. translate these to U+2018 (LEFT SINGLE QUOTATION MARK)
#. and U+2019 (RIGHT SINGLE QUOTATION MARK), respectively.
#.
#. If you don't know what to put here, please see
#. <http://en.wikipedia.org/wiki/Quotation_mark#Glyphs>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:272
msgid "`"
msgstr "`"

#: lib/quotearg.c:273
msgid "'"
msgstr "'"

#: lib/randread.c:118
#, c-format
msgid "%s: end of file"
msgstr "%s : fin de fichier"

#: lib/regcomp.c:137
msgid "Success"
msgstr "Succès"

#: lib/regcomp.c:140
msgid "No match"
msgstr "Pas de correspondance"

#: lib/regcomp.c:143
msgid "Invalid regular expression"
msgstr "Expression régulière invalide"

#: lib/regcomp.c:146
msgid "Invalid collation character"
msgstr "Caractère invalide dans une séquence"

#: lib/regcomp.c:149
msgid "Invalid character class name"
msgstr "Nom de classe de caractère invalide"

#: lib/regcomp.c:152
msgid "Trailing backslash"
msgstr "Slash inversé de fin"

#: lib/regcomp.c:155
msgid "Invalid back reference"
msgstr "Référence de retour invalide"

#: lib/regcomp.c:158
msgid "Unmatched [ or [^"
msgstr "[ ou [^ sans correspondance"

#: lib/regcomp.c:161
msgid "Unmatched ( or \\("
msgstr "( ou \\( sans correspondance"

#: lib/regcomp.c:164
msgid "Unmatched \\{"
msgstr "\\{ sans correspondance"

#: lib/regcomp.c:167
msgid "Invalid content of \\{\\}"
msgstr "Contenu de  \\{\\} invalide"

#: lib/regcomp.c:170
msgid "Invalid range end"
msgstr "Fin d'intervalle invalide"

#: lib/regcomp.c:173
msgid "Memory exhausted"
msgstr "Mémoire épuisée"

#: lib/regcomp.c:176
msgid "Invalid preceding regular expression"
msgstr "Expression régulière précédant invalide"

#: lib/regcomp.c:179
msgid "Premature end of regular expression"
msgstr "Fin prématurée d'expression régulière"

#: lib/regcomp.c:182
msgid "Regular expression too big"
msgstr "Expression régulière trop longue"

#: lib/regcomp.c:185
msgid "Unmatched ) or \\)"
msgstr ") ou \\) sans correspondance"

#: lib/regcomp.c:706
msgid "No previous regular expression"
msgstr "Pas d'expression régulière précédante"

#: lib/root-dev-ino.h:37
#, c-format
msgid "it is dangerous to operate recursively on %s"
msgstr "il est dangereux d'opérer récursivement sur %s"

#: lib/root-dev-ino.h:41
#, c-format
msgid "it is dangerous to operate recursively on %s (same as %s)"
msgstr "il est dangereux d'opérer récursivement sur %s (identique à %s)"

#: lib/root-dev-ino.h:43
#, c-format
msgid "use --no-preserve-root to override this failsafe"
msgstr "utiliser --no-preserve-root pour écraser cette mesure de sûreté"

#. TRANSLATORS: A regular expression testing for an affirmative answer
#. (english: "yes").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^yesexpr='
#: lib/rpmatch.c:147
msgid "^[yY]"
msgstr "^[yY]"

#. TRANSLATORS: A regular expression testing for a negative answer
#. (english: "no").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^noexpr='
#: lib/rpmatch.c:160
msgid "^[nN]"
msgstr "^[nN]"

#: lib/set-mode-acl.c:591 src/copy.c:1913 src/cp.c:512
#, c-format
msgid "setting permissions for %s"
msgstr "initialisation des permissions de %s"

#: lib/siglist.h:28
msgid "Hangup"
msgstr ""

#: lib/siglist.h:31
msgid "Interrupt"
msgstr ""

#: lib/siglist.h:34
msgid "Quit"
msgstr ""

#: lib/siglist.h:37
msgid "Illegal instruction"
msgstr ""

#: lib/siglist.h:40
msgid "Trace/breakpoint trap"
msgstr ""

#: lib/siglist.h:43
msgid "Aborted"
msgstr ""

#: lib/siglist.h:46
msgid "Floating point exception"
msgstr ""

#: lib/siglist.h:49
msgid "Killed"
msgstr ""

#: lib/siglist.h:52
#, fuzzy
msgid "Bus error"
msgstr "Erreur système"

#: lib/siglist.h:55
msgid "Segmentation fault"
msgstr ""

#: lib/siglist.h:58
msgid "Broken pipe"
msgstr ""

#: lib/siglist.h:61
msgid "Alarm clock"
msgstr ""

#: lib/siglist.h:64
msgid "Terminated"
msgstr ""

#: lib/siglist.h:67
msgid "Urgent I/O condition"
msgstr ""

#: lib/siglist.h:70
msgid "Stopped (signal)"
msgstr ""

#: lib/siglist.h:73
msgid "Stopped"
msgstr ""

#: lib/siglist.h:76
msgid "Continued"
msgstr ""

#: lib/siglist.h:79
msgid "Child exited"
msgstr ""

#: lib/siglist.h:82
msgid "Stopped (tty input)"
msgstr ""

#: lib/siglist.h:85
msgid "Stopped (tty output)"
msgstr ""

#: lib/siglist.h:88
msgid "I/O possible"
msgstr ""

#: lib/siglist.h:91
msgid "CPU time limit exceeded"
msgstr ""

#: lib/siglist.h:94
msgid "File size limit exceeded"
msgstr ""

#: lib/siglist.h:97
msgid "Virtual timer expired"
msgstr ""

#: lib/siglist.h:100
msgid "Profiling timer expired"
msgstr ""

#: lib/siglist.h:103
#, fuzzy
msgid "Window changed"
msgstr "changement d'horloge"

#: lib/siglist.h:106
#, fuzzy
msgid "User defined signal 1"
msgstr "%s: signal invalide"

#: lib/siglist.h:109
#, fuzzy
msgid "User defined signal 2"
msgstr "%s: signal invalide"

#: lib/siglist.h:114
msgid "EMT trap"
msgstr ""

#: lib/siglist.h:117
#, fuzzy
msgid "Bad system call"
msgstr "échec de l'appel système fork()"

#: lib/siglist.h:120
msgid "Stack fault"
msgstr ""

#: lib/siglist.h:123
msgid "Information request"
msgstr ""

#: lib/siglist.h:125
#, fuzzy
msgid "Power failure"
msgstr "fichier bizarre"

#: lib/siglist.h:128
msgid "Resource lost"
msgstr ""

#: lib/strsignal.c:109
#, fuzzy, c-format
msgid "Real-time signal %d"
msgstr "intervalle de temps invalide %s"

#: lib/strsignal.c:113
#, c-format
msgid "Unknown signal %d"
msgstr ""

#: lib/unicodeio.c:103
msgid "iconv function not usable"
msgstr "fonction iconv n'est pas utilisable"

#: lib/unicodeio.c:105
msgid "iconv function not available"
msgstr "fonction iconv n'est pas disponible"

#: lib/unicodeio.c:112
msgid "character out of range"
msgstr "caractère hors limites"

#: lib/unicodeio.c:180
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "ne peut convertir U+%04X à un jeu local de caractères"

#: lib/unicodeio.c:182
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "ne peut convertir U+%04X au jeu local de caractères: %s"

#: lib/userspec.c:106
msgid "invalid user"
msgstr "usager invalide"

#: lib/userspec.c:107
msgid "invalid group"
msgstr "groupe invalide"

#: lib/userspec.c:108
msgid "invalid spec"
msgstr "spec invalide"

#: lib/verror.c:73
#, c-format
msgid "unable to display error message"
msgstr "impossible d'afficher le message d'erreur"

#: lib/version-etc.c:74
#, c-format
msgid "Packaged by %s (%s)\n"
msgstr ""

#: lib/version-etc.c:77
#, c-format
msgid "Packaged by %s\n"
msgstr ""

#. TRANSLATORS: Translate "(C)" to the copyright symbol
#. (C-in-a-circle), if this symbol is available in the user's
#. locale.  Otherwise, do not translate "(C)"; leave it as-is.
#: lib/version-etc.c:84
msgid "(C)"
msgstr "©"

#: lib/version-etc.c:86
msgid ""
"\n"
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>.\n"
"This is free software: you are free to change and redistribute it.\n"
"There is NO WARRANTY, to the extent permitted by law.\n"
"\n"
msgstr ""
"\n"
"License GPLv3+: GNU GPL version 3 ou ultérieure <http://gnu.org/licenses/gpl."
"html>.\n"
"Ceci est un logiciel \"libre\" : vous êtes libre de le modifier et de le "
"redistribuer.\n"
"Ce logiciel n'offre pas d'autre garantie que celle imposée par la loi.\n"
"\n"

#. TRANSLATORS: %s denotes an author name.
#: lib/version-etc.c:102
#, c-format
msgid "Written by %s.\n"
msgstr "Écrit par %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:106
#, c-format
msgid "Written by %s and %s.\n"
msgstr "Écrit par %s et %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:110
#, c-format
msgid "Written by %s, %s, and %s.\n"
msgstr "Écrit par %s, %s et %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:117
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Écrit par %s, %s, %s,\n"
"et %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:124
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Écrit par %s, %s, %s,\n"
"%s et %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:131
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, and %s.\n"
msgstr ""
"Écrit par %s, %s, %s,\n"
"%s, %s, and %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:139
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"
msgstr ""
"Écrit par %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:147
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Écrit par %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"et %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:156
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Écrit par %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s et %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:167
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s, and others.\n"
msgstr ""
"Écrit par %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s et d'autres.\n"

#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: lib/version-etc.c:245
#, fuzzy, c-format
msgid ""
"\n"
"Report bugs to: %s\n"
msgstr ""
"\n"
"Signaler un bug à <%s>.\n"

#: lib/version-etc.c:247
#, fuzzy, c-format
msgid "Report %s bugs to: %s\n"
msgstr ""
"\n"
"Signaler %s bugs à %s\n"

#: lib/version-etc.c:251
#, fuzzy, c-format
msgid "%s home page: <%s>\n"
msgstr "Usage : %s\n"

#: lib/version-etc.c:253 src/system.h:591
#, c-format
msgid "%s home page: <http://www.gnu.org/software/%s/>\n"
msgstr "%s page d'accueil : <http://www.gnu.org/software/%s/>\n"

#: lib/version-etc.c:256 src/system.h:593
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "L'aide générale sur un logiciel GNU : <http://www.gnu.org/gethelp/>\n"

#: lib/xfreopen.c:35
msgid "stdin"
msgstr "stdin"

#: lib/xfreopen.c:36
msgid "stdout"
msgstr "stdout"

#: lib/xfreopen.c:37
msgid "stderr"
msgstr "stderr (erreur standard)"

#: lib/xfreopen.c:38
msgid "unknown stream"
msgstr "flux inconnu"

#: lib/xfreopen.c:39
#, c-format
msgid "failed to reopen %s with mode %s"
msgstr "la réouverture en mode %s de %s a échouée"

#: lib/xmemcoll.c:48 src/expr.c:885
#, c-format
msgid "string comparison failed"
msgstr "échec de comparaison de chaîne"

#: lib/xmemcoll.c:49
#, c-format
msgid "Set LC_ALL='C' to work around the problem."
msgstr "Définir LC_ALL=« C » pour contourner le problème."

#: lib/xmemcoll.c:51
#, c-format
msgid "The strings compared were %s and %s."
msgstr "Les chaînes comparées étaient %s et %s."

#: lib/xmemxfrm.c:54
#, c-format
msgid "string transformation failed"
msgstr "échec de transformation de chaîne"

#: lib/xmemxfrm.c:55 src/expr.c:886
#, c-format
msgid "set LC_ALL='C' to work around the problem"
msgstr "définir LC_ALL=«C» pour contourner le problème."

#: lib/xmemxfrm.c:57
#, c-format
msgid "the untransformed string was %s"
msgstr "la chaîne non transformée était %s"

#: lib/xprintf.c:50 lib/xprintf.c:76
#, c-format
msgid "cannot perform formatted output"
msgstr "ne peut exécuter le résultat formaté"

#: lib/xstrtol-error.c:63
#, c-format
msgid "invalid %s%s argument `%s'"
msgstr "%s%s argument invalide `%s'"

#: lib/xstrtol-error.c:68
#, c-format
msgid "invalid suffix in %s%s argument `%s'"
msgstr "suffixe invalide dans l'argument %s%s  `%s'"

#: lib/xstrtol-error.c:72
#, c-format
msgid "%s%s argument `%s' too large"
msgstr "%s%s argument `%s' trop grand"

#. This is a proper name. See the gettext manual, section Names.
#: src/base64.c:38
msgid "Simon Josefsson"
msgstr "Simon Josefsson"

#: src/base64.c:55 src/basename.c:46 src/cat.c:85 src/chcon.c:348
#: src/chgrp.c:106 src/chmod.c:360 src/chown.c:76 src/chroot.c:120
#: src/cksum.c:257 src/comm.c:99 src/cp.c:151 src/csplit.c:1442 src/cut.c:185
#: src/date.c:120 src/dd.c:464 src/df.c:799 src/dircolors.c:94
#: src/dirname.c:41 src/du.c:262 src/echo.c:39 src/env.c:49 src/expand.c:99
#: src/expr.c:200 src/factor.c:489 src/fmt.c:265 src/fold.c:62
#: src/getlimits.c:62 src/groups.c:50 src/head.c:104 src/hostid.c:40
#: src/hostname.c:53 src/id.c:78 src/install.c:936 src/join.c:164
#: src/kill.c:83 src/link.c:42 src/ln.c:332 src/logname.c:36 src/ls.c:4548
#: src/md5sum.c:149 src/mkdir.c:53 src/mkfifo.c:48 src/mknod.c:49
#: src/mktemp.c:65 src/mv.c:280 src/nice.c:68 src/nl.c:178 src/nohup.c:50
#: src/nproc.c:53 src/od.c:304 src/paste.c:429 src/pathchk.c:93
#: src/pinky.c:503 src/pr.c:2764 src/printenv.c:59 src/printf.c:85
#: src/ptx.c:1880 src/pwd.c:53 src/readlink.c:59 src/rm.c:132 src/rmdir.c:161
#: src/runcon.c:80 src/seq.c:66 src/setuidgid.c:46 src/shred.c:154
#: src/shuf.c:43 src/sleep.c:42 src/sort.c:314 src/split.c:99 src/stat.c:958
#: src/stdbuf.c:88 src/stty.c:510 src/su.c:365 src/sum.c:55 src/sync.c:37
#: src/tac.c:129 src/tail.c:245 src/tee.c:58 src/test.c:681 src/timeout.c:123
#: src/touch.c:211 src/tr.c:282 src/truncate.c:98 src/tsort.c:78 src/tty.c:61
#: src/uname.c:118 src/unexpand.c:109 src/uniq.c:130 src/unlink.c:42
#: src/uptime.c:197 src/users.c:102 src/wc.c:108 src/who.c:627 src/whoami.c:42
#: src/yes.c:38
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Pour en savoir davantage, faites: « %s --help ».\n"

#: src/base64.c:59
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"Base64 encode or decode FILE, or standard input, to standard output.\n"
"\n"
msgstr ""
"Usage : %s [OPTION]... [FICHIER]\n"
"Base64 encode ou bien décode FICHIER, ou l'entrée standard, sur la sortie "
"standard.\n"
"\n"

#: src/base64.c:63
msgid ""
"  -w, --wrap=COLS       Wrap encoded lines after COLS character (default "
"76).\n"
"                        Use 0 to disable line wrapping.\n"
"\n"
"  -d, --decode          Decode data.\n"
"  -i, --ignore-garbage  When decoding, ignore non-alphabet characters.\n"
"\n"
msgstr ""
"  -w, --wrap=COLS       retour à la ligne des lignes encodées après COLS "
"caractères (default 76).\n"
"                        Employer 0 pour éviter le retour à la ligne.\n"
"\n"
"  -d, --decode          Décode les données.\n"
"  -i, --ignore-garbage  Lors du décodage, ignore les caractères non "
"alphabétiques.\n"
"\n"

#: src/base64.c:71
msgid ""
"      --help            Display this help and exit.\n"
"      --version         Output version information and exit.\n"
msgstr ""
"      --help            Affiche cette aide et quitte.\n"
"      --version         Affiche les informations de version et quitte.\n"

#: src/base64.c:74 src/cat.c:111 src/fmt.c:292 src/shuf.c:70 src/sum.c:71
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#: src/base64.c:77
msgid ""
"\n"
"The data are encoded as described for the base64 alphabet in RFC 3548.\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal base64 alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"Les données sont encodées comme décrit pour l'alphabet base64 dans RFC "
"3548.\n"
"Lors du décodage, l'entrée peut contenir des retour à la ligne en plus des "
"octets de\n"
"l'alphabet base64 formel. Employer --ignore-garbage pour tenter de "
"récupérer\n"
"tout autre octet non alphabétique du flux encodé.\n"

#: src/base64.c:172 src/base64.c:209 src/csplit.c:263 src/csplit.c:1431
#: src/join.c:415 src/shuf.c:397 src/tac-pipe.c:74 src/tee.c:204 src/tr.c:1573
#, c-format
msgid "read error"
msgstr "Erreur de lecture."

#: src/base64.c:228
#, c-format
msgid "invalid input"
msgstr "entrée invalide"

#: src/base64.c:265
#, c-format
msgid "invalid wrap size: %s"
msgstr "taille d'enveloppe invalide : %s"

#: src/base64.c:284 src/basename.c:119 src/comm.c:433 src/cp.c:601
#: src/date.c:426 src/dircolors.c:448 src/dirname.c:97 src/du.c:928
#: src/hostid.c:76 src/hostname.c:112 src/id.c:169 src/install.c:612
#: src/join.c:897 src/link.c:86 src/ln.c:520 src/logname.c:72 src/mknod.c:158
#: src/mv.c:446 src/od.c:1802 src/ptx.c:2148 src/readlink.c:152 src/seq.c:410
#: src/shuf.c:377 src/sort.c:3536 src/split.c:531 src/tr.c:1726
#: src/tsort.c:548 src/tty.c:113 src/uname.c:253 src/uniq.c:453 src/uniq.c:470
#: src/unlink.c:82 src/uptime.c:255 src/users.c:147 src/wc.c:654 src/who.c:818
#: src/whoami.c:80
#, c-format
msgid "extra operand %s"
msgstr "opérande surnuméraire %s"

#: src/base64.c:310 src/cat.c:779
#, c-format
msgid "closing standard input"
msgstr "fermeture de l'entrée standard"

#. This is a proper name. See the gettext manual, section Names.
#: src/basename.c:40 src/chgrp.c:38 src/chmod.c:39 src/chown.c:36
#: src/comm.c:37 src/cp.c:57 src/csplit.c:42 src/cut.c:44 src/date.c:39
#: src/dd.c:47 src/df.c:40 src/dirname.c:34 src/du.c:53 src/env.c:33
#: src/expand.c:48 src/fold.c:35 src/groups.c:35 src/head.c:47 src/id.c:39
#: src/install.c:49 src/ln.c:40 src/ls.c:121 src/mkdir.c:36 src/mkfifo.c:33
#: src/mknod.c:34 src/mv.c:42 src/nice.c:40 src/nl.c:40 src/paste.c:52
#: src/pathchk.c:40 src/pinky.c:37 src/printenv.c:44 src/printf.c:63
#: src/rm.c:42 src/rmdir.c:38 src/stty.c:69 src/su.c:88 src/sum.c:38
#: src/tac.c:58 src/tail.c:62 src/tee.c:35 src/touch.c:45 src/tty.c:43
#: src/uname.c:61 src/unexpand.c:49 src/uniq.c:41 src/uptime.c:46
#: src/users.c:36 src/wc.c:50 src/who.c:45 src/yes.c:32
msgid "David MacKenzie"
msgstr "David MacKenzie"

#: src/basename.c:50
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s NOM [SUFFIXE]...\n"
"   ou: %s [OPTION]\n"

#: src/basename.c:55
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
"\n"
msgstr ""
"Afficher le NOM sans être précédé des composants des noms de répertoires\n"
"Si spécifié enlever aussi le SUFFIXE.\n"
"\n"

#: src/basename.c:62
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort       Output \"sort\".\n"
"  %s include/stdio.h .h  Output \"stdio\".\n"
msgstr ""
"\n"
"Exemples:\n"
"  %s /usr/bin/sort       sortie \"sort\".\n"
"  %s include/stdio.h .h  sortie \"stdio\".\n"

#: src/basename.c:113 src/chcon.c:524 src/chgrp.c:273 src/chmod.c:511
#: src/chown.c:275 src/chroot.c:186 src/comm.c:425 src/csplit.c:1369
#: src/dirname.c:91 src/expr.c:325 src/join.c:1075 src/link.c:78
#: src/mkdir.c:184 src/mkfifo.c:109 src/mknod.c:147 src/nohup.c:112
#: src/pathchk.c:156 src/printf.c:675 src/readlink.c:144 src/rm.c:323
#: src/rmdir.c:223 src/seq.c:404 src/setuidgid.c:137 src/sleep.c:121
#: src/stat.c:1110 src/stdbuf.c:346 src/tr.c:1711 src/unlink.c:76
#, c-format
msgid "missing operand"
msgstr "opérande manquante"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:48 src/cp.c:56 src/df.c:39 src/du.c:52 src/split.c:44
msgid "Torbjorn Granlund"
msgstr "Torbjorn Granlund"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:49 src/comm.c:36 src/ls.c:120 src/rm.c:43 src/split.c:45
#: src/tee.c:34 src/uniq.c:40
msgid "Richard M. Stallman"
msgstr "Richard M. Stallman"

#: src/cat.c:89 src/df.c:803 src/expand.c:103 src/fold.c:66 src/head.c:108
#: src/ls.c:4552 src/nl.c:182 src/paste.c:433 src/pr.c:2768 src/sum.c:59
#: src/tac.c:133 src/tail.c:249 src/tee.c:62 src/unexpand.c:113
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Usage: %s [OPTION]... [FICHIER]...\n"

#: src/cat.c:93
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonempty output lines\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      suppress repeated empty output lines\n"
msgstr ""
"Concatène FICHIER(s), ou l'entrée standard, sur la sortie standard.\n"
"\n"
"  -A, --show-all           équivalent à -vET\n"
"  -b, --number-nonblank    numérote les lignes non vides en sortie\n"
"  -e                       équivalent à -vE\n"
"  -E, --show-ends          affiche $ à la fin de chaque ligne\n"
"  -n, --number             numérote toutes les lignes en sortie\n"
"  -s, --squeeze-blank      supprime les lignes vides qui se répètent en "
"sortie\n"

#: src/cat.c:103
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       équivalent à -vT\n"
"  -T, --show-tabs          afficher les caractères TAB comme ^I\n"
"  -u                       (ignoré)\n"
"  -v, --show-nonprinting   utiliser la notation ^ et M- ,\n"
"                            excepté pour LFD et TAB\n"

#: src/cat.c:115
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s f - g  Output f's contents, then standard input, then g's contents.\n"
"  %s        Copy standard input to standard output.\n"
msgstr ""
"\n"
"Exemples:\n"
"  %s f - g  sortie du contenu de f, ensuite sur l'entrée standard, ensuite "
"le contenu de g.\n"
"  %s        copier l'entrée standard var la sortie standard.\n"

#: src/cat.c:327
#, c-format
msgid "cannot do ioctl on %s"
msgstr "ne peut exécuter ioctl sur %s"

#: src/cat.c:637 src/dd.c:1883 src/sort.c:306 src/tee.c:163 src/yes.c:88
#, c-format
msgid "standard output"
msgstr "sortie standard"

#: src/cat.c:714
#, c-format
msgid "%s: input file is output file"
msgstr "%s: le fichier à l'entrée est le même qu'à la sortie."

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:36 src/runcon.c:62
msgid "Russell Coker"
msgstr "Russell Coker"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:37 src/chgrp.c:39 src/chmod.c:40 src/chown.c:37 src/cp.c:58
#: src/cut.c:45 src/dirname.c:35 src/du.c:55 src/head.c:48 src/hostid.c:34
#: src/hostname.c:33 src/mktemp.c:36 src/mv.c:43 src/nohup.c:37 src/od.c:35
#: src/pathchk.c:41 src/pwd.c:31 src/rm.c:44 src/setuidgid.c:38 src/sleep.c:35
#: src/sync.c:31 src/tail.c:64 src/tr.c:36 src/true.c:33
msgid "Jim Meyering"
msgstr "Jim Meyering"

#: src/chcon.c:100 src/runcon.c:204 src/runcon.c:235
#, c-format
msgid "failed to create security context: %s"
msgstr "échec de création du contexte de sécurité : %s"

#: src/chcon.c:112
#, c-format
msgid "failed to set %s security context component to %s"
msgstr "a échoué à établir %s le composant du contexte de sécurité à %s"

#: src/chcon.c:156 src/chcon.c:533 src/copy.c:1851 src/runcon.c:218
#: src/stat.c:491
#, c-format
msgid "failed to get security context of %s"
msgstr "échec de récupération du contexte de sécurité de %s"

#: src/chcon.c:166
#, c-format
msgid "can't apply partial context to unlabeled file %s"
msgstr "ne peut appliquer un contexte partiel au fichier non étiquetté %s"

#: src/chcon.c:193
#, c-format
msgid "failed to change context of %s to %s"
msgstr "échec lors du changement de contexte de %s à %s"

#: src/chcon.c:255 src/chmod.c:208 src/chown-core.c:301 src/copy.c:295
#: src/du.c:481 src/ls.c:2820
#, c-format
msgid "cannot access %s"
msgstr "ne peut accéder %s"

#: src/chcon.c:260 src/chmod.c:215 src/chown-core.c:308 src/du.c:486
#, c-format
msgid "%s"
msgstr "%s"

#: src/chcon.c:265 src/chmod.c:221 src/chown-core.c:314 src/du.c:492
#, c-format
msgid "cannot read directory %s"
msgstr "ne peut lire le répertoire %s"

#: src/chcon.c:292
#, c-format
msgid "changing security context of %s\n"
msgstr "changement du contexte de sécurité de %s\n"

#: src/chcon.c:326 src/chmod.c:338 src/chown-core.c:510 src/du.c:640
#: src/remove.c:616
#, c-format
msgid "fts_read failed"
msgstr "Échec de fts_read"

#: src/chcon.c:337 src/chmod.c:349 src/chown-core.c:522 src/du.c:652
#: src/remove.c:630
#, fuzzy, c-format
msgid "fts_close failed"
msgstr "Échec de fermeture"

#: src/chcon.c:352
#, c-format
msgid ""
"Usage: %s [OPTION]... CONTEXT FILE...\n"
"  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Usage : %s [OPTION]... CONTEXT FILE...\n"
"  or :  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or :  %s [OPTION]... --reference=RFILE FILE...\n"

#: src/chcon.c:358
msgid ""
"Change the security context of each FILE to CONTEXT.\n"
"With --reference, change the security context of each FILE to that of "
"RFILE.\n"
"\n"
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
msgstr ""
"Etablit le contexte de sécurité de chaque FICHIER à CONTEXT.\n"
"Avec --reference, établit le contexte de sécurité de chaque FICHIER à celui "
"de RFILE.\n"
"\n"
"  -h, --no-dereference   affecte les liens symboliques au lieu du fichier "
"référencé\n"

#: src/chcon.c:364
msgid ""
"      --reference=RFILE  use RFILE's security context rather than "
"specifying\n"
"                         a CONTEXT value\n"
"  -R, --recursive        operate on files and directories recursively\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"      --reference=RFILE  utilise le contexte de sécurité de RFILE au lieu de "
"spécifier\n"
"                         une valeur CONTEXT\n"
"  -R, --recursive        agit sur les fichiers et répertoires récursivement\n"
"  -v, --verbose          affiche un diagnostique pour chaque fichier traité\n"

#: src/chcon.c:370
msgid ""
"  -u, --user=USER        set user USER in the target security context\n"
"  -r, --role=ROLE        set role ROLE in the target security context\n"
"  -t, --type=TYPE        set type TYPE in the target security context\n"
"  -l, --range=RANGE      set range RANGE in the target security context\n"
"\n"
msgstr ""
"  -u, --user=USER        établit l'usager USER dans le contexte de sécurité "
"cible\n"
"  -r, --role=ROLE        établit le rôle ROLE dans le contexte de sécurité "
"cible\n"
"  -t, --type=TYPE        établit le type TYPE dans le contexte de sécurité "
"cible\n"
"  -l, --range=RANGE      établit l'intervalle RANGE dans le contexte de "
"sécurité cible\n"
"\n"

#: src/chcon.c:377 src/chgrp.c:140 src/chown.c:117
msgid ""
"The following options modify how a hierarchy is traversed when the -R\n"
"option is also specified.  If more than one is specified, only the final\n"
"one takes effect.\n"
"\n"
"  -H                     if a command line argument is a symbolic link\n"
"                         to a directory, traverse it\n"
"  -L                     traverse every symbolic link to a directory\n"
"                         encountered\n"
"  -P                     do not traverse any symbolic links (default)\n"
"\n"
msgstr ""
"Les options suivantes modifient comment la hiérarchie est traversée lors "
"que\n"
"l'option -R est aussi spécifié.  Si plus d'une option est spécifiée, seule "
"la dernière\n"
"prend effet.\n"
"\n"
"  -H                     si l'argument de la ligne de commande est un lien "
"symbolique\n"
"                         vers un répertoire alors le parcourir\n"
"  -L                     parcourir chaque lien symbolique menant à un "
"répertoire\n"
"                         rencontré\n"
"  -P                     ne pas parcourir aucun lien symbolique (par "
"défaut)\n"
"\n"

#: src/chcon.c:505 src/chgrp.c:260 src/chown.c:262
#, c-format
msgid "-R --dereference requires either -H or -L"
msgstr "-R --dereference requiert soit -H ou -L"

#: src/chcon.c:511
#, c-format
msgid "-R -h requires -P"
msgstr "-R -h requiert -P"

#: src/chcon.c:526 src/chgrp.c:275 src/chmod.c:513 src/chown.c:277
#: src/comm.c:427 src/csplit.c:1371 src/join.c:1077 src/link.c:80
#: src/mknod.c:149 src/setuidgid.c:139 src/tr.c:1714
#, c-format
msgid "missing operand after %s"
msgstr "opérande manquante après %s"

#: src/chcon.c:549 src/runcon.c:248
#, c-format
msgid "invalid context: %s"
msgstr "contexte invalide : %s"

#: src/chcon.c:556
#, c-format
msgid "conflicting security context specifiers given"
msgstr "paramètres de contexte de sécurité donnés en conflit"

#: src/chcon.c:565 src/chgrp.c:283 src/chgrp.c:301 src/chmod.c:521
#: src/chmod.c:540 src/chown.c:285 src/chown.c:314 src/cp.c:427 src/cp.c:487
#: src/mv.c:96 src/pwd.c:274 src/rm.c:333 src/touch.c:356
#, c-format
msgid "failed to get attributes of %s"
msgstr "échec d'obtention des attributs de %s"

#: src/chgrp.c:93
#, c-format
msgid "invalid group: %s"
msgstr "groupe invalide : %s"

#: src/chgrp.c:110
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Usage: %s [OPTION]... GROUPE FICHIER...\n"
"   ou: %s [OPTION]... --reference=FICHIER-R FICHIER...\n"

#: src/chgrp.c:115
msgid ""
"Change the group of each FILE to GROUP.\n"
"With --reference, change the group of each FILE to that of RFILE.\n"
"\n"
"  -c, --changes          like verbose but report only when a change is made\n"
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
msgstr ""
"Etablit le groupe de chaque FICHIER à GROUPE.\n"
"Avec l'option --reference, établit le groupe de chaque FICHIER à celui de R-"
"FICHIER.\n"
"\n"
"  -c, --changes             comme verbeux mais rapporte seulement les "
"changements faits\n"
"      --dereference         affecte le référent de chaque lien symbolique"
"(par défaut),\n"
"                            plutôt que le lien symbolique lui-même\n"

#: src/chgrp.c:123 src/chown.c:93
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""
"  -h, --no-dereference      modifier les liens symboliques au lieu des\n"
"                            fichiers référencés (utile seulement\n"
"                             sur les systèmes permettant de changer le "
"propriétaire\n"
"                             d'un lien symbolique)\n"

#: src/chgrp.c:128 src/chown.c:105
msgid ""
"      --no-preserve-root  do not treat `/' specially (the default)\n"
"      --preserve-root    fail to operate recursively on `/'\n"
msgstr ""
"      --no-preserve-root  ne pas traiter `/' de manière spéciale (par "
"défaut)\n"
"      --preserve-root     fait échouer le traitement récursif sur `/'\n"

#: src/chgrp.c:132
msgid ""
"  -f, --silent, --quiet  suppress most error messages\n"
"      --reference=RFILE  use RFILE's group rather than specifying a\n"
"                         GROUP value\n"
"  -R, --recursive        operate on files and directories recursively\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
"\n"
msgstr ""
"  -f, --silent, --quiet     supprime la plupart des messages d'erreur\n"
"      --reference=RFICHIER   utilise le groupe de RFICHIER\n"
"                            au lieu d'une valeur GROUPE\n"
"  -R, --recursive           agit récursivement sur les fichiers et "
"répertoires\n"
"  -v, --verbose             produit un diagnostic pour chaque fichier "
"traité\n"
"\n"

#: src/chgrp.c:154
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s staff /u      Change the group of /u to \"staff\".\n"
"  %s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n"
msgstr ""
"\n"
"Exemples:\n"
"  %s staff /u      changer le groupe de /u vers \"staff\".\n"
"  %s -hR staff /u  changer le groupe de /u et des sous-fichiers vers \"staff"
"\".\n"

#: src/chmod.c:126
#, c-format
msgid "getting new attributes of %s"
msgstr "obtention des nouveaux attributs de %s"

#: src/chmod.c:148 src/chown-core.c:119
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr "Ni le lien symbolique %s ni la référence n'ont changé.\n"

#: src/chmod.c:158
#, c-format
msgid "mode of %s changed to %04lo (%s)\n"
msgstr "Le mode d'accès de %s a été modifié à %04lo (%s).\n"

#: src/chmod.c:161
#, c-format
msgid "failed to change mode of %s to %04lo (%s)\n"
msgstr "Échec du changement de mode de %s à %04lo (%s).\n"

#: src/chmod.c:164
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "Le mode d'accès de %s qui a été conservé est: %04lo (%s).\n"

#: src/chmod.c:228
#, c-format
msgid "cannot operate on dangling symlink %s"
msgstr "ne peut opérer sur un lien symbolique lâche %s"

#: src/chmod.c:268
#, c-format
msgid "changing permissions of %s"
msgstr "modification des permissions de %s"

#: src/chmod.c:303
#, c-format
msgid "%s: new permissions are %s, not %s"
msgstr "%s: les nouvelles permissions sont %s, et non pas %s"

#: src/chmod.c:364
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Usage: %s [OPTION]... MODE[,MODE]... FICHIER...\n"
"   ou: %s [OPTION]... MODE-OCTAL FICHIER\n"
"   ou: %s [OPTION]... --reference=FICHIER-R FICHIER\n"

#: src/chmod.c:370
msgid ""
"Change the mode of each FILE to MODE.\n"
"\n"
"  -c, --changes           like verbose but report only when a change is "
"made\n"
msgstr ""
"Changer le mode de chaque fichier selon le MODE choisi.\n"
"\n"
"  -c, --changes           identique à verbose mais rapporte seulement les "
"changements lorsqu'ils ont lieu\n"

#: src/chmod.c:375
msgid ""
"      --no-preserve-root  do not treat `/' specially (the default)\n"
"      --preserve-root     fail to operate recursively on `/'\n"
msgstr ""
"      --no-preserve-root  ne pas traiter `/' de manière spéciale (par "
"défaut)\n"
"      --preserve-root     bloquer le traitement récursif sur `/'\n"

#: src/chmod.c:379
msgid ""
"  -f, --silent, --quiet   suppress most error messages\n"
"  -v, --verbose           output a diagnostic for every file processed\n"
"      --reference=RFILE   use RFILE's mode instead of MODE values\n"
"  -R, --recursive         change files and directories recursively\n"
msgstr ""
"  -f, --silent, --quiet   supprimer la plupart des messages d'erreur\n"
"  -v, --verbose           produire un diagnostic pour chaque fichier traité\n"
"      --reference=FICHIER utiliser les modes d'accès du FICHIER de "
"référence\n"
"                          au lieu de valeurs\n"
"  -R, --recursive         modifier récursivement fichiers et répertoires\n"

#: src/chmod.c:387
msgid ""
"\n"
"Each MODE is of the form `[ugoa]*([-+=]([rwxXst]*|[ugo]))+'.\n"
msgstr ""
"\n"
"Chaque MODE a la forme `[ugoa]*([-+=]([rwxXst]*|[ugo]))+'.\n"

#: src/chmod.c:498
#, c-format
msgid "cannot combine mode and --reference options"
msgstr "ne peut combiner les options mode et --reference"

#: src/chmod.c:529
#, c-format
msgid "invalid mode: %s"
msgstr "mode invalide: %s"

#: src/chown-core.c:145
#, c-format
msgid "changed ownership of %s to %s\n"
msgstr "Changement de propriétaire de %s vers %s\n"

#: src/chown-core.c:146
#, c-format
msgid "changed group of %s to %s\n"
msgstr "Changement de groupe de %s vers %s\n"

#: src/chown-core.c:147
#, c-format
msgid "no change to ownership of %s\n"
msgstr "ne peut changer l'appartenance de %s\n"

#: src/chown-core.c:150
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "échec de changement de propriétaire de %s vers %s\n"

#: src/chown-core.c:151
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "Échec de changement de groupe de %s vers %s\n"

#: src/chown-core.c:152
#, c-format
msgid "failed to change ownership of %s\n"
msgstr "échec de changement de propriétaire de %s\n"

#: src/chown-core.c:155
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "L'appartenance de %s qui a été retenue est %s\n"

#: src/chown-core.c:156
#, c-format
msgid "group of %s retained as %s\n"
msgstr "Le groupe d'appartenance de %s qui a été retenu est %s.\n"

#: src/chown-core.c:157
#, c-format
msgid "ownership of %s retained\n"
msgstr "l'appartenance de %s a été retenue\n"

#: src/chown-core.c:355
#, c-format
msgid "cannot dereference %s"
msgstr "ne peut effectuer une déférence sur %s"

#: src/chown-core.c:443
#, c-format
msgid "changing ownership of %s"
msgstr "changement de propriétaire pour %s"

#: src/chown-core.c:444
#, c-format
msgid "changing group of %s"
msgstr "modification du groupe de %s"

#: src/chown.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Usage: %s [OPTION]... [PROPRIÉTAIRE][:GROUPE] FICHIER...\n"
"   ou: %s [OPTION]... --reference=FICHIER-R FICHIER...\n"

#: src/chown.c:85
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"With --reference, change the owner and group of each FILE to those of "
"RFILE.\n"
"\n"
"  -c, --changes          like verbose but report only when a change is made\n"
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
msgstr ""
"Etablit le propriétaire et/ou le groupe de chaque FICHIER à PROPRIÉTAIRE et/"
"ou à GROUPE.\n"
"Avec l'option --reference, établit le propriétaire et le groupe de chaque "
"FICHIER à ceux de RFICHIER.\n"
"\n"
"  -c, --changes             comme verbeux mais rapporte seulement les "
"modifications faites\n"
"      --dereference         affecte le référent de chaque lien symbolique"
"(par défaut),\n"
"                            plutôt que le lien symbolique lui-même\n"

#: src/chown.c:98
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute.\n"
msgstr ""
"      --from=PROPRIÉTAIRE_COURANT:GROUPE_COURANT\n"
"                            changer le propriétaire et/ou le groupe de "
"chaque fichier\n"
"                            seulement s'il y a concordance avec le "
"propriétaire\n"
"                            et/ou groupe courant spécifié. Les deux peuvent "
"être\n"
"                            omis, auquel cas la concordance n'est pas "
"requise pour\n"
"                            l'argument non spécifié.\n"

#: src/chown.c:109
msgid ""
"  -f, --silent, --quiet  suppress most error messages\n"
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
"  -R, --recursive        operate on files and directories recursively\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
"\n"
msgstr ""
"  -f, --silent, --quiet     supprime la plupart des messages d'erreur\n"
"      --reference=RFICHIER  utilise le propriétaire et le groupe de "
"RFICHIER\n"
"                            au lieu de valeurs explicites PROPRIÉTAIRE:"
"GROUPE\n"
"  -R, --recursive           agit récursivement sur fichiers et répertoires\n"
"  -v, --verbose             affiche un diagnostique pour chaque fichier "
"traité\n"
"\n"

#: src/chown.c:131
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a `:' following a symbolic OWNER.\n"
"OWNER and GROUP may be numeric as well as symbolic.\n"
msgstr ""
"\n"
"Le propriétaire n'est pas modifié si manquant.  Le groupe n'est pas modifié "
"si manquant,\n"
"mais modifié au groupe de login implicite si « : » en suivant le PROPRIÉTAIRE "
"symbolique.\n"
"Le PROPRIÉTAIRE et le GROUPE peuvent être numérique ou symbolique.\n"

#: src/chown.c:137
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s root /u        Change the owner of /u to \"root\".\n"
"  %s root:staff /u  Likewise, but also change its group to \"staff\".\n"
"  %s -hR root /u    Change the owner of /u and subfiles to \"root\".\n"
msgstr ""
"\n"
"Exemples:\n"
"  %s root /u        changer le propriétaire de /u vers \"root\".\n"
"  %s root:staff /u  idem mais aussi changer son groupe à \"staff\".\n"
"  %s -hR root /u    changer le propriétaire de /u et des sous fichiers vers "
"\"root\".\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/chroot.c:36
msgid "Roland McGrath"
msgstr "Roland McGrath"

#: src/chroot.c:88 src/install.c:900 src/setuidgid.c:110 src/setuidgid.c:120
#, c-format
msgid "invalid group %s"
msgstr "groupe invalide %s"

#: src/chroot.c:100
#, fuzzy, c-format
msgid "invalid group list %s"
msgstr "groupe invalide %s"

#: src/chroot.c:108
#, fuzzy, c-format
msgid "failed to set additional groups"
msgstr "ne peut établir de groupe(s) supplémentaire(s)"

#: src/chroot.c:124
#, fuzzy, c-format
msgid ""
"Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage : %s RACINE [COMMANDE [ARG]...]\n"
"  ou : %s OPTION\n"

#: src/chroot.c:129
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr ""
"Exécuter la COMMANDE avec le répertoire root initialisé à NOUVEAU-ROOT.\n"
"\n"

#: src/chroot.c:134
msgid ""
"  --userspec=USER:GROUP  specify user and group (ID or name) to use\n"
"  --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n"
msgstr ""

#: src/chroot.c:141
msgid ""
"\n"
"If no command is given, run ``${SHELL} -i'' (default: /bin/sh).\n"
msgstr ""
"\n"
"Si aucune commande n'est fournie, exécuter ``${SHELL} -i'' (par défaut: /bin/"
"sh).\n"

#: src/chroot.c:191
#, c-format
msgid "cannot change root directory to %s"
msgstr "ne peut changer le répertoire racine vers %s"

#: src/chroot.c:195
#, c-format
msgid "cannot chdir to root directory"
msgstr "ne peut aller vers le répertoire root"

#: src/chroot.c:236
#, fuzzy, c-format
msgid "failed to set group-ID"
msgstr "échec à la création d'un nouveau rôle %s"

#: src/chroot.c:242
#, fuzzy, c-format
msgid "failed to set user-ID"
msgstr "échec de création de nouvel usager %s"

#: src/chroot.c:264 src/nohup.c:233 src/setuidgid.c:213 src/stdbuf.c:366
#: src/timeout.c:298
#, fuzzy, c-format
msgid "failed to run command %s"
msgstr "ne peut exécuter la commande %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/cksum.c:40
msgid "Q. Frank Xia"
msgstr "Q. Frank Xia"

#: src/cksum.c:213
#, c-format
msgid "%s: file too long"
msgstr "%s: fichier trop long"

#: src/cksum.c:261
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Usage: %s [FICHIER]...\n"
"   ou: %s [OPTION]\n"

#: src/cksum.c:266
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
"FICHIER.\n"
"\n"

#: src/comm.c:103 src/join.c:168
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Usage: %s [OPTION]... FICHIER1  FICHIER2\n"

#: src/comm.c:107
msgid "Compare sorted files FILE1 and FILE2 line by line.\n"
msgstr "Comparer les fichiers triés GAUCHE et DROITE ligne par ligne.\n"

#: src/comm.c:110
msgid ""
"\n"
"With no options, produce three-column output.  Column one contains\n"
"lines unique to FILE1, column two contains lines unique to FILE2,\n"
"and column three contains lines common to both files.\n"
msgstr ""
"\n"
"Sans option, la sortie se fait sur 3 colonnes.  La première colonne "
"contient\n"
"les lignes uniques au FICHIER1, la seconde contient les lignes uniques au "
"FICHIER2,\n"
"et la troisième contient les lignes communes aux deux fichiers.\n"

#: src/comm.c:116
#, fuzzy
msgid ""
"\n"
"  -1              suppress column 1 (lines unique to FILE1)\n"
"  -2              suppress column 2 (lines unique to FILE2)\n"
"  -3              suppress column 3 (lines that appear in both files)\n"
msgstr ""
"\n"
"  -1              supprimer les lignes uniques du fichier de gauche\n"
"  -2              supprimer les lignes uniques du fichier de droite\n"
"  -3              supprimer les lignes uniques des 2 fichiers\n"

#: src/comm.c:122
msgid ""
"\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
msgstr ""
"\n"
"  --check-order     vérifie que l'entrée est triée, même\n"
"                      si toutes les lignes en entrée sont appairées\n"
"  --nocheck-order   ne vérifie pas que l'entrée est triée\n"

#: src/comm.c:128
msgid "  --output-delimiter=STR  separate columns with STR\n"
msgstr "  --output-delimiter=STR  sépare les colonnes avec STR\n"

#: src/comm.c:133
msgid ""
"\n"
"Note, comparisons honor the rules specified by `LC_COLLATE'.\n"
msgstr ""

#: src/comm.c:137
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s -12 file1 file2  Print only lines present in both file1 and file2.\n"
"  %s -3  file1 file2  Print lines in file1 not in file2, and vice versa.\n"
msgstr ""

#: src/comm.c:222 src/join.c:368
#, c-format
msgid "file %d is not in sorted order"
msgstr "fichier %d n'est pas dans l'ordre attendu"

#: src/comm.c:405
#, c-format
msgid "multiple delimiters specified"
msgstr "multiples délimiteurs spécifiés"

#: src/comm.c:409
#, c-format
msgid "empty %s not allowed"
msgstr "%s vide n'est pas autorisé"

#: src/copy.c:371
#, c-format
msgid "clearing permissions for %s"
msgstr "réinitialisation des permissions de %s"

#: src/copy.c:405 src/copy.c:2087 src/cp.c:325
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "échec de préservation du propriétaire pour %s"

#: src/copy.c:431
#, c-format
msgid "failed to lookup file %s"
msgstr "échec de repérage du fichier `%s'"

#: src/copy.c:436
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "échec de préservation du propriétaire pour %s"

#: src/copy.c:495 src/csplit.c:630 src/du.c:935 src/fmt.c:427 src/head.c:850
#: src/sort.c:3548 src/split.c:538 src/tac.c:544 src/tail.c:1603 src/wc.c:666
#, c-format
msgid "cannot open %s for reading"
msgstr "Ne peut ouvrir %s en lecture"

#: src/copy.c:501 src/copy.c:629 src/dd.c:1298 src/dd.c:1926 src/tail.c:1439
#: src/tail.c:1505 src/truncate.c:150 src/truncate.c:234
#, c-format
msgid "cannot fstat %s"
msgstr "ne peut évaluer par fstat() %s"

#: src/copy.c:511
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "escamotage du fichier %s, parce qu'il a été remplacé durant la copie"

#: src/copy.c:535
#, c-format
msgid "failed to get file system create context"
msgstr "échec de récupération du contexte de création du système de fichiers"

#: src/copy.c:549
#, c-format
msgid "failed to set the security context of %s to %s"
msgstr "échec de changement de contexte de sécurité de  %s à %s"

#: src/copy.c:566 src/copy.c:1388 src/copy.c:1542 src/copy.c:1692 src/ln.c:277
#: src/remove.c:292 src/remove.c:318 src/remove.c:461 src/remove.c:482
#, c-format
msgid "cannot remove %s"
msgstr "ne peut enlever %s"

#: src/copy.c:571 src/copy.c:1383 src/copy.c:1547 src/copy.c:1696
#: src/remove.c:435
#, c-format
msgid "removed %s\n"
msgstr "détruit %s\n"

#: src/copy.c:608
#, c-format
msgid "not writing through dangling symlink %s"
msgstr "n'écrit pas à travers le symlink détaché %s"

#: src/copy.c:621
#, c-format
msgid "cannot create regular file %s"
msgstr "ne peut créer le fichier régulier %s"

#: src/copy.c:641
#, fuzzy, c-format
msgid "failed to clone %s"
msgstr "échec d'ouverture de %s"

#: src/copy.c:720 src/dd.c:1358 src/dd.c:1683
#, c-format
msgid "reading %s"
msgstr "lecture de %s"

#: src/copy.c:766 src/head.c:429
#, c-format
msgid "cannot lseek %s"
msgstr "ne peut repérer par lseek() %s"

#: src/copy.c:779 src/copy.c:808 src/dd.c:1740 src/dd.c:1803
#, c-format
msgid "writing %s"
msgstr "écriture de %s"

#: src/copy.c:823 src/copy.c:2146
#, c-format
msgid "preserving times for %s"
msgstr "préservation des dates pour %s"

#: src/copy.c:893 src/copy.c:899 src/head.c:858 src/touch.c:174
#: src/truncate.c:408
#, c-format
msgid "closing %s"
msgstr "fermeture de %s"

#: src/copy.c:1133
#, c-format
msgid "%s: try to overwrite %s, overriding mode %04lo (%s)? "
msgstr "%s : essaye de réécrire %s, en outrepassant le mode %04lo (%s) ? "

#: src/copy.c:1140
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s: écraser %s?"

#: src/copy.c:1209
#, c-format
msgid " (backup: %s)"
msgstr " (archiver: %s)"

#: src/copy.c:1219
#, c-format
msgid "failed to restore the default file creation context"
msgstr "échec de restauration du contexte par défaut de création de fichier"

#: src/copy.c:1275
#, c-format
msgid "omitting directory %s"
msgstr "omission du répertoire %s"

#: src/copy.c:1289
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "AVERTISSEMENT: fichier source %s spécifié plus d'une fois"

#: src/copy.c:1337 src/ln.c:212
#, c-format
msgid "%s and %s are the same file"
msgstr "%s et %s identifient le même fichier."

#: src/copy.c:1417
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "ne peut écraser le non-répertoire %s par le répertoire %s"

#: src/copy.c:1435 src/ln.c:180
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "n'écrasera pas %s qui vient d'être créé par %s"

#: src/copy.c:1453
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "ne peut écraser le répertoire %s par un non-répertoire"

#: src/copy.c:1467
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr "ne peut déplacer le répertoire dans un non-répertoire: %s -> %s"

#: src/copy.c:1497
#, c-format
msgid "backing up %s would destroy source;  %s not moved"
msgstr "L'archivage de %s pourrait détruire la source: %s n'a pas été déplacé."

#: src/copy.c:1498
#, c-format
msgid "backing up %s would destroy source;  %s not copied"
msgstr ""
"L'archivage de %s pourrait détruire le fichier SOURCE:\n"
"%s n'a pas été copié."

#: src/copy.c:1517 src/ln.c:242
#, c-format
msgid "cannot backup %s"
msgstr "ne peut archiver %s"

#: src/copy.c:1581
#, c-format
msgid "will not copy %s through just-created symlink %s"
msgstr "ne copiera pas %s depuis le symlink qui vient juste d'être créé %s"

#: src/copy.c:1658
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "ne peut copier un répertoire %s dans lui-même %s"

#: src/copy.c:1675
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "ne peut créer un lien direct %s vers le répertoire %s"

#: src/copy.c:1703
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "ne peut créer un lien direct %s vers %s"

#: src/copy.c:1748
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "ne peut déplacer %s vers un sous-répertoire de lui-même %s"

#: src/copy.c:1791
#, c-format
msgid "cannot move %s to %s"
msgstr "ne peut déplacer %s vers %s"

#: src/copy.c:1803
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr ""
"échec de déplacement inter-périphérique: %s vers %s; incapable de détruire "
"la cible"

#: src/copy.c:1835 src/install.c:588 src/mkdir.c:190 src/mkfifo.c:115
#: src/mknod.c:168
#, c-format
msgid "failed to set default file creation context to %s"
msgstr ""
"échec lors de l'établissement du contexte de création de fichier par défaut "
"à %s"

#: src/copy.c:1870
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "ne peut copier des liens symboliques cycliques %s."

#: src/copy.c:1975
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr ""
"%s: peut créer des liens symboliques relatifs\n"
"seulement que dans le répertoire courant."

#: src/copy.c:1982
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "ne peut créer un lien symbolique %s vers %s"

#: src/copy.c:1998
#, c-format
msgid "cannot create link %s"
msgstr "ne peut créer le lien %s"

#: src/copy.c:2023 src/mkfifo.c:134
#, c-format
msgid "cannot create fifo %s"
msgstr "ne peut créer le fifo %s"

#: src/copy.c:2032
#, c-format
msgid "cannot create special file %s"
msgstr "ne peut créer le fichier spécial %s"

#: src/copy.c:2043 src/ls.c:3032 src/stat.c:609
#, c-format
msgid "cannot read symbolic link %s"
msgstr "ne peut lire le lien symbolique %s"

#: src/copy.c:2070
#, c-format
msgid "cannot create symbolic link %s"
msgstr "ne peut créer le lien symbolique %s"

#: src/copy.c:2102
#, c-format
msgid "%s has unknown file type"
msgstr "%s possède un type de fichier inconnu."

#: src/copy.c:2244 src/ln.c:320
#, c-format
msgid "cannot un-backup %s"
msgstr "ne peut désarchiver %s"

#: src/copy.c:2248
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "%s -> %s (désarchivage)\n"

#: src/cp.c:155 src/mv.c:284
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
msgstr ""
"Usage: %s [OPTION]... [-T] SOURCE CIBLE\n"
"   ou: %s [OPTION]... SOURCE... RÉPERTOIRE\n"
"   ou: %s [OPTION]... --target-directory=RÉPERTOIRE SOURCE...\n"

#: src/cp.c:161
msgid ""
"Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
"\n"
msgstr ""
"Copier la SOURCE vers la DESTINATION, ou de multiples SOURCES vers un "
"RÉPERTOIRE.\n"
"\n"

#: src/cp.c:165 src/csplit.c:1455 src/cut.c:197 src/df.c:809 src/du.c:274
#: src/expand.c:112 src/fmt.c:275 src/fold.c:75 src/head.c:118
#: src/install.c:959 src/kill.c:97 src/ln.c:353 src/ls.c:4558 src/mkdir.c:62
#: src/mkfifo.c:57 src/mknod.c:59 src/mv.c:294 src/nl.c:191 src/paste.c:443
#: src/pr.c:2777 src/ptx.c:1892 src/shred.c:164 src/shuf.c:57 src/sort.c:327
#: src/split.c:113 src/stdbuf.c:97 src/tac.c:142 src/tail.c:259
#: src/timeout.c:138 src/touch.c:226 src/truncate.c:113 src/unexpand.c:122
#: src/uniq.c:145
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"Les arguments obligatoires pour les options de formes longues le sont aussi\n"
"pour les options de formes courtes.\n"

#: src/cp.c:168
msgid ""
"  -a, --archive                same as -dR --preserve=all\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=links\n"
msgstr ""
"  -a, --archive                identique à -dR --preserve=all\n"
"      --backup[=CONTRÔLE]      archive chaque fichier de destination\n"
"  -b                           identique à --backup mais n'accepte pas "
"d'argument\n"
"      --copy-contents          copie le contenu des fichiers spéciaux en "
"mode récursif\n"
"  -d                           identique à --no-dereference --"
"preserve=links\n"

#: src/cp.c:175
msgid ""
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again (redundant "
"if\n"
"                                 the -n option is used)\n"
"  -i, --interactive            prompt before overwrite (overrides a previous "
"-n\n"
"                                  option)\n"
"  -H                           follow command-line symbolic links in SOURCE\n"
msgstr ""
"  -f, --force                  si un fichier de destination existe et \n"
"                               ne peut être ouvert alors le détruire et\n"
"                               réessayer (redondant si l'option -n est "
"employée)\n"
"  -i, --interactive            demande confirmation avant d'écraser(annule "
"une\n"
"                                  précédente option -n)\n"
"  -H                           suit les liens symboliques de ligne de "
"commande dans SOURCE\n"

#: src/cp.c:183
msgid ""
"  -l, --link                   link files instead of copying\n"
"  -L, --dereference            always follow symbolic links in SOURCE\n"
msgstr ""
"  -l, --link                   lier les fichiers au lieu de les copier\n"
"  -L, --dereference            toujours suivre les liens symboliques dans "
"SOURCE\n"

#: src/cp.c:187
msgid ""
"  -n, --no-clobber             do not overwrite an existing file (overrides\n"
"                                 a previous -i option)\n"
"  -P, --no-dereference         never follow symbolic links in SOURCE\n"
msgstr ""
"  -n, --no-clobber             n'écase pas un fichier existant (annule\n"
"                                 une option -i précédente)\n"
"  -P, --no-dereference        ne suit jamais un lien symbolique dans SOURCE\n"

#: src/cp.c:192
msgid ""
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: context, links, "
"xattr,\n"
"                                 all\n"
msgstr ""
"  -p                           identique à --preserve=mode,ownership,"
"timestamps\n"
"      --preserve[=ATTR_LIST]   préserve les attributs spécifiés (par "
"défaut :\n"
"                                 mode,ownership,timestamps), si posssible\n"
"                                 les attributs additionels : context, links, "
"xattr,\n"
"                                 all\n"

#: src/cp.c:199
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                use full source file name under DIRECTORY\n"
msgstr ""
"      --no-preserve=LISTE_ATTR ne pas préserver les attributs spécifiques\n"
"      --parents                accoler le chemin source au répertoire\n"

#: src/cp.c:203
#, fuzzy
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --reflink[=WHEN]         control clone/CoW copies. See below.\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -R, -r, --recursive          copier récursivement les répertoires\n"
"      --remove-destination     enlever chaque fichier de destination "
"existant\n"
"                               avant de l'ouvrir (par contraste avec --"
"force)\n"

#: src/cp.c:209
#, fuzzy
msgid ""
"      --sparse=WHEN            control creation of sparse files. See below.\n"
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
msgstr ""
"      --sparse=DATE            contrôle la DATE de création des fichiers\n"
"                               dispersés\n"
"      --strip-trailing-slashes enlève les « / » en suffixe de chacun\n"
"                               des arguments SOURCE\n"

#: src/cp.c:214
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
msgstr ""
"  -s, --symbolic-link        créer des liens symboliques au lieu de copier\n"
"  -S, --suffix=SUFFIXE       écraser le suffixe usuel d'archivage\n"
"                             par le SUFFIXE\n"
"      --target-directory=RÉPERTOIRE\n"
"                             déplacer tous les fichiers SOURCE en arguments\n"
"                             vers le RÉPERTOIRE\n"
"  -T, --no-target-directory  traiter la CIBLE comme un fichier normal\n"

#: src/cp.c:220
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update                 déplacer seulement les vieux ou\n"
"                               les tout nouveaux fichiers\n"
"  -v, --verbose                expliquer ce qui a été fait\n"
"  -x, --one-file-system        demeurer sur ce système de fichiers\n"

#: src/cp.c:229
#, fuzzy
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
"\n"
"When --reflink[=always] is specified, perform a lightweight copy, where the\n"
"data blocks are copied only when modified.  If this is not possible the "
"copy\n"
"fails, or if --reflink=auto is specified, fall back to a standard copy.\n"
msgstr ""
"\n"
"Par défaut, les fichiers SOURCES dispersés sont détectés par le biais\n"
"d'une heuristique grossière et le fichier CIBLE correspondant est aussi\n"
"construit de façon dispersée.  Il s'agit d'un comportement sélectionné\n"
"par l'option --sparse=auto.  Spécifiez --sparse=always pour créer un "
"fichier\n"
"CIBLE dispersé lorsque le fichier SOURCE contient une assez longue séquence\n"
"d'octets de valeur zéro.\n"
"Utilisez --sparse=never pour inhiber la création de fichiers dispersés.\n"

#: src/cp.c:241 src/install.c:995 src/ln.c:381 src/mv.c:320
msgid ""
"\n"
"The backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"\n"
"Le suffixe d'archive est « ~ », initialisé autrement avec --suffix ou\n"
"SIMPLE_BACKUP_SUFFIX.  La méthode du contrôle de version peut être "
"sélectionné\n"
"par l'option --backup ou par VERSION_CONTROL par le bias des variables\n"
"d'environnement selon les valeurs suivantes:\n"
"\n"

#: src/cp.c:248 src/install.c:1002 src/ln.c:393 src/mv.c:327
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  none, off       ne jamais archiver (même si --backup est utilisé)\n"
"  numbered, t     faire des archives numérotées\n"
"  existing, nil   numéroter si des archives  numérotées existent déjà,\n"
"                  ne pas numéroter autrement\n"
"  simple, never   toujours faire des archives de type simple\n"

#: src/cp.c:254
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"Un cas spécial où « cp » archive la SOURCE lorsque les options « force » et\n"
"« backup » sont utilisées et que la SOURCE et la DESTINATION portent le\n"
"même nom qu'un fichier régulier existant.\n"

#: src/cp.c:313
#, c-format
msgid "failed to preserve times for %s"
msgstr "échec de préservation des dates pour %s"

#: src/cp.c:344
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "échec de préservation des permissions de %s"

#: src/cp.c:471
#, c-format
msgid "cannot make directory %s"
msgstr "ne peut créer le répertoire %s"

#: src/cp.c:520 src/cp.c:539
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s existe mais n'est pas un répertoire"

#: src/cp.c:566 src/cp.c:1054 src/install.c:406 src/install.c:523 src/ln.c:117
#: src/ln.c:147 src/ln.c:168 src/ln.c:473 src/mv.c:151 src/mv.c:398
#, c-format
msgid "accessing %s"
msgstr "accès de %s"

#: src/cp.c:586 src/install.c:597 src/ln.c:503 src/mv.c:431 src/shred.c:1189
#: src/touch.c:432 src/truncate.c:359
#, c-format
msgid "missing file operand"
msgstr "opérande fichier manquant"

#: src/cp.c:588 src/install.c:599 src/ln.c:517 src/mv.c:433
#, c-format
msgid "missing destination file operand after %s"
msgstr "opérande du fichier cible manquant après %s"

#: src/cp.c:597 src/install.c:608 src/mv.c:442
#, c-format
msgid "cannot combine --target-directory (-t) and --no-target-directory (-T)"
msgstr ""
"Ne peut combiner --target-directory (-t) et --no-target-directory (-T) "

#: src/cp.c:611 src/cp.c:1056 src/install.c:408 src/install.c:525
#: src/install.c:621 src/ln.c:119 src/ln.c:475 src/ln.c:531 src/mv.c:400
#: src/mv.c:456
#, c-format
msgid "target %s is not a directory"
msgstr "la cible %s n'est pas un répertoire"

#: src/cp.c:722
#, c-format
msgid "with --parents, the destination must be a directory"
msgstr "avec --parents, la destination doit être un répertoire"

#: src/cp.c:1049 src/install.c:518 src/ln.c:468 src/mv.c:393
#, c-format
msgid "multiple target directories specified"
msgstr "options multiples répertoires cibles spécifiées"

#: src/cp.c:1094
#, c-format
msgid "cannot make both hard and symbolic links"
msgstr "Ne peut créer à la fois un lien symbolique et direct."

#: src/cp.c:1101 src/mv.c:463
#, c-format
msgid "options --backup and --no-clobber are mutually exclusive"
msgstr "les options --backup et --no-clobber s'excluent mutuellement"

#: src/cp.c:1107
#, c-format
msgid "--reflink can be used only with --sparse=auto"
msgstr ""

#: src/cp.c:1115 src/install.c:582 src/ln.c:539 src/mv.c:471
msgid "backup type"
msgstr "type d'archive"

#: src/cp.c:1140
#, c-format
msgid "cannot preserve security context without an SELinux-enabled kernel"
msgstr "ne peut préserver le contexte de sécurité en dehors d'un noyau SELinux"

#: src/cp.c:1146
#, c-format
msgid "cannot preserve extended attributes, cp is built without xattr support"
msgstr ""
"ne peut préserver les attributs étendus, cp est construite sans le support "
"xattr"

#. This is a proper name. See the gettext manual, section Names.
#: src/csplit.c:41 src/dd.c:48
msgid "Stuart Kemp"
msgstr "Stuart Kemp"

#: src/csplit.c:522
#, c-format
msgid "input disappeared"
msgstr "L'entrée est disparue."

#: src/csplit.c:650 src/csplit.c:661
#, c-format
msgid "%s: line number out of range"
msgstr "%s: numéro de ligne est hors limite"

#: src/csplit.c:690
#, c-format
msgid "%s: %s: line number out of range"
msgstr "%s: %s: numéro de ligne est hors limite"

#: src/csplit.c:693 src/csplit.c:742
#, c-format
msgid " on repetition %s\n"
msgstr " par répétition %s\n"

#: src/csplit.c:736
#, c-format
msgid "%s: %s: match not found"
msgstr "%s: %s: pas de concordance"

#: src/csplit.c:800 src/csplit.c:840 src/nl.c:359 src/tac.c:274
#, c-format
msgid "error in regular expression search"
msgstr "Erreur dans l'expression régulière recherchée."

#: src/csplit.c:965
#, c-format
msgid "write error for %s"
msgstr "erreur d'écriture sur %s"

#: src/csplit.c:1041
#, c-format
msgid "%s: integer expected after delimiter"
msgstr "%s: entier attendu après le délimiteur"

#: src/csplit.c:1057
#, c-format
msgid "%s: `}' is required in repeat count"
msgstr "%s: « } » est requis pour un compteur de répétition."

#: src/csplit.c:1067
#, c-format
msgid "%s}: integer required between `{' and `}'"
msgstr "%s}: entier requis entre « { » et « } »"

#: src/csplit.c:1094
#, c-format
msgid "%s: closing delimiter `%c' missing"
msgstr "%s: délimiteur de fermeture « %c » manquant"

#: src/csplit.c:1111
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: expression régulière invalide: %s"

#: src/csplit.c:1144
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: patron invalide."

#: src/csplit.c:1147
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: le numéro de ligne doit être plus grand que zéro."

#: src/csplit.c:1153
#, c-format
msgid "line number %s is smaller than preceding line number, %s"
msgstr ""
"le numéro de ligne %s est plus petit que le numéro précédent de ligne %s"

#: src/csplit.c:1159
#, c-format
msgid "warning: line number %s is the same as preceding line number"
msgstr ""
"AVERTISSEMENT: le numéro de ligne %s est le même que le précédent numéro de "
"ligne"

#: src/csplit.c:1212
#, c-format
msgid "invalid format width"
msgstr "largeur de format invalide"

#: src/csplit.c:1233
#, c-format
msgid "invalid format precision"
msgstr "précision de format invalide"

#: src/csplit.c:1254
#, c-format
msgid "missing conversion specifier in suffix"
msgstr "Symbole de conversion manquant dans le suffixe."

#: src/csplit.c:1260
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "Le symbole de conversion %c est invalide dans le suffixe."

#: src/csplit.c:1263
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "Le symbole de conversion \\%.3o est invalide dans le suffixe."

#: src/csplit.c:1286
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "Trop de spécifications  %% de conversion dans le suffixe."

#: src/csplit.c:1301
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "La spéfication de conversion %% est manquante dans le suffixe."

#: src/csplit.c:1345
#, c-format
msgid "%s: invalid number"
msgstr "%s: nombre invalide."

#: src/csplit.c:1446
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Usage: %s [OPTION]... FICHIER  MODÈLE...\n"

#: src/csplit.c:1450
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files `xx00', `xx01', ...,\n"
"and output byte counts of each piece to standard output.\n"
"\n"
msgstr ""
"Produire des morceaux du FICHIER séparés par MODÈLE(s) vers les fichiers\n"
"« xx01 », « xx02 », ... et le nombre d'octets de chaque morceau sur la sortie "
"standard.\n"
"\n"

#: src/csplit.c:1458
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=FORMAT utilise sprintf FORMAT au lieu de %02d\n"
"  -f, --prefix=PRÉFIXE       utilise le PRÉFIXE au lieu de `xx'\n"
"  -k, --keep-files           ne pas détruire les fichiers de sortie\n"
"                              lorsqu'il y a erreur\n"

#: src/csplit.c:1463
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=NOMBRE        utiliser NOMBRE de chiffres au lieu de 2\n"
"  -s, --quiet, --silent      ne pas afficher la taille des fichiers\n"
"                             de sortie\n"
"  -z, --elide-empty-files    détruire les fichiers de sortie vides\n"

#: src/csplit.c:1470
msgid ""
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
msgstr ""
"\n"
"Lire de l'entrée standard si le FICHIER est -.  Chaque MODÈLE peut être:\n"

#: src/csplit.c:1474
msgid ""
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
msgstr ""
"\n"
"  ENTIER             copier jusqu'à mais sans inclure le nombre spécifiée\n"
"                     de lignes\n"
"  /REGEXP/[SAUT]     copier jusqu'à la détection d'une ligne identique\n"
"                     mais sans l'inclure\n"
"  %%REGEXP%%[SAUT]     escamoter jusqu'à, mais sans inclure une\n"
"                     ligne identique\n"
"  {ENTIER}           répéter le patron précédent un nombre de fois\n"
"  {*}                répéter le patron précédent le plus souvent possible\n"
"\n"
"Une ligne de SAUT a besoin d'un « + » ou « - » suivi d'un entier positif.\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/cut.c:43 src/paste.c:51
msgid "David M. Ihnat"
msgstr "David M. Ihnat"

#: src/cut.c:63
msgid "fields and positions are numbered from 1"
msgstr "champs et positions sont numérotés à partir de 1"

#: src/cut.c:189
#, c-format
msgid "Usage: %s OPTION... [FILE]...\n"
msgstr "Usage : %s [OPTION]... [FICHIER]...\n"

#: src/cut.c:193
msgid ""
"Print selected parts of lines from each FILE to standard output.\n"
"\n"
msgstr ""
"Afficher des parties de lignes de chaque FICHIER vers la sortie standard.\n"
"\n"

#: src/cut.c:200
msgid ""
"  -b, --bytes=LIST        select only these bytes\n"
"  -c, --characters=LIST   select only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=LISTE       sélectionner seulement ces octets\n"
"  -c, --characters=LISTE  sélectionner seulement ces caractères\n"
"  -d, --delimiter=DÉLIM   utiliser le DÉLIMiteur au lieu d'une tabulation\n"
"                          comme délimiteur de champs\n"

#: src/cut.c:205
msgid ""
"  -f, --fields=LIST       select only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=LISTE      sélectionner seulement ces champs; afficher aussi\n"
"                            toutes les lignes qui ne contiennent pas de "
"caractère délimiteur,\n"
"                            à moins que l'option -s soit spécifiée\n"
"  -n                     (ignoré)\n"

#: src/cut.c:211
msgid ""
"      --complement        complement the set of selected bytes, characters\n"
"                            or fields\n"
msgstr ""
"      --complement        compléte le jeu des octets sélectionnés, "
"caractères\n"
"                            ou champs\n"

#: src/cut.c:215
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited    ne pas afficher les lignes ne\n"
"                          contenant pas de délimiteurs\n"
"      --output-delimiter=CHAÎNE\n"
"                          utiliser la CHAÎNE comme délimiteur de sortie\n"
"                          par défaut le délimiteur de l'entrée est utilisée\n"

#: src/cut.c:222
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Selected input is written\n"
"in the same order that it is read, and is written exactly once.\n"
msgstr ""
"\n"
"Employez un, et seulement un parmi -b, -c ou -f. Chaque LIST est fait d'un\n"
"intervalle, ou de plusieurs intervalles séparés par des virgules.  L'entrée\n"
"sélectionnée est écrite dans le même ordre qu'elle est lue, et seulement une "
"fois.\n"

#: src/cut.c:228
msgid ""
"Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Chaque intervalle est l'un de :\n"
"\n"
"  N     Nième octet, caractère ou champ, compté à partir de 1\n"
"  N-    du Nième octet, caractère ou champ jusqu'à la fin de la ligne\n"
"  N-M   du Nième au Mième octets (inclus), caractère ou champ\n"
"  -M    du premier au Mième octets (inclus), caractère ou champ\n"
"\n"
"Sans FICHIER, ou quand FICHIER est -, lire l'entrée standard.\n"

#: src/cut.c:368 src/cut.c:489
msgid "invalid byte or field list"
msgstr "Octet ou champ de liste invalide."

#: src/cut.c:385
msgid "invalid range with no endpoint: -"
msgstr "intervalle invalide sans borne de fin : -"

#: src/cut.c:399
msgid "invalid decreasing range"
msgstr "intervalle diminuant invalide"

#: src/cut.c:478
#, c-format
msgid "byte offset %s is too large"
msgstr "décalage d'octet %s est trop grand"

#: src/cut.c:481
#, c-format
msgid "field number %s is too large"
msgstr "numéro de champ %s est trop grand"

#: src/cut.c:785 src/cut.c:793
msgid "only one type of list may be specified"
msgstr "Un seul type de liste peut être spécifié."

#: src/cut.c:802
msgid "the delimiter must be a single character"
msgstr "Le délimiteur doit être un caractère simple."

#: src/cut.c:837
msgid "you must specify a list of bytes, characters, or fields"
msgstr "Une liste d'octets, de caractères, ou de champs doit être spécifiée."

#: src/cut.c:840
msgid "an input delimiter may be specified only when operating on fields"
msgstr ""
"un délimiteur peut être spécifié seulement lorsqu'opérant sur des champs"

#: src/cut.c:844
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"La suppression des lignes non-délimitées est permise\n"
"\tseulement lorsqu'opérant sur des champs."

#: src/cut.c:860
msgid "missing list of fields"
msgstr "Liste des champs manquante."

#: src/cut.c:862
msgid "missing list of positions"
msgstr "Liste des positions manquante."

#: src/date.c:124
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"   ou: %s [-u|--utc|--universal] [MMJJhhmm[[CC]AA][.ss]]\n"

#: src/date.c:129
msgid ""
"Display the current time in the given FORMAT, or set the system date.\n"
"\n"
"  -d, --date=STRING         display time described by STRING, not `now'\n"
"  -f, --file=DATEFILE       like --date once for each line of DATEFILE\n"
msgstr ""
"Afficher la date courante selon le FORMAT spécifié ou\n"
"initialiser la date du système.\n"
"\n"
"  -d, --date=CHAÎNE        afficher la date selon la description donnée par "
"la CHAÎNE,\n"
"                           excluant le mot réservé « now »\n"
"  -f, --file=FICHIER       identique à --date pour chaque ligne du\n"
"                           FICHIER de dates\n"

#: src/date.c:135
msgid ""
"  -r, --reference=FILE      display the last modification time of FILE\n"
"  -R, --rfc-2822            output date and time in RFC 2822 format.\n"
"                            Example: Mon, 07 Aug 2006 12:34:56 -0600\n"
msgstr ""
"  -r, --reference=FILE      affiche la dernière heure de modification de "
"FILE\n"
"  -R, --rfc-2822            affiche la date et l'heure dans le format RFC "
"2822.\n"
"                            Exemple: Mon, 07 Aug 2006 12:34:56 -0600\n"

#: src/date.c:140
msgid ""
"      --rfc-3339=TIMESPEC   output date and time in RFC 3339 format.\n"
"                            TIMESPEC=`date', `seconds', or `ns' for\n"
"                            date and time to the indicated precision.\n"
"                            Date and time components are separated by\n"
"                            a single space: 2006-08-07 12:34:56-06:00\n"
"  -s, --set=STRING          set time described by STRING\n"
"  -u, --utc, --universal    print or set Coordinated Universal Time\n"
msgstr ""
"      --rfc-3339=TIMESPEC  affiche la date et l'heure selon le format RFC-"
"3339.\n"
"                           TIMESPEC=`date', `seconds', ou `ns' pour\n"
"                           la date et l'heure selon la précision voulue.\n"
"                            Les éléments Date et Heure sont séparés par\n"
"                            un simple espace: 2006-08-07 12 : 34 : 56-"
"06 : 00\n"
"  -s, --set=CHAÎNE         initialise la date selon CHAÎNE\n"
"  -u, --utc, --universal   affiche ou initialise selon le système de\n"
"                           temps universel (T.U.)\n"

#: src/date.c:151
msgid ""
"\n"
"FORMAT controls the output.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (e.g., Sun)\n"
msgstr ""
"\n"
"FORMAT contrôle l'affichage.  Les séquences interprétées sont :\n"
"\n"
"  %%   un caractère %\n"
"  %a   les noms abrégés des jours de la semaine (i.e. dim..sam)\n"

#: src/date.c:158
msgid ""
"  %A   locale's full weekday name (e.g., Sunday)\n"
"  %b   locale's abbreviated month name (e.g., Jan)\n"
"  %B   locale's full month name (e.g., January)\n"
"  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n"
msgstr ""
"  %A   les noms complets localisés des jours de la semaine (dimanche.."
"samedi)\n"
"  %b   les noms abrégés  localisés des mois (jan..déc)\n"
"  %B   les noms complets localisés des mois (janvier..décembre)\n"
"  %c   la date et l'heure localisées (i.e. Jeu mar 3 23:05:25 2005)\n"

#: src/date.c:164
msgid ""
"  %C   century; like %Y, except omit last two digits (e.g., 20)\n"
"  %d   day of month (e.g, 01)\n"
"  %D   date; same as %m/%d/%y\n"
"  %e   day of month, space padded; same as %_d\n"
msgstr ""
"  %C   siècle; comme %Y, sans les 2 derniers chiffres (i.e. 20)\n"
"  %d   jour du mois (i.e. 01..31)\n"
"  %D   date, même que %m/%d/%y\n"
"  %e   jour du mois, blanc ajouté au besoin, identique à %_d\n"

#: src/date.c:170
msgid ""
"  %F   full date; same as %Y-%m-%d\n"
"  %g   last two digits of year of ISO week number (see %G)\n"
"  %G   year of ISO week number (see %V); normally useful only with %V\n"
msgstr ""
"  %F   la date complète, identique à %Y-%m-%d\n"
"  %g   les 2 derniers chiffres de l'année correspondant au numéro de semaine "
"ISO (voir %G)\n"
"  %G   l'année correspondant au numéro de semaine ISO (voir %V); normalement "
"utile seulement avec %V\n"

#: src/date.c:175
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h   identique à %b\n"
"  %H   heure (00..23)\n"
"  %I   heure (01..12)\n"
"  %j   jour numérique de l'année (001..366)\n"

#: src/date.c:181
msgid ""
"  %k   hour ( 0..23)\n"
"  %l   hour ( 1..12)\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""
"  %k   heure ( 0..23)\n"
"  %l   heure ( 1..12)\n"
"  %m   mois (01..12)\n"
"  %M   minute (00..59)\n"

#: src/date.c:187
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's equivalent of either AM or PM; blank if not known\n"
"  %P   like %p, but lower case\n"
"  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n"
"  %R   24-hour hour and minute; same as %H:%M\n"
"  %s   seconds since 1970-01-01 00:00:00 UTC\n"
msgstr ""
"  %n   un saut de ligne\n"
"  %N   nanosecondes (000000000..999999999)\n"
"  %p   indicateur localisé AM ou PM en majuscules (blanc si inconnu)\n"
"  %P   identique à %p mais en minuscules\n"
"  %r   heure locale en format 12-heure (i.e. 11:11:01 PM)\n"
"  %R   heure en format 24-heure identique à %H:%M\n"
"  %s   secondes depuis 1970-01-01 00:00:00 UTC\n"

#: src/date.c:196
msgid ""
"  %S   second (00..60)\n"
"  %t   a tab\n"
"  %T   time; same as %H:%M:%S\n"
"  %u   day of week (1..7); 1 is Monday\n"
msgstr ""
"  %S   les secondes (00..60)\n"
"  %t   une tabulation horizontale\n"
"  %T   l'heure, identique à %H:%M:%S\n"
"  %u   le jour de la semaine (1..7);  1 représente le lundi\n"

#: src/date.c:202
msgid ""
"  %U   week number of year, with Sunday as first day of week (00..53)\n"
"  %V   ISO week number, with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6); 0 is Sunday\n"
"  %W   week number of year, with Monday as first day of week (00..53)\n"
msgstr ""
"  %U   le numéro de la semaine dans l'année débutant par le dimanche\n"
"        comme premier jour de la semaine (00..53)\n"
"  %V   le numéro de la semaine ISO dans l'année débutant par le lundi\n"
"        comme premier jour de la semaine (01..53)\n"
"  %w   le jour de la semaine (0..6);  0 représente le dimanche\n"
"  %W   le numéro de la semaine dans l'année débutant par le lundi\n"
"        comme premier jour de la semaine (00..53)\n"

#: src/date.c:208
msgid ""
"  %x   locale's date representation (e.g., 12/31/99)\n"
"  %X   locale's time representation (e.g., 23:13:48)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year\n"
msgstr ""
"  %x   représentation localisée de la date (i.e. 12/31/99)\n"
"  %X   représentation localisée de l'heure (i.e. 23:13:48)\n"
"  %y   les deux derniers chiffres de l'année (00..99)\n"
"  %Y   l'année\n"

#: src/date.c:214
msgid ""
"  %z   +hhmm numeric timezone (e.g., -0400)\n"
"  %:z  +hh:mm numeric timezone (e.g., -04:00)\n"
"  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n"
"  %:::z  numeric time zone with : to necessary precision (e.g., -04, "
"+05:30)\n"
"  %Z   alphabetic time zone abbreviation (e.g., EDT)\n"
"\n"
"By default, date pads numeric fields with zeroes.\n"
msgstr ""
"  %z   fuseau horaire numérique +hhmm  (i.e. -0400)\n"
"  % : z  fuseau horaire numérique +hh:mm (i.e. -04:00)\n"
"  % : : z  fuseau horaire numérique +hh:mm:ss (i.e. -04:00:00)\n"
"  % : : : z  fuseau horaire numérique selon la précision nécessaire (i.e. -"
"04, +05:30)\n"
"  %Z   abréviation alphabétique des fuseaux horaires (i.e. EDT)\n"
"\n"
"Par défaut les champs de date numériques sont remplis par des zéros.\n"

#: src/date.c:223
msgid ""
"The following optional flags may follow `%':\n"
"\n"
"  -  (hyphen) do not pad the field\n"
"  _  (underscore) pad with spaces\n"
"  0  (zero) pad with zeros\n"
"  ^  use upper case if possible\n"
"  #  use opposite case if possible\n"
msgstr ""
"Les fanions optionnels suivants peuvent suivre `%' :\n"
"\n"
"  -  (hyphen) ne remplit pas le champs\n"
"  _  (underscore) remplit avec espace\n"
"  0  (zero) remplit avec zéro\n"
"  ^  emploie majuscule si possible\n"
"  #  emploie la casse opposée si possible\n"

#: src/date.c:232
msgid ""
"\n"
"After any flags comes an optional field width, as a decimal number;\n"
"then an optional modifier, which is either\n"
"E to use the locale's alternate representations if available, or\n"
"O to use the locale's alternate numeric symbols if available.\n"
msgstr ""
"\n"
"Un largeur champ optionel suit un fanion à l'aide d'un nombre décimal;\n"
"suivi du modificateur optionel lequel peut prendre la valeur\n"
"E pour utiliser une représentation de locale si disponible, ou\n"
"O pour utiliser une représentation de symboles numériques de locale si "
"disponible.\n"

#: src/date.c:260 src/dd.c:1867 src/head.c:841 src/md5sum.c:445
#: src/md5sum.c:749 src/od.c:863 src/od.c:1914 src/pr.c:1176 src/pr.c:1372
#: src/pr.c:1494 src/stty.c:847 src/tac.c:535 src/tail.c:335 src/tee.c:126
#: src/tr.c:1892 src/tsort.c:523 src/wc.c:193
#, c-format
msgid "standard input"
msgstr "entrée standard"

#: src/date.c:288 src/date.c:508
#, c-format
msgid "invalid date %s"
msgstr "date invalide %s"

#: src/date.c:399 src/date.c:433
#, c-format
msgid "multiple output formats specified"
msgstr "multiples formats de fichiers de sortie spécifiés"

#: src/date.c:411
#, c-format
msgid "the options to specify dates for printing are mutually exclusive"
msgstr ""
"les options pour spécifier les dates pour l'impression sont mutuellement "
"exclusives"

#: src/date.c:418
#, c-format
msgid "the options to print and set the time may not be used together"
msgstr ""
"Les options pour afficher et initialiser la date ne peuvent être\n"
"utilisées ensembles."

#: src/date.c:439
#, c-format
msgid ""
"the argument %s lacks a leading `+';\n"
"when using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with `+'"
msgstr ""
"l'argument %s n'est pas précédé du préfixe «+»;\n"
"lors de l'utilisation d'une option pour spécifier la date,\n"
"chaque argument qui n'est pas une option reconnue doit être\n"
"une chaîne de formatage qui débute par « + »."

#: src/date.c:516
#, c-format
msgid "cannot set date"
msgstr "ne peut initialiser la date."

#: src/date.c:539 src/du.c:411
#, c-format
msgid "time %s is out of range"
msgstr "date %s est hors limites"

#. This is a proper name. See the gettext manual, section Names.
#: src/dd.c:46 src/factor.c:43 src/rm.c:41 src/tail.c:61 src/touch.c:42
#: src/wc.c:49
msgid "Paul Rubin"
msgstr "Paul Rubin"

#: src/dd.c:468
#, c-format
msgid ""
"Usage: %s [OPERAND]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s [OPÉRANDE]...\n"
"   ou: %s OPTION\n"

#: src/dd.c:473
msgid ""
"Copy a file, converting and formatting according to the operands.\n"
"\n"
"  bs=BYTES        read and write BYTES bytes at a time (also see ibs=,obs=)\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=CONVS      convert the file as per the comma separated symbol list\n"
"  count=BLOCKS    copy only BLOCKS input blocks\n"
"  ibs=BYTES       read BYTES bytes at a time (default: 512)\n"
msgstr ""
"Copie un fichier en le convertissant et le formatant selon les opérandes.\n"
"\n"
"  bs=BYTES        lit et écrit BYTES octets à la fois (voir aussi ibs=,"
"obs=)\n"
"  cbs=BYTES       convertit BYTES octet à la fois\n"
"  conv=CONVS      convertit le fichier selon la liste de symbole séparés par "
"une virgule\n"
"  count=BLOCKS    copie seulement BLOCKS blocs d'entrée\n"
"  ibs=BYTES       lit BYTES octets à la fois (défaut : 512)\n"

#: src/dd.c:482
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  iflag=FLAGS     read as per the comma separated symbol list\n"
"  obs=BYTES       write BYTES bytes at a time (default: 512)\n"
"  of=FILE         write to FILE instead of stdout\n"
"  oflag=FLAGS     write as per the comma separated symbol list\n"
"  seek=BLOCKS     skip BLOCKS obs-sized blocks at start of output\n"
"  skip=BLOCKS     skip BLOCKS ibs-sized blocks at start of input\n"
"  status=noxfer   suppress transfer statistics\n"
msgstr ""
"  if=FICHIER      lit à partir du FICHIER au lieu de l'entrée standard\n"
"  iflag=FANIONS   lit selon la liste de symboles séparés par une virgule\n"
"  obs=BYTES        écrit BYTES octets à la fois (défault : 512)\n"
"  of=FICHIER      écrit dans FICHIER au lieu de la sortie standard\n"
"  oflag=FANIONS   écrit selon la liste de symboles séparés par des virgules\n"
"  seek=N          escamote N blocs de taille « obs » au début du fichier de "
"sortie\n"
"  skip=N          escamote N blocs de taille « ibs » au début du fichier "
"d'entrée\n"
"  status=noxfer   supprime les statistiques de transfert\n"

#: src/dd.c:492
msgid ""
"\n"
"BLOCKS and BYTES may be followed by the following multiplicative suffixes:\n"
"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M\n"
"GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
"Each CONV symbol may be:\n"
"\n"
msgstr ""
"\n"
"BLOCS et BYTES peuvent être suivis des suffixes multiplicatifs suivants:,\n"
"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M\n"
"GB 1000*1000*1000, G 1024*1024*1024 et ainsi de suite pour T, P, E, Z, Y.\n"
"\n"
"Chaque mot CLÉ peut être:\n"
"\n"

#: src/dd.c:501
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternate EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
msgstr ""
"  ascii     de l'EBCDIC vers l'ASCII\n"
"  ebcdic    de l'ASCII  vers l'EBCDIC\n"
"  ibm       de l'ASCII  vers l'EBCDIC en utilisant une table différente\n"
"  block     remplir les enregistrements terminés par un saut de ligne\n"
"            par des blancs jusqu'à l'obtention de la taille « cbs »\n"
"  unblock   remplacer les blancs de la fin des enregistrements\n"
"            de taille « cbs » par des sauts de ligne\n"
"  lcase     changer les majuscules en minuscules\n"

#: src/dd.c:509
msgid ""
"  nocreat   do not create the output file\n"
"  excl      fail if the output file already exists\n"
"  notrunc   do not truncate the output file\n"
"  ucase     change lower case to upper case\n"
"  swab      swap every pair of input bytes\n"
msgstr ""
"  nocreat   ne pas créer de ficheir de sortie\n"
"  excl      échoue si le fichier de sortie existe déjà\n"
"  notrunc   ne tronque pas le fichier de sortie\n"
"  ucase     change les minuscules en majuscules\n"
"  swab      interchange chaque paire d'octets entrée\n"

#: src/dd.c:516
msgid ""
"  noerror   continue after read errors\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"            with block or unblock, pad with spaces rather than NULs\n"
"  fdatasync  physically write output file data before finishing\n"
"  fsync     likewise, but also write metadata\n"
msgstr ""
"  noerror   continue même après des erreurs de lecture\n"
"  sync      remplit chaque bloc lu par des nuls jusqu'à concurrence\n"
"            de la taille « ibs » ; avec block ou unblock, remplit avec des "
"espaces au lieu de nuls\n"
"  fdatasync  écrit physiquement les données en sortie avant la fin\n"
"  fsync     pareil, mais écrit les métadonnées\n"

#: src/dd.c:523
msgid ""
"\n"
"Each FLAG symbol may be:\n"
"\n"
"  append    append mode (makes sense only for output; conv=notrunc "
"suggested)\n"
msgstr ""
"\n"
"Chaque symbole FLAG peut être :\n"
"\n"
"  append    mode d'accolage (n'a de sens que pour la sortie ; conv=notrunc "
"suggéré)\n"

#: src/dd.c:530
msgid "  cio       use concurrent I/O for data\n"
msgstr "  cio      utilise les E/S concurrentes pour les données\n"

#: src/dd.c:532
msgid "  direct    use direct I/O for data\n"
msgstr "  direct    utiliser les E/S directes pour les données\n"

#: src/dd.c:534
msgid "  directory  fail unless a directory\n"
msgstr "  échec de répertoire à moins qu'un répertoire\n"

#: src/dd.c:536
msgid "  dsync     use synchronized I/O for data\n"
msgstr "  dsync     utilise une E/S synchronisée pour les données\n"

#: src/dd.c:538
msgid "  sync      likewise, but also for metadata\n"
msgstr "  sync      identique mais aussi pour les métadonnées\n"

#: src/dd.c:539
msgid "  fullblock  accumulate full blocks of input (iflag only)\n"
msgstr "  fullblock  accumule des blocs pleins en entrée (seulement iflag)\n"

#: src/dd.c:542
msgid "  nonblock  use non-blocking I/O\n"
msgstr "  nonblock  utiliser une E/S non bloquante\n"

#: src/dd.c:544
msgid "  noatime   do not update access time\n"
msgstr "  noatime   ne met pas à jour la date d'accès\n"

#: src/dd.c:546
msgid "  noctty    do not assign controlling terminal from file\n"
msgstr ""
"  noctty    ne pas assigner de terminal contrôleur à partir du fichier\n"

#: src/dd.c:549
msgid "  nofollow  do not follow symlinks\n"
msgstr "  nofollow  ne pas suivre les liens symboliques\n"

#: src/dd.c:551
msgid "  nolinks   fail if multiply-linked\n"
msgstr "  nolinks   échoue si multiply-linked\n"

#: src/dd.c:553
msgid "  binary    use binary I/O for data\n"
msgstr "  binaire   utiliser les E/S binaires pour les données\n"

#: src/dd.c:555
msgid "  text      use text I/O for data\n"
msgstr "  text      utiliser les E/S textuelles pour les données\n"

#: src/dd.c:559
#, c-format
msgid ""
"\n"
"Sending a %s signal to a running `dd' process makes it\n"
"print I/O statistics to standard error and then resume copying.\n"
"\n"
"  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
"  $ kill -%s $pid; sleep 1; kill $pid\n"
"  18335302+0 records in\n"
"  18335302+0 records out\n"
"  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s\n"
"\n"
"Options are:\n"
"\n"
msgstr ""
"\n"
"Expédier le signal %s vers le processus `dd' actif provoque\n"
"l'écriture des statistiques sur la sortie d'erreur standard\n"
"suivi de la poursuite de la copie.\n"
"\n"
"  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
"  $ kill -%s $pid; sleep 1; kill $pid\n"
"  18335302+0 enregistrements lus\n"
"  18335302+0 enregistrements écrits\n"
"  9387674624 octets (9.4 Go) copiés, 34.6279 secondes, 271 Mo/s\n"

#: src/dd.c:615
#, c-format
msgid ""
"%<PRIuMAX>+%<PRIuMAX> records in\n"
"%<PRIuMAX>+%<PRIuMAX> records out\n"
msgstr ""
"%<PRIuMAX>+%<PRIuMAX> enregistrements lus\n"
"%<PRIuMAX>+%<PRIuMAX> enregistrements écrits\n"

#: src/dd.c:621
#, c-format
msgid "%<PRIuMAX> truncated record\n"
msgid_plural "%<PRIuMAX> truncated records\n"
msgstr[0] "%<PRIuMAX> enregistrement tronqué\n"
msgstr[1] "%<PRIuMAX> enregistrements tronqués\n"

#: src/dd.c:633
#, c-format
msgid "%<PRIuMAX> byte (%s) copied"
msgid_plural "%<PRIuMAX> bytes (%s) copied"
msgstr[0] "%<PRIuMAX> octet (%s) copié"
msgstr[1] "%<PRIuMAX> octets (%s) copiés"

#: src/dd.c:651
msgid "Infinity B"
msgstr "Infinité B"

#. TRANSLATORS: The two instances of "s" in this string are the SI
#. symbol "s" (meaning second), and should not be translated.
#.
#. This format used to be:
#.
#. ngettext (", %g second, %s/s\n", ", %g seconds, %s/s\n", delta_s == 1)
#.
#. but that was incorrect for languages like Polish.  To fix this
#. bug we now use SI symbols even though they're a bit more
#. confusing in English.
#: src/dd.c:664
#, c-format
msgid ", %g s, %s/s\n"
msgstr ", %g s, %s/s\n"

#: src/dd.c:672
#, c-format
msgid "closing input file %s"
msgstr "fermeture du fichier d'entrée %s"

#: src/dd.c:679
#, c-format
msgid "closing output file %s"
msgstr "fermeture du fichier de sortie %s"

#: src/dd.c:850
#, fuzzy, c-format
msgid "failed to turn off O_DIRECT: %s"
msgstr "ne peut exécuter la commande %s"

#: src/dd.c:904 src/dd.c:1653
#, c-format
msgid "writing to %s"
msgstr "écriture vers %s"

#: src/dd.c:1015 src/dd.c:1069
#, c-format
msgid "unrecognized operand %s"
msgstr "opérande non reconnue %s"

#: src/dd.c:1026
msgid "invalid conversion"
msgstr "conversion invalide"

#: src/dd.c:1029
msgid "invalid input flag"
msgstr "fanion d'entrée invalide"

#: src/dd.c:1032 src/dd.c:1099
msgid "invalid output flag"
msgstr "fanion de sortie invalide"

#: src/dd.c:1035
msgid "invalid status flag"
msgstr "fanion d'état invalide"

#: src/dd.c:1074 src/truncate.c:322
#, c-format
msgid "invalid number %s"
msgstr "nombre invalide %s"

#: src/dd.c:1108
#, c-format
msgid "cannot combine any two of {ascii,ebcdic,ibm}"
msgstr "ne peut combiner n'importe quel des deux de: ascii, ebcdic, ibm"

#: src/dd.c:1110
#, c-format
msgid "cannot combine block and unblock"
msgstr "ne peut combiner les options block t unblock"

#: src/dd.c:1112
#, c-format
msgid "cannot combine lcase and ucase"
msgstr "ne peut combiner les options lcase et ucase"

#: src/dd.c:1114
#, c-format
msgid "cannot combine excl and nocreat"
msgstr "ne peut combiner les options excl et nocreat"

#: src/dd.c:1260
#, c-format
msgid ""
"warning: working around lseek kernel bug for file (%s)\n"
"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types"
msgstr ""
"AVERTISSEMENT: arrangement pour contourner bug de lseek dans le kernel \n"
"pour le fichier (%s)\n"
"de type mt_type=0x%0lx -- voir <sys/mtio.h> pour la liste des types"

#: src/dd.c:1342
#, c-format
msgid "%s: cannot skip"
msgstr "%s : ne peut sauter"

#: src/dd.c:1344 src/dd.c:1366 src/dd.c:1423
#, c-format
msgid "%s: cannot seek"
msgstr "%s: ne peut retrouver"

#: src/dd.c:1403
#, c-format
msgid "offset overflow while reading file %s"
msgstr "débordement du décalage lors de la lecture du fichier %s"

#: src/dd.c:1415
#, c-format
msgid "warning: invalid file offset after failed read"
msgstr ""
"avertissement : décalage(offset) de fichier invalide suite à un échec de "
"lecture"

#: src/dd.c:1419
#, c-format
msgid "cannot work around kernel bug after all"
msgstr "ne peut après tout contrer une anomalie du kernel"

#: src/dd.c:1562
#, c-format
msgid "setting flags for %s"
msgstr "initialisation des fanions pour %s"

#: src/dd.c:1636
#, c-format
msgid "%s: cannot skip to specified offset"
msgstr "%s : ne peut se déplacer du décalage spécifié"

#: src/dd.c:1812
#, c-format
msgid "fdatasync failed for %s"
msgstr "fdatasync a échoué pour %s"

#: src/dd.c:1822
#, c-format
msgid "fsync failed for %s"
msgstr "fsync a échoue pour %s"

#: src/dd.c:1873 src/dd.c:1902
#, c-format
msgid "opening %s"
msgstr "ouverture de %s"

#: src/dd.c:1911
#, c-format
msgid ""
"offset too large: cannot truncate to a length of seek=%<PRIuMAX> (%lu-byte) "
"blocks"
msgstr ""
"décalage trop grand: ne peut tronquer à la longueur de la recherche=%"
"<PRIuMAX> (%lu-byte) blocs"

#: src/dd.c:1932
#, fuzzy, c-format
msgid "failed to truncate to %<PRIuMAX> bytes in output file %s"
msgstr "troncation à %<PRIuMAX> octets dans le fichier de sortie %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/df.c:41 src/du.c:54 src/expr.c:153 src/kill.c:43 src/pathchk.c:39
#: src/shuf.c:37 src/sleep.c:36 src/sort.c:63
msgid "Paul Eggert"
msgstr "Paul Eggert"

#: src/df.c:151
msgid "Filesystem    Type"
msgstr "Sys. de fich. Type "

#: src/df.c:153
msgid "Filesystem        "
msgstr "Sys. de fich.     "

#: src/df.c:156
#, c-format
msgid "    Inodes   IUsed   IFree IUse%%"
msgstr "    Inodes   IUtil.  ILib. %%IUti."

#: src/df.c:160
#, c-format
msgid "    Size  Used Avail Use%%"
msgstr "    Tail. Occ. Disp. %%Occ."

#: src/df.c:162
#, c-format
msgid "     Size   Used  Avail Use%%"
msgstr "     Tail.  Occ.  Disp. %%Occ."

#: src/df.c:165
#, c-format
msgid " %s-blocks      Used Available Capacity"
msgstr " %s-blocs        Capacité Disponible Occupée"

#: src/df.c:196
#, c-format
msgid " %4s-blocks      Used Available Use%%"
msgstr " %4s-blocs       Occupé Disponible Capacité"

#: src/df.c:200
#, c-format
msgid " Mounted on\n"
msgstr " Monté sur\n"

#: src/df.c:530
#, c-format
msgid "cannot get current directory"
msgstr "ne peut obtenir le répertoire courant"

#: src/df.c:540 src/df.c:554 src/df.c:582
#, c-format
msgid "cannot change to directory %s"
msgstr "ne peut aller vers le répertoire %s"

#: src/df.c:560
#, c-format
msgid "cannot stat current directory (now %s)"
msgstr "ne peut obtenir par stat() le répertoire courant (maintenant %s)"

#: src/df.c:804
msgid ""
"Show information about the file system on which each FILE resides,\n"
"or all file systems by default.\n"
"\n"
msgstr ""
"Afficher les informations à propos du système de fichiers sur lequel\n"
"réside chaque FICHIER ou de tous les systèmes de fichiers par défaut.\n"
"\n"

#: src/df.c:812
msgid ""
"  -a, --all             include dummy file systems\n"
"  -B, --block-size=SIZE  use SIZE-byte blocks\n"
"      --total           produce a grand total\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"  -H, --si              likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -a, --all               inclut les systèmes de fichiers fantôme\n"
"  -B, --block-size=TAILLE utilise des blocs d'octets de TAILLE octets\n"
"      --total           produit un total général\n"
"  -h, --human-readable    affiche les tailles dans un format lisible par\n"
"                          un humain (i.e. 1K 234M 2G)\n"
"  -H, --si              identique mais utilise un multiple de 1000\n"
"                            et non de 1024\n"

#: src/df.c:819
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local file systems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes            lister les informations des « inodes »\n"
"                            plutôt que sur l'utilisation des blocs\n"
"  -k                      identique à --block-size=1K\n"
"  -l, --local             limiter le listing au système local de fichiers\n"
"      --no-sync           ne pas effectuer une synchronisation avant\n"
"                            d'obtenir les informations d'utilisation\n"
"                            des disques (par défaut)\n"

#: src/df.c:825
msgid ""
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
"  -t, --type=TYPE       limit listing to file systems of type TYPE\n"
"  -T, --print-type      print file system type\n"
"  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""
"  -P, --portability       utiliser le format de sortie POSIX\n"
"      --sync              demander une synchronisation avant d'obtenir les\n"
"                            informations d'utilisation des disques\n"
"                            (par défaut)\n"
"  -t, --type=TYPE         limiter l'affichage au TYPE de système de\n"
"                          fichiers\n"
"  -T, --print-type        afficher le type du système de fichiers\n"
"  -x, --exclude-type=TYPE limiter l'affichage en excluant le TYPE\n"
"                            de système de fichiers\n"
"  -v                      (ignorée)\n"

#: src/df.c:973
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "Le système de fichiers %s est à la fois sélectionné et exclu."

#: src/df.c:1021
msgid "Warning: "
msgstr "AVERTISSEMENT: "

#: src/df.c:1023
msgid "cannot read table of mounted file systems"
msgstr "ne peut lire la table des systèmes de fichiers montés"

#: src/df.c:1051
#, c-format
msgid "no file systems processed"
msgstr "aucun système de fichier traité"

#. This is a proper name. See the gettext manual, section Names.
#: src/dircolors.c:35
msgid "H. Peter Anvin"
msgstr "H. Peter Anvin"

#: src/dircolors.c:98 src/uptime.c:201 src/users.c:106
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "Usage: %s [OPTION]... [FICHIER]\n"

#: src/dircolors.c:99
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
msgstr ""
"Commande d'affichage pour initialiser la variable d'environnement LS_COLOR.\n"
"\n"
"Déterminer le format de sortie:\n"
"  -b, --sh, --bourne-shell    code de sortie pour un Bourne shell\n"
"                              initialiser la variable LS_COLORS\n"
"  -c, --csh, --c-shell        code de sortie pour un C shell pour\n"
"                              initialiser la variable LS_COLORS\n"
"  -p, --print-data-base       utiliser les valeurs par défaut de sortie\n"

#: src/dircolors.c:109
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run `dircolors --print-database'.\n"
msgstr ""
"\n"
"Si le FICHIER est fourni, le lire pour déterminer les couleurs à utiliser\n"
"pour les types de fichiers et les extensions. Autrement, utiliser la base de "
"données\n"
"précompilés. Pour le détail du format de ces fichiers, exécuter «dircolors --"
"print-database'.\n"

#: src/dircolors.c:287
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s:%lu: ligne invalide;  second jeton manquant"

#: src/dircolors.c:359
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s:%lu: mot clé non reconnu %s"

#: src/dircolors.c:360
msgid "<internal>"
msgstr "<interne>"

#: src/dircolors.c:441
#, c-format
msgid ""
"the options to output dircolors' internal database and\n"
"to select a shell syntax are mutually exclusive"
msgstr ""
"les options pour la base de données interne de sortie de dircolors et\n"
"la sélection de la syntaxe du shell sont mutuellement exclusives"

#: src/dircolors.c:451
msgid "file operands cannot be combined with --print-database (-p)"
msgstr ""
"Les opérandes de fichier ne peutvent être combinées avec --print-database (-"
"p)."

#: src/dircolors.c:474
#, c-format
msgid "no SHELL environment variable, and no shell type option given"
msgstr "Aucune variable de shell et aucune option de mode spécifiée."

#: src/dirname.c:45
#, c-format
msgid ""
"Usage: %s NAME\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s NOM\n"
"   ou: %s OPTION\n"

#: src/dirname.c:50
msgid ""
"Print NAME with its trailing /component removed; if NAME contains no /'s,\n"
"output `.' (meaning the current directory).\n"
"\n"
msgstr ""
"Afficher le NOM du répertoire en enlevant ses composantes de fin;\n"
"si le NOM ne contient pas de « / »\n"
"le symbole « . » indique le répertoire courant.\n"
"\n"

#: src/dirname.c:57
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort  Output \"/usr/bin\".\n"
"  %s stdio.h        Output \".\".\n"
msgstr ""
"\n"
"Exemples:\n"
"  %s /usr/bin/sort  sortie \"/usr/bin\".\n"
"  %s stdio.h        sortie \".\".\n"

#: src/du.c:266 src/sort.c:318 src/wc.c:112
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [OPTION]... --files0-from=F\n"
msgstr ""
"Usage: %s [OPTION]... [FICHIER]...\n"
"   ou: %s [OPTION]... --reference=FICHIER-R FICHIER...\n"

#: src/du.c:270
msgid ""
"Summarize disk usage of each FILE, recursively for directories.\n"
"\n"
msgstr ""
"Produire un sommaire de l'utilisation de l'espace disque de chaque FICHIER,\n"
"et récursivement dans tous les répertoires.\n"

#: src/du.c:277
msgid ""
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes, rather than disk usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in (`sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
msgstr ""
"  -a, --all                affiche le décompte pour tous les fichiers,\n"
"                           pas seulement pour les répertoires\n"
"      --apparent-size      affiche les tailles apparentes, au lieu de "
"l'occupation disque; \n"
"                           même si la taille apparente est habituellement "
"plus petite, elle peut être\n"
"                           plus grande en raison de trous dans (`sparse') "
"les fichiers, \n"
"                           de la fragmentation, de blocs indirects et autre "
"raisons similaires\n"

#: src/du.c:284
msgid ""
"  -B, --block-size=SIZE  use SIZE-byte blocks\n"
"  -b, --bytes           equivalent to `--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference only symlinks that are listed on the\n"
"                          command line\n"
msgstr ""
"  -B, --block-size=TAILLE  utilise des blocs de TAILLE octets\n"
"  -b, --bytes              équivalent à `--apparent-size --block-size=1'\n"
"  -c, --total              produit le total général\n"
"  -D, --dereference-args   ne pas tenir compte seulement des symlinks qui\n"
"                           apparaissent sur la ligne de commande\n"

#: src/du.c:291
msgid ""
"      --files0-from=F   summarize disk usage of the NUL-terminated file\n"
"                          names specified in file F;\n"
"                          If F is - then read names from standard input\n"
"  -H                    equivalent to --dereference-args (-D)\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"      --si              like -h, but use powers of 1000 not 1024\n"
msgstr ""
"      --files0-from=F   résume l'occupation disque des fichiers terminés par "
"NUL\n"
"                             noms spécifiés dans le fichier F;\n"
"                          si F est - alors lit les noms depuis l'entrée "
"standard\n"
"  -H,                      identique à --dereference-args (-D)\n"
"  -h, --human-readable     affiche les tailles dans un format lisible par\n"
"                             un humain (i.e. 1K 234M 2G)\n"
"      --si                 identique à -h mais utilise un multiple de 1000\n"
"                             et pas de 1024\n"

#: src/du.c:299
msgid ""
"  -k                    like --block-size=1K\n"
"  -l, --count-links     count sizes many times if hard linked\n"
"  -m                    like --block-size=1M\n"
msgstr ""
"  -k,                      identique à --block-size=1K\n"
"  -l, --count-links        dénombre les tailles aussi souvent qu'il y a\n"
"                             de liens directs\n"
"  -m                       identique à --block-size=1M\n"

#: src/du.c:304
msgid ""
"  -L, --dereference     dereference all symbolic links\n"
"  -P, --no-dereference  don't follow any symbolic links (this is the "
"default)\n"
"  -0, --null            end each output line with 0 byte rather than "
"newline\n"
"  -S, --separate-dirs   do not include size of subdirectories\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""
"  -L, --dereference        ne pas tenir compte de tous les liens\n"
"                           symboliques\n"
"  -P, --no-dereference     ne pas suivre les liens symboliques (par défaut)\n"
"  -0, --null               terminer chaque ligne de sortie par un octet de "
"valeur zéro plutôt que changement de ligne\n"
"  -S, --separate-dirs      ne pas inclure la taille des sous-répertoires\n"
"  -s, --summarize          afficher seulement un total pour chaque type\n"
"                           d'argument\n"

#: src/du.c:311
msgid ""
"  -x, --one-file-system    skip directories on different file systems\n"
"  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
"      --exclude=PATTERN    exclude files that match PATTERN\n"
"      --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""
"  -x, --one-file-system    escamote les répertoires de différents\n"
"                             systèmes de fichiers\n"
"  -X, --exclude-from=FICHIER  exclut les fichiers qui concordent avec\n"
"                             un des patrons dans FICHIER\n"
"      --exclude=PATRON  exclut les fichiers qui concordent avec\n"
"                             le PATRON\n"
"      --max-depth=N    affiche le total pour un répertoire\n"
"                             (ou un fichier, avec --all) seulement\n"
"                             si il est à N niveaux ou moins dessous les "
"arguments\n"
"                             de ligne de commande ;\n"
"                             --max-depth=0 est identique à --summarize\n"

#: src/du.c:320
msgid ""
"      --time            show time of the last modification of any file in "
"the\n"
"                          directory, or any of its subdirectories\n"
"      --time=WORD       show time as WORD instead of modification time:\n"
"                          atime, access, use, ctime or status\n"
"      --time-style=STYLE  show times using style STYLE:\n"
"                          full-iso, long-iso, iso, +FORMAT\n"
"                          FORMAT is interpreted like `date'\n"
msgstr ""
"      --time            affiche le temps de la dernière modification de "
"n'importe\n"
"                          quel fichier du répertoire ou des sous-"
"répertoires\n"
"      --time=MOT        affiche le temps comme un MOT au lieu du temps de "
"modification :\n"
"                          atime, access, use, ctime ou status\n"
"      --time-style=STYLE affiche le temp en utilisant STYLE:\n"
"                          full-iso, long-iso, iso, +FORMAT\n"
"                          FORMAT est interprété comme `date'\n"

#: src/du.c:758
#, c-format
msgid "invalid maximum depth %s"
msgstr "profondeur maximum invalide %s"

#: src/du.c:851
#, c-format
msgid "cannot both summarize and show all entries"
msgstr "Ne peut afficher à la fois un résumé et toutes les entrées."

#: src/du.c:858
#, c-format
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr ""
"AVERTISSEMENT: le résumé est identique si l'option --max-dept=0 est utilisée"

#: src/du.c:864
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%lu"
msgstr ""
"AVERTISSEMENT: conflit avec l'option d'établissement de sommaire avec --max-"
"depth=%lu"

#: src/du.c:930 src/sort.c:3538 src/wc.c:656
msgid "file operands cannot be combined with --files0-from"
msgstr "Les opérandes fichier ne peuvent être combinés avec --files0-from"

#: src/du.c:967 src/md5sum.c:551 src/od.c:903 src/tac.c:239 src/tac.c:350
#: src/tac.c:481 src/tac.c:557 src/wc.c:718
#, c-format
msgid "%s: read error"
msgstr "%s: erreur de lecture."

#: src/du.c:981 src/sort.c:3567 src/wc.c:731
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr ""
"pendant le lecture de noms de fichier depuis l'entrée standard, nom de "
"fichier de %s non permis"

#: src/du.c:998 src/du.c:1006 src/wc.c:744 src/wc.c:752
msgid "invalid zero-length file name"
msgstr "taille invalide de longueur zéro de nom de fichier"

#: src/du.c:1023 src/head.c:152 src/head.c:265 src/head.c:337 src/head.c:541
#: src/head.c:623 src/head.c:695 src/head.c:753 src/head.c:777 src/tail.c:404
#: src/tail.c:492 src/tail.c:541 src/tail.c:634 src/tail.c:762 src/tail.c:810
#: src/tail.c:849 src/tail.c:1629 src/tail.c:1658 src/uniq.c:394
#, c-format
msgid "error reading %s"
msgstr "Erreur lors de la lecture %s"

#: src/du.c:1026 src/ls.c:2577 src/wc.c:774
msgid "total"
msgstr "total"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:27
msgid "Brian Fox"
msgstr "Brian Fox"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:28
msgid "Chet Ramey"
msgstr "Chet Ramey"

#: src/echo.c:43
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... [STRING]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"Usage : %s [SHORT-OPTION]... [STRING]...\n"
"  ou :  %s LONG-OPTION\n"

#: src/echo.c:47
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n             do not output the trailing newline\n"
msgstr ""
"Faire l'écho des CHAINES sur la sortie standard.\n"
"\n"
"  -n             ne pas produire sur la sortie la nouvelle ligne de queue\n"

#: src/echo.c:53
msgid ""
"  -e             enable interpretation of backslash escapes (default)\n"
"  -E             disable interpretation of backslash escapes\n"
msgstr ""
"  -e             autoriser l'interprétation des échappements de barre "
"oblique inverse (par défaut)\n"
"  -E             désactiver l'interprétation des échappements de barre "
"oblique inverse\n"

#: src/echo.c:56
msgid ""
"  -e             enable interpretation of backslash escapes\n"
"  -E             disable interpretation of backslash escapes (default)\n"
msgstr ""
"  -e             autorise l'interprétation des échappements de barre oblique "
"inverse\n"
"  -E             désactiver l'interprétation des échappements de barre "
"oblique inverse(par défaut)\n"

#: src/echo.c:62
msgid ""
"\n"
"If -e is in effect, the following sequences are recognized:\n"
"\n"
msgstr ""

#: src/echo.c:67 src/printf.c:106
#, fuzzy
msgid ""
"  \\\\      backslash\n"
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\e      escape\n"
"  \\f      form feed\n"
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\c     ne produit pas d'autre sortie\n"
"  \\f     saut de page\n"
"  \\n     saut de ligne\n"
"  \\r     retour de chariot\n"
"  \\t     tabulation horizontale\n"
"  \\v     tabulation verticale\n"

#: src/echo.c:79
msgid ""
"  \\0NNN   byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:32 src/printenv.c:45 src/whoami.c:36
msgid "Richard Mlynarik"
msgstr "Richard Mlynarik"

#: src/env.c:53
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr "Usage: %s [OPTION]... [-] [NOM=VALEUR]... [COMMANDE] [ARG]...\n"

#: src/env.c:56
#, fuzzy
msgid ""
"Set each NAME to VALUE in the environment and run COMMAND.\n"
"\n"
"  -i, --ignore-environment  start with an empty environment\n"
"  -0, --null           end each output line with 0 byte rather than newline\n"
"  -u, --unset=NAME     remove variable from the environment\n"
msgstr ""
"Initialiser chaque VARIABLE à la VALEUR dans l'environnement\n"
"et exécuter la COMMANDE.\n"
"\n"
"  -i, --ignore-environment   débuter avec un environnement vide\n"
"  -u, --unset=VARIABLE       retirer la VARIABLE de l'environment\n"

#: src/env.c:65
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"Un simple - implique -i.  Si aucune COMMANDE n'est fournie,\n"
"afficher les variables d'environnement.\n"

#: src/env.c:121
#, fuzzy, c-format
msgid "cannot unset %s"
msgstr "ne peut exécuter %s"

#: src/env.c:131
#, fuzzy, c-format
msgid "cannot set %s"
msgstr "ne peut évaluer %s"

#: src/env.c:145
#, c-format
msgid "cannot specify --null (-0) with command"
msgstr ""

#: src/expand.c:107
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Convertir les tabulations de chaque FICHIER par des blancs d'espacement,\n"
"en écrivant sur la sortie standard.\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/expand.c:115
msgid ""
"  -i, --initial       do not convert tabs after non blanks\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
msgstr ""
"  -i, --initial       ne pas convertir les tabulations après des non-blancs\n"
"  -t, --tabs=N        utiliser N caractères de tabulations à part et non 8\n"

#: src/expand.c:119
msgid ""
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""
"  -t, --tabs=LISTE    utiliser la LISTE explicite de positions de "
"tabulation\n"

#: src/expand.c:172 src/unexpand.c:191
#, c-format
msgid "tab stop is too large %s"
msgstr "L'arrêt de tabulation %s est trop grand."

#: src/expand.c:180 src/unexpand.c:199
#, c-format
msgid "tab size contains invalid character(s): %s"
msgstr "La taille de la tabulation contient des caractères invalides: %s."

#: src/expand.c:206 src/unexpand.c:225
#, c-format
msgid "tab size cannot be 0"
msgstr "La taille de la tabulation ne peut être 0."

#: src/expand.c:208 src/unexpand.c:227
#, c-format
msgid "tab sizes must be ascending"
msgstr "Les tailles de tabulation doivent être croissantes."

#: src/expand.c:325 src/expand.c:344 src/unexpand.c:373 src/unexpand.c:420
#, c-format
msgid "input line is too long"
msgstr "ligne d'entrée est trop longue"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:151 src/ln.c:39 src/mv.c:41 src/tee.c:33
msgid "Mike Parker"
msgstr "Mike Parker"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:152 src/groups.c:36
msgid "James Youngman"
msgstr "James Youngman"

#: src/expr.c:204
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s EXPRESSION\n"
"   ou: %s OPTION\n"

#: src/expr.c:212
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"Afficher la valeur de l'EXPRESSION sur la sortie standard.  Une ligne "
"blanche\n"
"sépare la précédence croissante des groupes. L'EXPRESSION peut être:\n"
"\n"
"  ARG1 | ARG2          ARG1 s'il est nul ou 0, autrement ARG2\n"
"\n"
"  ARG1 & ARG2          ARG1 si aucun des arguments est nul ou 0, autrement "
"0\n"

#: src/expr.c:221
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  ARG1 <  ARG2         ARG1 si plus petit que ARG2\n"
"  ARG1 <= ARG2         ARG1 si plus petit ou égal à ARG2\n"
"  ARG1 =  ARG2         ARG1 si égal à ARG2\n"
"  ARG1 != ARG2         ARG1 n'est pas égal à ARG2\n"
"  ARG1 >= ARG2         ARG1 si plus grand ou égal à ARG2\n"
"  ARG1 >  ARG2         ARG1 si plus grand que ARG2\n"

#: src/expr.c:230
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  ARG1 + ARG2       somme arithmétique de ARG1 et ARG2\n"
"  ARG1 - ARG2       différence arithmétique de ARG1 et ARG2\n"

#: src/expr.c:237
#, no-c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  ARG1 * ARG2       produit arithmétique de ARG1 et ARG2\n"
"  ARG1 / ARG2       quotient arithmétique de ARG1 divisé par ARG2\n"
"  ARG1 % ARG2       reste arithmétique ARG1 divisé par ARG2\n"

#: src/expr.c:243
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  CHAÎNE: EXPREG   patron d'ancrage de concordance de l'EXPREG dans la "
"CHAÎNE\n"
"\n"
"  match CHAÎNE EXPREG      identique à CHAÎNE: EXPREG\n"
"  substr CHAÎNE POS LONG   sous-chaîne de CHAÎNE débutant à la POSition\n"
"                           (comptée à partir de 1) et ayant une LONGueur\n"
"  index CHAÎNE CAR         valeur de la position du CARactère retrouvé\n"
"                           dans la CHAÎNE, sinon 0\n"
"  length CHAÎNE            longueur de la CHAÎNE\n"

#: src/expr.c:252
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like `match' or an operator like `/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""
"  + JETON                  interpréter le JETON comme une chaîne, même si "
"c'est\n"
"                           un mot clé comme « match » ou un opérateur comme "
"« / »\n"
"\n"
"  ( EXPRESSION )           valeur de l'EXPRESSION\n"

#: src/expr.c:258
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"Portez attention au fait que plusieurs opérateurs peuvent être escamotés\n"
"ou commentés par certains shells.\n"
"Les comparaisons sont arithmétiques si les deux ARGuments sont des nombres,\n"
"autrement elles sont lexicographiques.\n"
"Les concordances de patrons retournent la chaîne retrouvée si elle est\n"
"encapsulée entre \\( et \\) ou nul; si \\( et \\) ne sont pas utilisés,\n"
"le nombre de caractères qui concordent est retourné sinon 0.\n"

#: src/expr.c:265
msgid ""
"\n"
"Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is "
"null\n"
"or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n"
msgstr ""
"\n"
"L'état de fin d'exécution est 0 si l'EXPRESSION est soit nulle ou 0, 1 si "
"l'EXPRESSION est nulle\n"
"ou 0, 2 si l'EXPRESSION est syntaxiquement invalide et 3 si une erreur est "
"survenue.\n"

#: src/expr.c:279
#, c-format
msgid "syntax error"
msgstr "erreur de syntaxe"

#: src/expr.c:598 src/ptx.c:285
#, c-format
msgid "error in regular expression matcher"
msgstr "erreur dans l'expression régulière recherchée."

#: src/expr.c:790 src/expr.c:827
#, c-format
msgid "non-numeric argument"
msgstr "argument non numérique"

#: src/expr.c:792 src/truncate.c:326
#, c-format
msgid "division by zero"
msgstr "division par zéro"

#: src/expr.c:888
#, c-format
msgid "the strings compared were %s and %s"
msgstr "les chaînes comparées étaient %s et %s"

#: src/factor.c:447
msgid "using arbitrary-precision arithmetic"
msgstr "utilise une arithmétique arbitrary-precision"

#: src/factor.c:458
msgid "using single-precision arithmetic"
msgstr "utilise une arithmétique single-precision"

#: src/factor.c:463 src/od.c:1640 src/od.c:1709
#, c-format
msgid "%s is too large"
msgstr "%s est trop grand"

#: src/factor.c:467
#, c-format
msgid "%s is not a valid positive integer"
msgstr "%s n'est pas un entier positif valide."

#: src/factor.c:493
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s [NOMBRE]...\n"
"   ou: %s OPTION\n"

#: src/factor.c:498
msgid ""
"Print the prime factors of each specified integer NUMBER.  If none\n"
"are specified on the command line, read them from standard input.\n"
"\n"
msgstr ""
"Affiche les facteurs premiers de tous les NOMBRES entiers spécifiés.\n"
"Si aucun argument n'est fourni, les nombres sont lus depuis l'entrée "
"standard.\n"
"\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/fmt.c:36
msgid "Ross Paterson"
msgstr "Ross Paterson"

#: src/fmt.c:269
#, c-format
msgid "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"
msgstr "Usage : %s [-WIDTH] [OPTION]... [FICHIER]...\n"

#: src/fmt.c:270
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"The option -WIDTH is an abbreviated form of --width=DIGITS.\n"
"\n"
msgstr ""
"Reformate chaque paragraphe de FICHIER(s), en écrivant sur la\n"
"sortie standard.\n"
"L'option -WIDTH est un forme abrégée de --width=DIGITS.\n"
"\n"

#: src/fmt.c:278
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
"                              reattaching the prefix to reformatted lines\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin        préserver l'indentation des 2 premières lignes\n"
"  -p, --prefix=CHAÎNE       reformater seulement les lignes débutant par "
"CHAÎNE\n"
"                              en réattanchant le préfixe aux lignes "
"reformatées\n"
"  -s, --split-only          briser les longues lignes mais sans les remplir\n"

#: src/fmt.c:285
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
msgstr ""
"  -t, --tagged-paragraph    indenter différemment la 1ère ligne de la 2ème\n"
"  -u, --uniform-spacing     séparer d'un blanc les mots,\n"
"                            puis de deux après chaque phrase\n"
"  -w, --width=N             utiliser une largeur de N colonnes pour une\n"
"                            pour une ligne (par défaut 75 colonnes)\n"

#: src/fmt.c:354
#, c-format
msgid ""
"invalid option -- %c; -WIDTH is recognized only when it is the first\n"
"option; use -w N instead"
msgstr ""
"option invalide -- %c; -WIDTH est reconnue seulement lorsque c'est la "
"première\n"
"option; utiliser -w N à la place"

#: src/fmt.c:396
#, c-format
msgid "invalid width: %s"
msgstr "Largeur invalide: %s"

#: src/fold.c:70
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
"\n"
msgstr ""
"Limiter la longueur de chaque ligne de chaque FICHIER (entrée standard par\n"
"défaut) et forcer le bouclage sur la ligne suivante en écrivant sur la "
"sortie standard.\n"
"\n"

#: src/fold.c:78
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         compter les octets au lieu des colonnes\n"
"  -s, --spaces        briser la ligne sur des blancs\n"
"  -w, --width=N       utiliser N colonnes au lieu de 80\n"

#: src/fold.c:287 src/pr.c:836
#, c-format
msgid "invalid number of columns: %s"
msgstr "nombre invalide de colonnes: %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/getlimits.c:29 src/stdbuf.c:38 src/timeout.c:74 src/truncate.c:42
msgid "Padraig Brady"
msgstr "Padraig Brady"

#: src/getlimits.c:66
#, c-format
msgid "Usage: %s\n"
msgstr "Usage : %s\n"

#: src/getlimits.c:70
msgid ""
"Output platform dependent limits in a format useful for shell scripts.\n"
"\n"
msgstr ""
"Limites dépendant de la plate-forme de sortie dans un format utile pour les "
"scripts shell.\n"
"\n"

#: src/group-list.c:67 src/id.c:305 src/setuidgid.c:184
#, c-format
msgid "failed to get groups for user %s"
msgstr "échec de récupération des groupes de l'usager %s"

#: src/group-list.c:72 src/id.c:310
#, c-format
msgid "failed to get groups for the current process"
msgstr "échec de récupération des groupes du processus en cours"

#: src/group-list.c:102
#, c-format
msgid "cannot find name for group ID %lu"
msgstr "ne peut trouver le nom de l'identificateur de groupe %lu"

#: src/groups.c:54
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]...\n"
msgstr "Usage : %s [OPTION]... [NOM-D'USAGER]...\n"

#: src/groups.c:55
msgid ""
"Print group memberships for each USERNAME or, if no USERNAME is specified, "
"for\n"
"the current process (which may differ if the groups database has changed).\n"
msgstr ""
"Affiche l'appartenance à des groupes pour chaque USERNAME ou, si pas de "
"USERNAME spécifié,\n"
"pour le processus en cours (lequel est différent si la database des groupes "
"a changé).\n"

#: src/groups.c:114 src/id.c:198
#, c-format
msgid "%s: No such user"
msgstr "%s: usager inexistant."

#: src/head.c:112
msgid ""
"Print the first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Afficher les 10 premières lignes de chaque FICHIER sur la sortie standard.\n"
"Avec plus d'un FICHIER, précéder chacun d'une en-tête donnant le nom du "
"fichier.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/head.c:121
#, fuzzy
msgid ""
"  -c, --bytes=[-]K         print the first K bytes of each file;\n"
"                             with the leading `-', print all but the last\n"
"                             K bytes of each file\n"
"  -n, --lines=[-]K         print the first K lines instead of the first 10;\n"
"                             with the leading `-', print all but the last\n"
"                             K lines of each file\n"
msgstr ""
"  -c, --bytes=[-]N         afficher les premiers N octets de chaque "
"fichier;\n"
"                             lorsque précédé du préfixe `-', afficher tous "
"les octets\n"
"                             sauf les derniers N octets de chaque fichier\n"
"  -n, --lines=[-]N         afficher les N premières lignes au lieu des 10 "
"premières;\n"
"                             lorsque précédé du préfixe `-', afficher toutes "
"les lignes\n"
"                             sauf les N dernières lignes de chaque fichier\n"

#: src/head.c:129
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent    ne pas afficher les en-têtes avec les\n"
"                            noms de fichiers\n"
"  -v, --verbose            toujours afficher les en-têtes avec les\n"
"                            noms de fichiers\n"

#: src/head.c:135
#, fuzzy
msgid ""
"\n"
"K may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
msgstr ""
"\n"
"N peut avoir un suffixe multiplicateur :\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, et ainsi de suite pour T, P, E, Z, Y.\n"

#: src/head.c:155
#, c-format
msgid "error writing %s"
msgstr "Erreur lors de l'écriture %s"

#: src/head.c:158
#, c-format
msgid "%s: file has shrunk too much"
msgstr "%s: fichier a trop été réduit"

#: src/head.c:231 src/head.c:1047
#, c-format
msgid "%s: number of bytes is too large"
msgstr "%s: nombre d'octets est trop grand"

#: src/head.c:444
#, c-format
msgid "%s: cannot lseek back to original position"
msgstr "%s: ne peut repérer via lseek() par rapport à la position originale"

#: src/head.c:616 src/head.c:687 src/tail.c:442
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s: ne peut repérer selon le déplacement %s"

#: src/head.c:794
#, c-format
msgid "cannot reposition file pointer for %s"
msgstr "ne peut repositionner le pointeur de fichier pour %s"

#: src/head.c:881
#, c-format
msgid "%s: %s is so large that it is not representable"
msgstr "%s: %s est tellement grande qu'elle n'est pas représentable."

#: src/head.c:882
msgid "number of lines"
msgstr "Nombre de lignes"

#: src/head.c:882
msgid "number of bytes"
msgstr "Nombre d'octets"

#: src/head.c:889 src/tail.c:1793
msgid "invalid number of lines"
msgstr "nombre invalide de lignes."

#: src/head.c:890 src/tail.c:1794
msgid "invalid number of bytes"
msgstr "nombre d'octets invalide."

#: src/head.c:977 src/head.c:1035
#, c-format
msgid "invalid trailing option -- %c"
msgstr "option de terminaison invalide --%c"

#: src/hostid.c:44
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"Usage : %s [OPTION]\n"
"Affiche l'identificateur numérique (en hexadécimal) de l'hôte courant.\n"
"\n"

#: src/hostname.c:57
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"Usage: %s [NOM]\n"
"   ou: %s OPTION\n"
"Afficher le nom du poste (hostname) du système courant.\n"
"\n"

#: src/hostname.c:95
#, c-format
msgid "cannot set name to %s"
msgstr "ne peut initialiser le nom à %s"

#: src/hostname.c:98
#, c-format
msgid "cannot set hostname; this system lacks the functionality"
msgstr ""
"Ne peut nommer le poste (hostname); le système ne supporte pas cette fonction"

#: src/hostname.c:106
#, c-format
msgid "cannot determine hostname"
msgstr "Ne peut déterminer le nom du poste (hostname)"

#. This is a proper name. See the gettext manual, section Names.
#: src/id.c:38 src/touch.c:43
msgid "Arnold Robbins"
msgstr "Arnold Robbins"

#: src/id.c:82
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]\n"
msgstr "Usage: %s [OPTION]... [NOM-D'USAGER]\n"

#: src/id.c:83
msgid ""
"Print user and group information for the specified USERNAME,\n"
"or (when USERNAME omitted) for the current user.\n"
"\n"
"  -a              ignore, for compatibility with other versions\n"
"  -Z, --context   print only the security context of the current user\n"
"  -g, --group     print only the effective group ID\n"
"  -G, --groups    print all group IDs\n"
"  -n, --name      print a name instead of a number, for -ugG\n"
"  -r, --real      print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user      print only the effective user ID\n"
msgstr ""
"Affiche les informations d'usager et de groupe de USAGER, ou\n"
" (quand USAGER est omis) de l'usager courant.\n"
"\n"
"  -a              ignorée, pour compatibilité avec les autres version\n"
"  -Z, --context   affiche seulement le contexte de sécurité de l'usager "
"actif\n"
"  -g, --group     affiche seulement l'IDentificateur du groupe effectif\n"
"  -G, --groups    affiche tous les IDs de groupes\n"
"  -n, --name      affiche le nom au lieu du nombre, pour -ugG\n"
"  -r, --real      affiche l'ID réel au lieu de l'ID effectif, avec -ugG\n"
"  -u, --user      affiche seulement l'IDentificateur effectif de l'usager\n"

#: src/id.c:97
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"Sans aucune OPTION, afficher les informations utiles d'identification.\n"

#: src/id.c:141
#, c-format
msgid "--context (-Z) works only on an SELinux-enabled kernel"
msgstr "--context (-Z) ne fonctionne que sur un noyau activé pour SELinux"

#: src/id.c:175
#, c-format
msgid "cannot print security context when user specified"
msgstr "ne peut afficher le contexte de sécurité quand un usager est spécifié"

#: src/id.c:184
#, c-format
msgid "can't get process context"
msgstr "Ne peut trouver le contexte de traitement"

#: src/id.c:188
#, c-format
msgid "cannot print \"only\" of more than one choice"
msgstr "ne peut afficher \"un seul\" parmi plusieurs choix"

#: src/id.c:192
#, c-format
msgid "cannot print only names or real IDs in default format"
msgstr ""
"Ne peut afficher seulement les noms ou les IDentificateurs réels\n"
"dans le format par défaut."

#: src/id.c:249
#, c-format
msgid "cannot find name for user ID %lu"
msgstr "ne peut trouver le nom de l'usager ID %lu"

#: src/id.c:269
#, c-format
msgid "uid=%lu"
msgstr "uid=%lu"

#: src/id.c:274
#, c-format
msgid " gid=%lu"
msgstr " gid=%lu"

#: src/id.c:281
#, c-format
msgid " euid=%lu"
msgstr " euid=%lu"

#: src/id.c:289
#, c-format
msgid " egid=%lu"
msgstr " egid=%lu"

#: src/id.c:317
msgid " groups="
msgstr " groupes="

#: src/id.c:333
#, c-format
msgid " context=%s"
msgstr "contexte=%s"

#: src/install.c:377
#, c-format
msgid "warning: %s: failed to change context to %s"
msgstr "avertissement : %s : échec de l'établissement du contexte %s"

#: src/install.c:535
#, fuzzy, c-format
msgid ""
"WARNING: --preserve_context is deprecated; use --preserve-context instead"
msgstr ""
"Attention : ne prend pas en compte --preserve-context ; ce noyau n'a pas "
"SELinux-enabled activé."

#: src/install.c:541
#, c-format
msgid ""
"WARNING: ignoring --preserve-context; this kernel is not SELinux-enabled"
msgstr ""
"Attention : ne prend pas en compte --preserve-context ; ce noyau n'a pas "
"SELinux-enabled activé."

#: src/install.c:551
#, c-format
msgid "WARNING: ignoring --context (-Z); this kernel is not SELinux-enabled"
msgstr ""
"Attention : pas pris en compte --context (-Z) ; ce noyau n'a pas SELinux-"
"enable activé."

#: src/install.c:568
#, c-format
msgid "the strip option may not be used when installing a directory"
msgstr "l'option strip est invalide lors de l'installation d'un répertoire"

#: src/install.c:571
#, c-format
msgid "target directory not allowed when installing a directory"
msgstr ""
"le répertoire cible n'est pas permis lors de l'installation d'un répertoire"

#: src/install.c:575
#, c-format
msgid "cannot force target context to %s and preserve it"
msgstr "ne peut forcer le contexte cible à %s et le préserver"

#: src/install.c:629 src/mkdir.c:203 src/stdbuf.c:327
#, c-format
msgid "invalid mode %s"
msgstr "mode invalide %s"

#: src/install.c:636
#, c-format
msgid "WARNING: ignoring --strip-program option as -s option was not specified"
msgstr ""
"ATTENTION : pas pris en compte --strip-program du fait que l'option -s "
"n'était pas spécifiée"

#: src/install.c:641
#, c-format
msgid "options --compare (-C) and --preserve-timestamps are mutually exclusive"
msgstr ""
"les options --compare (-C) et --preserve-timestamps s'excluent mutuellement"

#: src/install.c:648
#, c-format
msgid "options --compare (-C) and --strip are mutually exclusive"
msgstr "les options --compare (-C) et --strip s'excluent mutuellement"

#: src/install.c:654
#, c-format
msgid ""
"the --compare (-C) option is ignored when you specify a mode with non-"
"permission bits"
msgstr ""
"l'option --compare (-C) est ignorée quand est spécifié un mode non-"
"permission bits"

#: src/install.c:806
#, c-format
msgid "cannot change ownership of %s"
msgstr "Ne peut changer l'appartenance de %s"

#: src/install.c:830
#, c-format
msgid "cannot set time stamps for %s"
msgstr "ne peut initialiser les estampilles de date-heure pour %s"

#: src/install.c:851 src/timeout.c:283
#, c-format
msgid "fork system call failed"
msgstr "échec de l'appel système fork()"

#: src/install.c:855
#, c-format
msgid "cannot run %s"
msgstr "ne peut exécuter %s"

#: src/install.c:859
#, c-format
msgid "waiting for strip"
msgstr "en attente de bande"

#: src/install.c:861
#, c-format
msgid "strip process terminated abnormally"
msgstr "le traitement en chaîne s'est arrêté anormalement"

#: src/install.c:882
#, c-format
msgid "invalid user %s"
msgstr "usager invalide %s"

#: src/install.c:917
#, c-format
msgid "creating directory %s"
msgstr "création du répertoire %s"

#: src/install.c:940
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
"  or:  %s [OPTION]... -d DIRECTORY...\n"
msgstr ""
"Usage: %s [OPTION]... [-T] SOURCE CIBLE\n"
"   ou: %s [OPTION]... SOURCE... RÉPERTOIRE\n"
"   ou: %s [OPTION]... -t RÉPERTOIRE SOURCE...\n"
"   ou: %s [OPTION]... -d RÉPERTOIRE...\n"

#: src/install.c:947
msgid ""
"\n"
"This install program copies files (often just compiled) into destination\n"
"locations you choose.  If you want to download and install a ready-to-use\n"
"package on a GNU/Linux system, you should instead be using a package "
"manager\n"
"like yum(1) or apt-get(1).\n"
"\n"
"In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the 4th form, create all components of the given DIRECTORY(ies).\n"
"\n"
msgstr ""
"\n"
"Ce programme d'installation copie les fichiers (souvent juste compilés) vers "
"la \n"
"localisation que vous voulez.  Si vous voulez télécharger et installer un "
"paquetage\n"
"prêt à l'emploi sur GNU/Linux, vous devriez plutôt passer par le "
"gestionnaire de paquets\n"
"comme yum(1) ou apt-get(1).\n"
"\n"
"Dans les trois premiers formats, copie la SOURCE vers la DESTINATION ou des\n"
"fichiers de plusieurs SOURCE(S) vers un RÉPERTOIRE existant, tout en "
"initialisant\n"
"les modes de protection et l'appartenance propriétaire/groupe.  Dans le\n"
"4e format, créer tous les composants des RÉPERTOIRES spécifiés.\n"
"\n"

#: src/install.c:962
msgid ""
"      --backup[=CONTROL]  make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -C, --compare       compare each pair of source and destination files, "
"and\n"
"                        in some cases, do not modify the destination at all\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=CONTRÔLE]      archive chaque fichier de destination\n"
"  -b                           identique à --backup mais n'accepte pas "
"d'argument\n"
"  -c                           (ignoré)\n"
"  -C, --compare       compare chaque pair de fichier source et destination, "
"et\n"
"                        dans certains cas, ne modifie pas du tout la "
"destination\n"
"  -d, --directory              traite tous les arguments comme des noms\n"
"                               de répertoire ; crée tous les composants\n"
"                               des répertoires spécifiés\n"

#: src/install.c:971
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        then copy SOURCE to DEST\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""
"  -D                        créer tous les composants de tête de la\n"
"                              DESTINATION excepté le dernier\n"
"                              ensuite copier la SOURCE vers la DESTINATION\n"
"  -g, --group=GROUPE        attribuer l'appartenance au GROUPE,\n"
"                              plutôt que le groupe du processus courant\n"
"  -m, --mode=MODE           initialiser les permissions d'accès au MODE\n"
"                              (comme par chmod), au lieu de rwxrr-xr-x\n"
"  -o, --owner=PROPRIÉTAIRE  attribuer l'appartenance au PROPRIÉTAIRE\n"
"                              (par le super-usager seulement)\n"

#: src/install.c:978
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables\n"
"      --strip-program=PROGRAM  program used to strip binaries\n"
"  -S, --suffix=SUFFIX  override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory  treat DEST as a normal file\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps applique les dates d'accès/ modification\n"
"                              des fichiers SOURCES aux fichiers de "
"destination correspondants\n"
"  -s, --strip               enleve les tables des symboles\n"
"      --strip-program=PROGRAMME qui enlève la table des symboles du binaire\n"
"  -S, --suffix=SUFFIXE      se substitue au SUFFIXE usuel d'archivage\n"
"  -t, --target-directory=RÉPERTOIRE  copie tous les arguments de la SOURCE "
"dans RÉPERTOIRE\n"
"  -T, --no-target-directory traite DEST comme un fichier normal\n"
"  -v, --verbose             affiche le nom de chaque répertoire créé\n"

#: src/install.c:988
msgid ""
"      --preserve-context  preserve SELinux security context\n"
"  -Z, --context=CONTEXT  set SELinux security context of files and "
"directories\n"
msgstr ""
"      --preserve-context  préserve le contexte de sécurité SELinux\n"
"  -Z, --context=CONTEXT  établit le contexte de sécurité SELinux des "
"fichiers et répertoires\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/join.c:39 src/sort.c:62
msgid "Mike Haertel"
msgstr "Mike Haertel"

#: src/join.c:172
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a FILENUM        print unpairable lines coming from file FILENUM, where\n"
"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"Pour chaque paire de lignes en entrée ayant des champs de fusion "
"identiques,\n"
"afficher une ligne sur la sortie standard.\n"
"Le champ de fusion par défaut est le premier, délimité par un blanc.\n"
"Si FICHIER1 ou FICHIER2 (pas les 2) est -, lire de l'entrée standard.\n"
"\n"
"  -a COTÉ           afficher les lignes non repérables venant du \n"
"                    fichier COTÉ\n"
"  -e VIDE           remplacer les champs d'entrée manquants par VIDE\n"

#: src/join.c:181
msgid ""
"  -i, --ignore-case  ignore differences in case when comparing fields\n"
"  -j FIELD          equivalent to `-1 FIELD -2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case ignore la casse lors de la comparaison de champs\n"
"  -j CHAMP          équivalent à « -1 CHAMP -2 CHAMP »\n"
"  -o FORMAT         respecte FORMAT lors de la construction de la ligne\n"
"                    de sortie\n"
"  -t CAR            utilise CAR comme délimiteur de champs d'entrée\n"
"                    et de sortie\n"

#: src/join.c:187
msgid ""
"  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
msgstr ""
"  -v NOFICHIER      comme -a NOFICHIER, mais supprime les lignes jointes sur "
"la sortie\n"
"  -1 CHAMP          fusionne sur le champs CHAMP du fichier 1\n"
"  -2 CHAMP          fusionne sur le champs CHAMP du fichier 2\n"
"  --check-order     vérifie que l'entrée est triée, même\n"
"                      si toutes les lignes en entrée sont appairées\n"
"  --nocheck-order   ne vérifie pas que l'entrée est triée\n"

#: src/join.c:197
#, fuzzy
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `FILENUM.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.\n"
"\n"
"Important: FILE1 and FILE2 must be sorted on the join fields.\n"
"E.g., use `sort -k 1b,1' if `join' has no options.\n"
"Note, comparisons honor the rules specified by `LC_COLLATE'.\n"
"If the input is not sorted and some lines cannot be joined, a\n"
"warning message will be given.\n"
msgstr ""
"\n"
"À moins que -t CAR ne soit fourni, les blancs de tête séparent\n"
"les champs et sont ignorés sinon les champs sont séparés par CAR.\n"
"Chaque CHAMP est un numéro de champ à partir de 1.\n"
"FORMAT est une, ou plus, spécifications séparées par une virgule ou blanc,\n"
"chacun étant « NOFICHIER.CHAMP » ou « 0 ».  Par défaut FORMAT affiche le\n"
"champ fusionné, les champs restants de FICHIER1 et de FICHIER2, tous séparés "
"par CAR.\n"
"\n"
"Important: FILE1 et FILE2 doivent être triés sur les champs de jointure.\n"
"E.g., use `sort -k 1b,1' si `join' n'a pas d'options.\n"
"Si l'entrée n'est pas triée et quelques lignes ne peuvent être fusionnées,\n"
"un message d'alerte l'indiquera.\n"

#: src/join.c:776 src/join.c:975
#, c-format
msgid "invalid field number: %s"
msgstr "numéro de champ invalide: %s"

#: src/join.c:797 src/join.c:806
#, c-format
msgid "invalid field specifier: %s"
msgstr "spécificateur de champ invalide: %s"

#: src/join.c:813
#, c-format
msgid "invalid file number in field spec: %s"
msgstr "numéro de fichier invalide le champ spécifié: %s"

#: src/join.c:856
#, c-format
msgid "incompatible join fields %lu, %lu"
msgstr "jonction incompatible des champs %lu, %lu"

#: src/join.c:986
#, c-format
msgid "conflicting empty-field replacement strings"
msgstr "chaînes de remplacement de champ vide conflictuelles"

#: src/join.c:1027 src/sort.c:3466
#, c-format
msgid "empty tab"
msgstr "tabulation vide"

#: src/join.c:1033 src/sort.c:3477
#, c-format
msgid "multi-character tab %s"
msgstr "tab multi-caractères %s"

#: src/join.c:1037 src/sort.c:3482
#, c-format
msgid "incompatible tabs"
msgstr "tabulations incompatibles"

#: src/join.c:1102
#, c-format
msgid "both files cannot be standard input"
msgstr "Les deux fichiers ne peuvent pas être à l'entrée standard."

#: src/kill.c:87
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"   ou: %s -l [SIGNAL]...\n"
"   ou: %s -t [SIGNAL]...\n"

#: src/kill.c:93
msgid ""
"Send signals to processes, or list signals.\n"
"\n"
msgstr ""
"Transmettre les signaux aux processus ou donner la liste des signaux.\n"
"\n"

#: src/kill.c:100
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   utiliser le nom ou le numéro du signal à transmettre.\n"
"  -l, --list       donner la liste des noms de signaux.\n"
"  -t, --table      afficher la table des informations relatives aux "
"signaux.\n"

#: src/kill.c:108
msgid ""
"\n"
"SIGNAL may be a signal name like `HUP', or a signal number like `1',\n"
"or the exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""
"\n"
"SIGNAL peut être un nom de signal comme «HUP» ou un numéro de signal comme "
"«1»,\n"
"ou un status de fin d'un processus terminé par un signal.\n"
"PID est un entier; si négatif il identifie un groupe de processus.\n"

#: src/kill.c:217
#, c-format
msgid "%s: invalid process id"
msgstr "%s: identificateur de processus invalide"

#: src/kill.c:271
#, c-format
msgid "invalid option -- %c"
msgstr "option invalide --%c"

#: src/kill.c:280
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s: signaux multiples spécifiés"

#: src/kill.c:294
#, c-format
msgid "multiple -l or -t options specified"
msgstr "options multiples -l ou -t spécifiées"

#: src/kill.c:311
#, c-format
msgid "cannot combine signal with -l or -t"
msgstr "ne peut combiner le signal avec -l ou -t"

#: src/kill.c:317
#, c-format
msgid "no process ID specified"
msgstr "aucun ID de processus spécifié"

#: src/libstdbuf.c:109
#, c-format
msgid "failed to allocate a %<PRIuMAX> byte stdio buffer\n"
msgstr ""

#: src/libstdbuf.c:116
#, fuzzy, c-format
msgid "invalid buffering mode %s for %s\n"
msgstr "argument %s invalide pour %s"

#: src/libstdbuf.c:124
#, c-format
msgid "could not set buffering of %s to mode %s\n"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/link.c:36 src/unlink.c:36 src/who.c:46
msgid "Michael Stone"
msgstr "Michael Stone"

#: src/link.c:46
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s FICHIER FICHIER2\n"
"   ou: %s OPTION\n"

#: src/link.c:49
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"Appeler la fonction link() pour créer un lien nommé FICHIER2 sur le FICHIER1 "
"existant.\n"
"\n"

#: src/link.c:91
#, c-format
msgid "cannot create link %s to %s"
msgstr "Ne peut créer le lien %s vers %s"

#: src/ln.c:156
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: lien direct non permis pour un répertoire"

#: src/ln.c:221
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s: ne peut écraser le répertoire"

#: src/ln.c:226
#, c-format
msgid "%s: replace %s? "
msgstr "%s: remplacer %s? "

#: src/ln.c:307
#, c-format
msgid "creating symbolic link %s"
msgstr "création d'un lien symbolique %s"

#: src/ln.c:308
#, c-format
msgid "creating symbolic link %s -> %s"
msgstr "création d'un lien symbolique %s vers %s "

#: src/ln.c:310
#, c-format
msgid "creating hard link to %.0s%s"
msgstr "création d'un lien direct sur %.0s%s"

#: src/ln.c:313
#, c-format
msgid "creating hard link %s"
msgstr "création d'un lien direct %s"

#: src/ln.c:314
#, c-format
msgid "creating hard link %s => %s"
msgstr "création d'un lien direct de %s vers %s"

#: src/ln.c:336
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] TARGET LINK_NAME   (1st form)\n"
"  or:  %s [OPTION]... TARGET                  (2nd form)\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY     (3rd form)\n"
"  or:  %s [OPTION]... -t DIRECTORY TARGET...  (4th form)\n"
msgstr ""
"Usage: %s [OPTION]... [-T] SOURCE NOM_DU_LIEN (1er format)\n"
"   ou: %s [OPTION]... CIBLE                   (2e  format)\n"
"   ou: %s [OPTION]... CIBLE... RÉPERTOIRE     (3e  format)\n"
"   ou: %s [OPTION]... -t RÉPERTOIRE CIBLE...  (4e  format)\n"

#: src/ln.c:343
msgid ""
"In the 1st form, create a link to TARGET with the name LINK_NAME.\n"
"In the 2nd form, create a link to TARGET in the current directory.\n"
"In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n"
"Create hard links by default, symbolic links with --symbolic.\n"
"When creating hard links, each TARGET must exist.  Symbolic links\n"
"can hold arbitrary text; if later resolved, a relative link is\n"
"interpreted in relation to its parent directory.\n"
"\n"
msgstr ""
"Dans le 1er format, crée un lien vers la CIBLE avec le NOM_DU_LIEN\n"
"Dans le 2e format, crée un lien vers la CIBLE dans le répertoire courant.\n"
"Dans le 3e et 4e format, crée des liens vers chaque CIBLE dans RÉPERTOIRE.\n"
"Crée des liens directs (hard link) par défaut, des liens symboliques avec --"
"symbolic.\n"
"Lors de la création de liens directs, chaque CIBLE doit exister.  Les liens "
"symboliques\n"
"peuvent contenir du simple texte; si ils sont résolus ensuite, un lien "
"relatif est\n"
"interprété par rapport a son répertoire parent.\n"
"\n"

#: src/ln.c:356
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         allow the superuser to attempt to hard link\n"
"                                directories (note: will probably fail due "
"to\n"
"                                system restrictions, even for the "
"superuser)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=CONTRÔLE]      archiver chaque fichier existant de "
"destination\n"
"  -b                           identique à --backup mais n'accepte pas "
"d'argument\n"
"  -d, -F, --directory          permettre au super usager de créer des liens "
"directs (hard)\n"
"                                sur des répertoires (note: va probablement "
"échouer en\n"
"                                raisons de restrictions système même pour le "
"super usager)\n"
"  -f, --force                  détruire les destinations,\n"
"                               sans demander confirmation\n"

#: src/ln.c:364
#, fuzzy
msgid ""
"  -i, --interactive           prompt whether to remove destinations\n"
"  -L, --logical               make hard links to symbolic link references\n"
"  -n, --no-dereference        treat destination that is a symlink to a\n"
"                                directory as if it were a normal file\n"
"  -P, --physical              make hard links directly to symbolic links\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""
"  -n, --no-dereference       avec --force, détruire la destination qui\n"
"                             est un lien symbolique vers un répertoire \n"
"  -i, --interactive          demander confirmation avant de détruire\n"
"                             les destinations\n"
"  -s, --symbolic             créer un lien symbolique au lieu d'un\n"
"                             lien direct\n"

#: src/ln.c:372
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -T, --no-target-directory   treat LINK_NAME as a normal file\n"
"  -v, --verbose               print name of each linked file\n"
msgstr ""
"  -S, --suffix=SUFFIXE       écrase le suffixe d'archivage courant\n"
"  -t, --target-directory=RÉPERTOIRE  spécifie RÉPERTOIRE dans lequel les "
"liens seront créés\n"
"  -T, --no-target-directory  traite le NOM_DU_LIEN comme un fichier normal\n"
"  -v, --verbose              affiche le nom de chaque fichier lié\n"

#: src/ln.c:388
#, c-format
msgid ""
"Using -s ignores -L and -P.  Otherwise, the last option specified controls\n"
"behavior when the source is a symbolic link, defaulting to %s.\n"
"\n"
msgstr ""

#: src/ln.c:511
#, c-format
msgid "cannot combine --target-directory and --no-target-directory"
msgstr "Ne peut combiner --target-directory et --no-target-directory"

#. This is a proper name. See the gettext manual, section Names.
#: src/logname.c:30
msgid "FIXME: unknown"
msgstr "FIXME : inconnu"

#: src/logname.c:40 src/sync.c:41
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "Usage: %s [OPTION]\n"

#: src/logname.c:41
msgid ""
"Print the name of the current user.\n"
"\n"
msgstr ""
"Afficher le nom de l'usager courant.\n"
"\n"

#: src/logname.c:85
#, c-format
msgid "no login name"
msgstr "pas de nom d'usager (login name)"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:729
msgid "%b %e  %Y"
msgstr "%b %e  %Y"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:742
msgid "%b %e %H:%M"
msgstr "%b %e %H:%M"

#: src/ls.c:1557
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr ""
"valeur invalide ignorée de la variable d'environnement QUOTING_STYLE: %s"

#: src/ls.c:1584
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr ""
"La taille des colonnes est ignorée:\n"
"la variable d'environnement COLUMNS %s est invalide."

#: src/ls.c:1614
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr ""
"La taille de tabulation est ignorée:\n"
"la variable d'environnement TABSIZE %s est invalide."

#: src/ls.c:1735 src/ptx.c:2043
#, c-format
msgid "invalid line width: %s"
msgstr "largeur de ligne invalide: %s"

#: src/ls.c:1809
#, c-format
msgid "invalid tab size: %s"
msgstr "taille de tabulation invalide: %s"

#: src/ls.c:1999
#, c-format
msgid "invalid time style format %s"
msgstr "format de style de temps invalide %s"

#: src/ls.c:2045
#, c-format
msgid "error initializing month strings"
msgstr ""

#: src/ls.c:2347
#, c-format
msgid "unrecognized prefix: %s"
msgstr "préfixe non reconnu: %s"

#: src/ls.c:2370
#, c-format
msgid "unparsable value for LS_COLORS environment variable"
msgstr ""
"la valeur de la variable d'environnement LS_COLORS ne peut être analysée "
"syntaxiquement"

#: src/ls.c:2447 src/pwd.c:162
#, c-format
msgid "cannot open directory %s"
msgstr "ne peut ouvrir le répertoire %s"

#: src/ls.c:2462
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "ne peut déterminer le périphérique et l'inode de %s"

#: src/ls.c:2471
#, c-format
msgid "%s: not listing already-listed directory"
msgstr "%s: ne peut lister un répertoire déjà listé"

#: src/ls.c:2548 src/pwd.c:230
#, c-format
msgid "reading directory %s"
msgstr "lecture du répertoire %s"

#: src/ls.c:2558
#, c-format
msgid "closing directory %s"
msgstr "fermeture du répertoire %s"

#: src/ls.c:3147
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "ne peut comparer les noms de fichier %s et %s"

#: src/ls.c:4553
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort.\n"
"\n"
msgstr ""
"Afficher les informations à propos des FICHIERS (du répertoire\n"
"courant par défaut). Trier les entrées alphabétiquement si aucune\n"
"des options  -cftuvSUX ni --sort n'est utilisée.\n"
"\n"

#: src/ls.c:4561
msgid ""
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print octal escapes for nongraphic characters\n"
msgstr ""
"  -a, --all                  ne pas ignorer les entrées débutant par .\n"
"  -A, --almost-all           ne pas inclure dans la liste . et ..\n"
"      --author               avec -l, afficher l'auteur de chaque fichier\n"
"  -b, --escape               afficher en octal les caractères non-"
"graphiques\n"

#: src/ls.c:4567
#, fuzzy
msgid ""
"      --block-size=SIZE      use SIZE-byte blocks.  See SIZE format below\n"
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                               modification of file status information)\n"
"                               with -l: show ctime and sort by name\n"
"                               otherwise: sort by ctime\n"
msgstr ""
"      --block-size=TAILLE    utiliser la TAILLE de blocs\n"
"  -B, --ignore-backups       ne pas inclure dans la liste,\n"
"                             les entrées se terminant par ~\n"
"  -c                         lister les fichiers triés selon leur date de\n"
"                             modification; \n"
"                             avec -lt:  trier par la date de modification\n"
"                                et afficher la date de modification (ctime)\n"
"                             avec -l:   trier par nom et afficher avec\n"
"                                avec la date de modification (ctime)\n"
"                             autrement: trier par la date de modification "
"(ctime)\n"

#: src/ls.c:4575
#, fuzzy
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         colorize the output.  WHEN defaults to "
"`always'\n"
"                               or can be `never' or `auto'.  More info "
"below\n"
"  -d, --directory            list directory entries instead of contents,\n"
"                               and do not dereference symbolic links\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""
"  -C                         afficher en colonnes\n"
"      --color[=PARAM]        afficher avec une couleur pour distinguer les "
"types de fichiers\n"
"                             de fichiers, selon un des PARAMètres\n"
"                             suivants: `never', `always', ou `auto'\n"
"  -d, --directory            lister les noms de répertoires plutôt\n"
"                             que leur contenu et ne pas déférencer les liens "
"symboliques\n"
"  -D, --dired                générer une sortie adaptée pour le mode\n"
"                             « dired » de Emacs\n"

#: src/ls.c:4583
msgid ""
"  -f                         do not sort, enable -aU, disable -ls --color\n"
"  -F, --classify             append indicator (one of */=>@|) to entries\n"
"      --file-type            likewise, except do not append `*'\n"
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            like -l --time-style=full-iso\n"
msgstr ""
"  -f                         ne trie pas, active -aU, désactive -ls --color\n"
"  -F, --classify             ajoute un indicateur (parmi */=>@|) aux "
"entrées\n"
"      --file-type            identique mais sans ajout de `*'\n"
"      --format=MODE          affiche selon le MODE : -x croisé,\n"
"                               -m avec virgules, -x horizontal, -l long,\n"
"                               -1 en colonne simple, -l en mode bavard,\n"
"                               -C vertical\n"
"      --full-time            identique à -l --time-style=full-iso\n"

#: src/ls.c:4591
msgid "  -g                         like -l, but do not list owner\n"
msgstr ""
"  -g                         identique à -l mais n'affiche pas le "
"propriétaire\n"

#: src/ls.c:4594
msgid ""
"      --group-directories-first\n"
"                             group directories before files.\n"
"                               augment with a --sort option, but any\n"
"                               use of --sort=none (-U) disables grouping\n"
msgstr ""
"      --group-directories-first\n"
"                             groupe les répertoires avant les fichiers.\n"
"                               augmente avec l'option a --sort, mais tout "
"usage\n"
"                               de --sort=none (-U) inhibe le groupage\n"

#: src/ls.c:4600
msgid ""
"  -G, --no-group             in a long listing, don't print group names\n"
"  -h, --human-readable       with -l, print sizes in human readable format\n"
"                               (e.g., 1K 234M 2G)\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -G, --no-group            dans une longue liste, n'affiche pas les noms de "
"groupe\n"
"  -h, --human-readable       avec -l affiche les tailles  dans un format "
"lisible par l'humain\n"
"                               (e.g., 1K 234M 2G)\n"
"      --si                   pareil, mais utilise puissance 1000 au lieu de "
"1024\n"

#: src/ls.c:4606
msgid ""
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                             that points to a directory\n"
"      --hide=PATTERN         do not list implied entries matching shell "
"PATTERN\n"
"                               (overridden by -a or -A)\n"
msgstr ""
"  -H, --dereference-command-line\n"
"                             suit les liens symboliques de la ligne de "
"commande\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             suit chaque lien symbolique de la ligne de "
"commande\n"
"                               qui pointe vers un répertoire\n"
"      --hide=PATRON          ne liste pas les entrées implicites concordant "
"avec le PATRON du shell\n"
"                               (écrasé par -a ou -A)\n"

#: src/ls.c:4615
msgid ""
"      --indicator-style=WORD  append indicator with style WORD to entry "
"names:\n"
"                               none (default), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                print the index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
"  -k                         like --block-size=1K\n"
msgstr ""
"      --indicator-style=MOT  suffixe  les noms d'entrée par l'indicateur "
"avec le style MOT :\n"
"                               none (défaut), barre oblique (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                affiche le numéro d'index de chaque fichier\n"
"  -I, --ignore=PATRON       ne liste pas les entrées implicites\n"
"                               concordant avec le PATRON du shell\n"
"  -k                         identique à --block-size=1K\n"

#: src/ls.c:4623
msgid ""
"  -l                         use a long listing format\n"
"  -L, --dereference          when showing file information for a symbolic\n"
"                               link, show information for the file the link\n"
"                               references rather than for the link itself\n"
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -l                         utiliser le format long d'affichage\n"
"  -L, --dereference          afficher les entrées pointées par des\n"
"                             liens symboliques, monter l'information pointée "
"par le lien\n"
"  -m                         remplir la largeur par une liste d'entrées\n"
"                             séparée par des virgules\n"

#: src/ls.c:4630
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
"  -N, --literal              print raw entry names (don't treat e.g. "
"control\n"
"                               characters specially)\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --indicator-style=slash\n"
"                             append / indicator to directories\n"
msgstr ""
"  -n, --numeric-uid-gid      identique à -l mais en listant les valeurs "
"numériques\n"
"                               des UID et GID\n"
"  -N, --literal              afficher les noms bruts (ne pas traiter les "
"caractères\n"
"                               de contrôle spécialement)\n"
"  -o                         identique à -l mais sans lister l'information "
"de groupe\n"
"  -p, --indicator-style=slash\n"
"                             accoler l'indicateur / aux répertoires\n"

#: src/ls.c:4638
msgid ""
"  -q, --hide-control-chars   print ? instead of non graphic characters\n"
"      --show-control-chars   show non graphic characters as-is (default\n"
"                             unless program is `ls' and output is a "
"terminal)\n"
"  -Q, --quote-name           enclose entry names in double quotes\n"
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                               literal, locale, shell, shell-always, c, "
"escape\n"
msgstr ""
"  -q, --hide-control-chars   afficher ? au lieu de caractères\n"
"                             non-graphiques\n"
"      --show-control-chars   afficher les caractères non graphiques\n"
"                             tel quel (par défaut)\n"
"  -Q, --quote-name           encapsuler chaque nom d'entrée entre\n"
"                             guillemets\n"
"      --quoting-style=MOT    utiliser le style d'encapsultation selon le MOT "
"clé\n"
"                             suivant:  literal, shell, shell-always, c, "
"escape\n"

#: src/ls.c:4646
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print the allocated size of each file, in "
"blocks\n"
msgstr ""
"  -r, --reverse              affiche en ordre inverse lors du tri\n"
"  -R, --recursive            affiche les sous-répertoires récursivement\n"
"  -s, --size                 affiche la taille allouée de chaque fichier, en "
"blocs\n"

#: src/ls.c:4651
msgid ""
"  -S                         sort by file size\n"
"      --sort=WORD            sort by WORD instead of name: none -U,\n"
"                             extension -X, size -S, time -t, version -v\n"
"      --time=WORD            with -l, show time as WORD instead of "
"modification\n"
"                             time: atime -u, access -u, use -u, ctime -c,\n"
"                             or status -c; use specified time as sort key\n"
"                             if --sort=time\n"
msgstr ""
"  -S                         trie selon la taille des fichiers\n"
"      --sort=MODE            trie selon le MODE plutôt que le nom : aucun -"
"U, \n"
"                               extension -X, taille -S, date -t, version -v\n"
"      --time=MODE            avec -l, affiche la date selon le MODE au lieu "
"de\n"
"                               la date de modification :\n"
"                               date :  atime -u, access -u, use -u, ctime -"
"c,\n"
"                               ou status -c ; utilise date spécifiée comme "
"clé de tri\n"
"                               si --sort=date\n"

#: src/ls.c:4660
msgid ""
"      --time-style=STYLE     with -l, show times using style STYLE:\n"
"                             full-iso, long-iso, iso, locale, +FORMAT.\n"
"                             FORMAT is interpreted like `date'; if FORMAT "
"is\n"
"                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n"
"                             non-recent files and FORMAT2 to recent files;\n"
"                             if STYLE is prefixed with `posix-', STYLE\n"
"                             takes effect only outside the POSIX locale\n"
msgstr ""
"      --time-style=STYLE     avec -l, affiche les dates selon STYLE :\n"
"                                full-iso, long-iso, iso, locale, +FORMAT.\n"
"                                FORMAT est interprété comme « date » ; si "
"FORMAT est\n"
"                                FORMAT1<retour de chariot>FORMAT2, FORMAT1 "
"s'applique aux\n"
"                                fichiers non récents et FORMAT2 aux fichiers "
"récents ;\n"
"                                si STYLE est préfixé par « posix- », STYLE "
"prend effet\n"
"                                seulement en dehors du particularisme POSIX\n"

#: src/ls.c:4669
msgid ""
"  -t                         sort by modification time\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""
"  -t                         trierselon la date de modification:\n"
"  -T, --tabsize=TAILLE       utiliser la tabulation selon TAILLE\n"
"                                pour chaque colonne au lieu de 8\n"

#: src/ls.c:4673
#, fuzzy
msgid ""
"  -u                         with -lt: sort by, and show, access time\n"
"                               with -l: show access time and sort by name\n"
"                               otherwise: sort by access time\n"
"  -U                         do not sort; list entries in directory order\n"
"  -v                         natural sort of (version) numbers within text\n"
msgstr ""
"  -u                         avec -lt: trier selon la date du dernier "
"accès;\n"
"                             avec -l:  afficher la date d'accès et trier par "
"nom\n"
"  -U                         ne pas trier: afficher selon l'ordre\n"
"                             original des entrées d'un répertoire\n"
"  -v                         trier par version\n"

#: src/ls.c:4680
msgid ""
"  -w, --width=COLS           assume screen width instead of current value\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -Z, --context              print any SELinux security context of each "
"file\n"
"  -1                         list one file per line\n"
msgstr ""
"  -w, --width=COLS           fixe la largeur de l'écran au lieu de la valeur "
"courante\n"
"  -x                         liste les entrées en ligne au lieu de colonne\n"
"  -X                         trie alphabétiquement par extension d'entrée\n"
"  -Z, --context              affiche tout contexte de sécurité SELinux de "
"chaque fichier\n"
"  -1                         liste un fichier par ligne\n"

#: src/ls.c:4690
#, fuzzy
msgid ""
"\n"
"Using color to distinguish file types is disabled both by default and\n"
"with --color=never.  With --color=auto, ls emits color codes only when\n"
"standard output is connected to a terminal.  The LS_COLORS environment\n"
"variable can change the settings.  Use the dircolors command to set it.\n"
msgstr ""
"\n"
"Par défaut, la couleur n'est pas utilisée pour distinguer les différents "
"types\n"
"de fichiers. Cela est équivalent à l'utilisation de l'option --"
"color=none.  \n"
"L'utilisation de l'option --color sans l'argument WHEN est équivalent à\n"
"l'utilisation de --colors=always.  Avec l'option --color=auto, les codes de\n"
"couleur sont transmis vers la sortie standard si celle-ci est reliée à un \n"
"terminal (tty). La variable d'environnement LS_COLORS peut influer sur les "
"couleurs\n"
"et peut être initialisé facilement par la commande dircolors.\n"

#: src/ls.c:4697
msgid ""
"\n"
"Exit status:\n"
" 0  if OK,\n"
" 1  if minor problems (e.g., cannot access subdirectory),\n"
" 2  if serious trouble (e.g., cannot access command-line argument).\n"
msgstr ""
"\n"
"status de fin :\n"
" 0  si OK,\n"
" 1  si problèmes mineurs (e.g., ne peut accéder le sous-répertoire),\n"
" 2  si erreur grave (e.g., ne peut accéder aux arguments de la ligne de "
"commande).\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:93 src/seq.c:39
msgid "Ulrich Drepper"
msgstr "Ulrich Drepper"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:94
msgid "Scott Miller"
msgstr "Scott Miller"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:95
msgid "David Madore"
msgstr "David Madore"

#: src/md5sum.c:153
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Print or check %s (%d-bit) checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Usage: %s [OPTION]... [FICHIER]...\n"
"Affiche ou vérifie les sommes de contrôle %s (%d-bits).\n"
"Sans FICHIER, ou quand FICHIER est -, lit l'entrée standard.\n"
"\n"

#: src/md5sum.c:163
msgid ""
"  -b, --binary            read in binary mode (default unless reading tty "
"stdin)\n"
msgstr ""
"  -b, --binary            lire en mode binaire (par défaut à moins de lire à "
"partir de tty stdin)\n"

#: src/md5sum.c:167
msgid "  -b, --binary            read in binary mode\n"
msgstr "  -b, --binary             écrire en binaire sur la console.\n"

#: src/md5sum.c:170
#, c-format
msgid "  -c, --check             read %s sums from the FILEs and check them\n"
msgstr ""
"  -c, --check              lire les sommes %s à partir des FICHIER et les "
"vérifier\n"

#: src/md5sum.c:174
msgid ""
"  -t, --text              read in text mode (default if reading tty stdin)\n"
msgstr ""
"  -t, --text               lire en mode texte (par défaut la lecture est "
"faite de tty stdin)\n"

#: src/md5sum.c:178
msgid "  -t, --text              read in text mode (default)\n"
msgstr "  -t, --text               lire en mode texte (par défaut)\n"

#: src/md5sum.c:181
msgid ""
"\n"
"The following three options are useful only when verifying checksums:\n"
"      --quiet             don't print OK for each successfully verified "
"file\n"
"      --status            don't output anything, status code shows success\n"
"  -w, --warn              warn about improperly formatted checksum lines\n"
"\n"
msgstr ""
"\n"
"Les trois options suivantes sont utiles seulement lors de la vérification\n"
"des sommes de contrôle:\n"
"      --quiet             n'affiche pas OK à chaque vérification correcte de "
"fichier\n"
"      --status            n'affiche rien, sauf le code status indiquant le "
"succès\n"
"  -w, --warn              avertit à propos des lignes de contrôle mal "
"formatées\n"
"\n"

#: src/md5sum.c:191
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating type (`*' for binary, ` ' for\n"
"text), and name for each FILE.\n"
msgstr ""
"\n"
"Les sommes sont calculées selon la description de %s.  Lors de la "
"vérification,\n"
"l'entrée devrait être formellement une sortie de ce programme.  Le mode par "
"défaut\n"
"est d'afficher la ligne avec la somme de contrôle, un caractère indiquant\n"
"le type (« * » pour binaire, « » pour texte) et un nom pour chaque FICHIER.\n"

#: src/md5sum.c:470
#, c-format
msgid "%s: too many checksum lines"
msgstr "%s: trop de lignes de somme de contrôle"

#: src/md5sum.c:492
#, c-format
msgid "%s: %<PRIuMAX>: improperly formatted %s checksum line"
msgstr "%s: %<PRIuMAX>: ligne de somme de contrôle %s mal formatée"

#: src/md5sum.c:515
#, c-format
msgid "%s: FAILED open or read\n"
msgstr "%s: ÉCHEC d'ouverture ou de lecture.\n"

#: src/md5sum.c:538
msgid "FAILED"
msgstr "ÉCHEC"

#: src/md5sum.c:540
msgid "OK"
msgstr "OK"

#: src/md5sum.c:564
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s: aucune ligne de somme de contrôle %s repérée."

#: src/md5sum.c:573
#, c-format
msgid "WARNING: %<PRIuMAX> of %<PRIuMAX> listed file could not be read"
msgid_plural "WARNING: %<PRIuMAX> of %<PRIuMAX> listed files could not be read"
msgstr[0] ""
"AVERTISSEMENT: %<PRIuMAX> de %<PRIuMAX> fichier listé n'a pu être lu."
msgstr[1] ""
"AVERTISSEMENT: %<PRIuMAX> de %<PRIuMAX> fichiers listés n'ont pu être lus."

#: src/md5sum.c:585
#, c-format
msgid "WARNING: %<PRIuMAX> of %<PRIuMAX> computed checksum did NOT match"
msgid_plural ""
"WARNING: %<PRIuMAX> of %<PRIuMAX> computed checksums did NOT match"
msgstr[0] ""
"AVERTISSEMENT: %<PRIuMAX> de %<PRIuMAX> somme de contrôle ne concorde pas."
msgstr[1] ""
"AVERTISSEMENT: %<PRIuMAX> de %<PRIuMAX> sommes de contrôle ne concordent pas."

#: src/md5sum.c:662
#, c-format
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr ""
"Les options --binary et --text sont sans effet lors de la\n"
"la vérification des sommes de contrôle."

#: src/md5sum.c:670
#, c-format
msgid "the --status option is meaningful only when verifying checksums"
msgstr ""
"L'option --status n'a de sens que si la vérification des sommes\n"
"de contrôle est demandée."

#: src/md5sum.c:677
#, c-format
msgid "the --warn option is meaningful only when verifying checksums"
msgstr ""
"L'option --warn n'a de sens que si la vérification des sommes\n"
"de contrôle est demandée."

#: src/md5sum.c:684
#, c-format
msgid "the --quiet option is meaningful only when verifying checksums"
msgstr ""
"L'option --quiet n'a de sens que lors de la vérification des sommes de "
"contrôle"

#: src/mkdir.c:57 src/rmdir.c:165
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "Usage: %s [OPTION]... RÉPERTOIRE...\n"

#: src/mkdir.c:58
msgid ""
"Create the DIRECTORY(ies), if they do not already exist.\n"
"\n"
msgstr ""
"Créer le(s) RÉPERTOIRE(s) si il(s) n'existe(nt) pas.\n"
"\n"

#: src/mkdir.c:65
msgid ""
"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"
"  -p, --parents     no error if existing, make parent directories as needed\n"
"  -v, --verbose     print a message for each created directory\n"
"  -Z, --context=CTX  set the SELinux security context of each created\n"
"                      directory to CTX\n"
msgstr ""
"  -m, --mode=MODE   établit l'accès fichier à MODE (comme avec chmod),\n"
"                    et non a=rwx - umask\n"
"  -p, --parents     pas d'erreur si existant, fait les répertoires parents "
"au besoin :\n"
"  -v, --verbose     affiche un message pour chaque répertoire créé\n"
"  -Z, --context=CTX  établit à CTX le contexte de sécurité SELinux de "
"chaque\n"
"                      répertoire créé\n"

#: src/mkdir.c:170
#, c-format
msgid "created directory %s"
msgstr "création du répertoire %s"

#: src/mkfifo.c:52 src/pathchk.c:97
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "Usage: %s [OPTION]... NOM...\n"

#: src/mkfifo.c:53
msgid ""
"Create named pipes (FIFOs) with the given NAMEs.\n"
"\n"
msgstr "Créer un relais nommé (named pipe FIFO) qui portera le NOM.\n"

#: src/mkfifo.c:60 src/mknod.c:62
msgid ""
"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n"
msgstr ""
"  -m, --mode=MODE   établit les bits d'accès fichier à MODE, non pas a=rw - "
"umask\n"

#: src/mkfifo.c:63
msgid ""
"  -Z, --context=CTX  set the SELinux security context of each NAME to CTX\n"
msgstr ""
"  -Z, --context=CTX  établit le contexte de sécurité SELinux de chaque NAME "
"à CTX\n"

#: src/mkfifo.c:123 src/mknod.c:129
#, c-format
msgid "invalid mode"
msgstr "mode invalide"

#: src/mkfifo.c:128 src/mknod.c:134
#, c-format
msgid "mode must specify only file permission bits"
msgstr "le mode doit seulement spécifier les bits de permission de fichier"

#: src/mknod.c:53
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "Usage: %s [OPTION]... NOM TYPE [MAJEUR MINEUR]\n"

#: src/mknod.c:55
msgid ""
"Create the special file NAME of the given TYPE.\n"
"\n"
msgstr ""
"Créer le fichier spécial avec le NOM et le TYPE donné.\n"
"\n"

#: src/mknod.c:65
msgid "  -Z, --context=CTX  set the SELinux security context of NAME to CTX\n"
msgstr ""
"  -Z, --context=CTX  établit le contexte de sécurité SELinux de NAME à CTX\n"

#: src/mknod.c:70
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"Les deux MAJEUR et MINEUR doivent être spécifiés quand le TYPE est b, c ou "
"u\n"
"et ils doivent être omis lorsque le TYPE est p. Si MAJEUR et MINEUR avec 0x "
"ou 0X,\n"
"est fourni, ils sont interprétés en hexadécimal; autrement, s'ils débutent "
"pas 0, ils\n"
"le sont en octal autrement en décimal. Le TYPE peut être:\n"

#: src/mknod.c:77
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      créer un fichier spécial de type blocage (avec tampon)\n"
"  c, u   créer un fichier spécial de type caractère (sans tampon) \n"
"  p      créer un relais de type « fifo »\n"

#: src/mknod.c:152
msgid "Special files require major and minor device numbers."
msgstr ""
"Les fichiers spéciaux requièrent les numéros majeur et mineur de "
"périphériques."

#: src/mknod.c:162
msgid "Fifos do not have major and minor device numbers."
msgstr "Les FIFOS n'ont pas de numéros mineur et majeur de périphérique."

#: src/mknod.c:178
#, c-format
msgid "block special files not supported"
msgstr "fichier spécial de bloc n'est pas supporté"

#: src/mknod.c:187
#, c-format
msgid "character special files not supported"
msgstr "fichier spécial de caractères n'est pas supporté"

#: src/mknod.c:203
#, c-format
msgid "invalid major device number %s"
msgstr "numéro majeur de périphérique invalide %s"

#: src/mknod.c:208
#, c-format
msgid "invalid minor device number %s"
msgstr "numéro mineur de périphérique invalide %s"

#: src/mknod.c:213
#, c-format
msgid "invalid device %s %s"
msgstr "périphérique invalide %s %s"

#: src/mknod.c:227
#, c-format
msgid "invalid device type %s"
msgstr "type de périphérique invalide %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/mktemp.c:37
msgid "Eric Blake"
msgstr ""

#: src/mktemp.c:69
#, c-format
msgid "Usage: %s [OPTION]... [TEMPLATE]\n"
msgstr "Usage : %s [OPTION]... [FICHIER]\n"

#: src/mktemp.c:70
#, fuzzy
msgid ""
"Create a temporary file or directory, safely, and print its name.\n"
"TEMPLATE must contain at least 3 consecutive `X's in last component.\n"
"If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n"
msgstr ""
"Créer un fichier ou répertoire temporaire, sûr, et affiche son nom.\n"
"si TEMPLATE n'est pas spécifié, employer tmp.XXXXXXXXXX.\n"

#: src/mktemp.c:76
msgid ""
"  -d, --directory     create a directory, not a file\n"
"  -u, --dry-run       do not create anything; merely print a name (unsafe)\n"
"  -q, --quiet         suppress diagnostics about file/dir-creation failure\n"
msgstr ""

#: src/mktemp.c:81
msgid ""
"      --suffix=SUFF   append SUFF to TEMPLATE.  SUFF must not contain "
"slash.\n"
"                        This option is implied if TEMPLATE does not end in "
"X.\n"
msgstr ""

#: src/mktemp.c:85
#, fuzzy
msgid ""
"      --tmpdir[=DIR]  interpret TEMPLATE relative to DIR.  If DIR is not\n"
"                        specified, use $TMPDIR if set, else /tmp.  With\n"
"                        this option, TEMPLATE must not be an absolute name.\n"
"                        Unlike with -t, TEMPLATE may contain slashes, but\n"
"                        mktemp creates only the final component.\n"
msgstr ""
"  --tmpdir[=DIR]   interprète TEMPLATE en relation avec DIR.  si DIR n'est\n"
"                     pas sépcifié, employer $TMPDIR si créé, sinon /tmp.\n"
"                     Avec cette option, TEMPLATE ne doit pas être un nom "
"absolu.\n"
"                     Au contraire d'avec -t, TEMPLATE peut contenir des "
"slashs, mais\n"
"                     même ici, mktemp ne crée seulement que le composant "
"final.\n"

#: src/mktemp.c:93
#, fuzzy
msgid ""
"  -p DIR              use DIR as a prefix; implies -t [deprecated]\n"
"  -t                  interpret TEMPLATE as a single file name component,\n"
"                        relative to a directory: $TMPDIR, if set; else the\n"
"                        directory specified via -p; else /tmp [deprecated]\n"
msgstr ""
"  -t               interprète TEMPLATE comme un seul composant de nom de "
"fichier,\n"
"                     lié à un répertoire : $TMPDIR, si crée ; sinon le\n"
"                     répertoire spécifié via -p ; sinon /tmp [caduc]\n"

#: src/mktemp.c:220
#, c-format
msgid "failed to redirect stderr to /dev/null"
msgstr "échec de redirection de l'erreur standard vers /dev/null"

#: src/mktemp.c:226
#, c-format
msgid "too many templates"
msgstr "trop de modèles"

#: src/mktemp.c:246
#, c-format
msgid "with --suffix, template %s must end in X"
msgstr ""

#: src/mktemp.c:271
#, fuzzy, c-format
msgid "invalid suffix %s, contains directory separator"
msgstr "modèle invalide, %s, contient des séparateurs de répertoires"

#: src/mktemp.c:276
#, c-format
msgid "too few X's in template %s"
msgstr "trop peu de X dans le modèle %s"

#: src/mktemp.c:289
#, c-format
msgid "invalid template, %s, contains directory separator"
msgstr "modèle invalide, %s, contient des séparateurs de répertoires"

#: src/mktemp.c:303
#, c-format
msgid "invalid template, %s; with --tmpdir, it may not be absolute"
msgstr "modèle invalide, %s ; avec --tmpdir, cela peut ne pas être parfait "

#: src/mktemp.c:323
#, c-format
msgid "failed to create directory via template %s"
msgstr "échec de création du répertoire à partir du modèle %s"

#: src/mktemp.c:333
#, c-format
msgid "failed to create file via template %s"
msgstr "échec de création du fichier à partir du modèle %s"

#: src/mv.c:290
msgid ""
"Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
"\n"
msgstr ""
"Renommer la SOURCE à la DESTINATION ou déplacer la SOURCE vers la "
"DESTINATION.\n"
"\n"

#: src/mv.c:297
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"  -i, --interactive            prompt before overwrite\n"
"  -n, --no-clobber             do not overwrite an existing file\n"
"If you specify more than one of -i, -f, -n, only the final one takes "
"effect.\n"
msgstr ""
"      --backup[=CONTRÔLE]      archive chaque fichier de destination "
"existant\n"
"  -b                           identique à --backup mais n'accepte pas "
"d'argument\n"
"  -f, --force                  ne demande pas de confirmation avant "
"d'écraser\n"
"  -i, --interactive            demande confirmation avant d'écraser\n"
"  -n, --no-clobber             n'écrase pas un fichier existant\n"
"si vous spécifiez plus d'un de -i, -f, -n, seulement le dernier prend "
"effet.\n"

#: src/mv.c:305
msgid ""
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --strip-trailing-slashes  enlève les « / » en suffixe de chacun\n"
"                                 des arguments SOURCE\n"
"  -S, --suffix=SUFFIXE         écrase le suffixe usuel d'archivage\n"

#: src/mv.c:310
msgid ""
"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
msgstr ""
"  -t, --target-directory=RÉPERTOIRE\n"
"                               déplacer tous les arguments SOURCE vers\n"
"                                 le RÉPERTORIE\n"
"  -T, --no-target-directory    traiter la CIBLE comme un fichier normal\n"
"  -u, --update                 déplacer seulement lorsque les fichiers "
"SOURCE sont\n"
"                                 plus récents que les fichiers de la cible "
"ou lorsque\n"
"                                 les fichiers de la cible sont manquants\n"
"  -v, --verbose                expliquer ce qui a été fait\n"

#: src/nice.c:72
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "Usage: %s [OPTION] [COMMANDE] [ARG]...\n"

#: src/nice.c:73
#, c-format
msgid ""
"Run COMMAND with an adjusted niceness, which affects process scheduling.\n"
"With no COMMAND, print the current niceness.  Nicenesses range from\n"
"%d (most favorable scheduling) to %d (least favorable).\n"
"\n"
"  -n, --adjustment=N   add integer N to the niceness (default 10)\n"
msgstr ""
"Exécuter la COMMANDE avec un niveau de priorité ajusté.\n"
"Sans aucune COMMANDE, afficher le niveau courant de priorité.  L'étendue des "
"niveaux va de\n"
"%d (priorité la plus favorable d'ordonnancement) à %d (la moins favorable).\n"
"\n"
"  -n, --adjustment=N  ajouter la valeur entière N à la valeur de la priorité "
"(par défaut 10)\n"

#: src/nice.c:157
#, c-format
msgid "invalid adjustment %s"
msgstr "ajustement invalide %s"

#: src/nice.c:166
#, c-format
msgid "a command must be given with an adjustment"
msgstr "Une commande doit être soumise avec un ajustement."

#: src/nice.c:173 src/nice.c:184
#, c-format
msgid "cannot get niceness"
msgstr "ne peut obtenir le niveau de priorité"

#: src/nice.c:190
#, c-format
msgid "cannot set niceness"
msgstr "ne peut initialiser le niveau de priorité"

#. This is a proper name. See the gettext manual, section Names.
#: src/nl.c:39
msgid "Scott Bartram"
msgstr "Scott Bartram"

#: src/nl.c:186
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Afficher chaque FICHIER sur la sortie standard, avec numéros de ligne.\n"
"Sans FICHIER, ou FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/nl.c:194
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=STYLE      utiliser STYLE pour numéroter les lignes\n"
"  -d, --section-delimiter=CC      utiliser CC pour séparer les pages\n"
"                                  logiques\n"
"  -f, --footer-numbering=STYLE    utiliser STYLE pour numéroter les lignes\n"
"                                  de bas de page\n"

#: src/nl.c:199
#, fuzzy
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --line-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=STYLE    utiliser STYLE pour numéroter les lignes\n"
"                                  d'en-tête\n"
"  -i, --page-increment=N          incrémenter de N de lignes à chaque ligne\n"
"  -l, --join-blank-lines=N        regrouper N de lignes vides\n"
"                                  en une seule ligne\n"
"  -n, --number-format=FORMAT      insérer un numéro de ligne selon FORMAT\n"
"  -p, --no-renumber               ne pas réinitialiser le nombre de lignes\n"
"                                  aux pages logiques\n"
"  -s, --number-separator=CHAÎNE   ajouter la CHAÎNE après (si possible)\n"
"                                  le numéro de ligne\n"

#: src/nl.c:207
msgid ""
"  -v, --starting-line-number=NUMBER  first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --starting-line-number=NUMBER  le numéro de la 1ère ligne sur chaque "
"page logique\n"
"  -w, --number-width=NOMBRE      utilise NOMBRE de colonnes pour nombre de "
"lignes\n"

#: src/nl.c:213
msgid ""
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
msgstr ""
"\n"
"Par défaut, -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn sont sélectionnées.\n"
"CC se compose de deux caractères délimiteurs pour séparer les pages "
"logiques\n"
"un deuxième caractère manquant implique que:\n"
"taper \\\\ pour  \\.  STYLE est une des options parmi:\n"
"\n"

#: src/nl.c:219
msgid ""
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pBRE      number only lines that contain a match for the basic regular\n"
"            expression, BRE\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"  a         numérote toutes les lignes\n"
"  t         numérote seulement les lignes non vides\n"
"  n         numérote n lignes\n"
"  pBRE      numérote seulement les lignes ayant une concordance avec "
"l'expression\n"
"              régulière de base, BRE\n"
"\n"
"FORMAT doit être choisi parmi :\n"
"\n"
"  ln   justifié à gauche, sans zéro en préfixe\n"
"  rn   justifié à droite, sans zéro en préfixe\n"
"  rz   justifié à droite, avec zéros en préfixe\n"
"\n"

#: src/nl.c:286
#, c-format
msgid "line number overflow"
msgstr "débordement du numéro de ligne"

#: src/nl.c:484
#, c-format
msgid "invalid header numbering style: %s"
msgstr "style de numérotation d'en-tête invalide: %s"

#: src/nl.c:492
#, c-format
msgid "invalid body numbering style: %s"
msgstr "style de numérotation de corps invalide: %s"

#: src/nl.c:500
#, c-format
msgid "invalid footer numbering style: %s"
msgstr "style de numérotation de pied de page invalide: %s"

#: src/nl.c:509
#, c-format
msgid "invalid starting line number: %s"
msgstr "numéro de ligne de départ invalide: %s"

#: src/nl.c:515
#, fuzzy, c-format
msgid "WARNING: --page-increment is deprecated; use --line-increment instead"
msgstr ""
"Attention : ne prend pas en compte --preserve-context ; ce noyau n'a pas "
"SELinux-enabled activé."

#: src/nl.c:522
#, c-format
msgid "invalid line number increment: %s"
msgstr "incrément du nombre de ligne invalide: %s"

#: src/nl.c:534
#, c-format
msgid "invalid number of blank lines: %s"
msgstr "nombre de lignes blanches invalide: %s"

#: src/nl.c:548
#, c-format
msgid "invalid line number field width: %s"
msgstr "largeur du champ de la numérotation de ligne invalide: %s"

#: src/nl.c:567
#, c-format
msgid "invalid line numbering format: %s"
msgstr "format de numérotation de ligne invalide: %s"

#: src/nohup.c:54
#, c-format
msgid ""
"Usage: %s COMMAND [ARG]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"   ou: %s OPTION\n"

#: src/nohup.c:60
msgid ""
"Run COMMAND, ignoring hangup signals.\n"
"\n"
msgstr ""
"Éxécuter la COMMANDe en ignorant les signaux hangup.\n"
"\n"

#: src/nohup.c:66
#, c-format
msgid ""
"\n"
"If standard input is a terminal, redirect it from /dev/null.\n"
"If standard output is a terminal, append output to `nohup.out' if possible,\n"
"`$HOME/nohup.out' otherwise.\n"
"If standard error is a terminal, redirect it to standard output.\n"
"To save output to FILE, use `%s COMMAND > FILE'.\n"
msgstr ""
"\n"
"Si l'entrée standard est un terminal, la redirige depuis /dev/null.\n"
"Si l'entrée standard est un terminal, empile la sortie sur `nohup.out' si "
"possible,\n"
"sur `$HOME/nohup.out' sinon.\n"
"Si fichier standard d'erreur est un terminal, la redirige sur la sortie "
"standard.\n"
"Pour enregistrer la sortie sur FILE, employez `%s COMMAND > FILE'.\n"

#: src/nohup.c:128
#, c-format
msgid "ignoring input"
msgstr "les entrées sont ignorées"

#: src/nohup.c:160 src/nohup.c:162
#, c-format
msgid "failed to open %s"
msgstr "échec d'ouverture de %s"

#: src/nohup.c:172
#, c-format
msgid "ignoring input and appending output to %s"
msgstr "les entrées sont ignorées et la sortie est ajoutée à %s"

#: src/nohup.c:173
#, c-format
msgid "appending output to %s"
msgstr "la sortie est ajoutée à %s"

#: src/nohup.c:190
#, c-format
msgid "failed to set the copy of stderr to close on exec"
msgstr "échec de copie sur stderr lors de l'exécution de la fermeture "

#: src/nohup.c:195
#, c-format
msgid "ignoring input and redirecting stderr to stdout"
msgstr "ignore l'entrée et redirige stderr sur stdout"

#: src/nohup.c:196
#, c-format
msgid "redirecting stderr to stdout"
msgstr "redirige stderr sur stdout"

#: src/nohup.c:200
#, c-format
msgid "failed to redirect standard error"
msgstr "échec de redirection vers l'erreur standard"

#. This is a proper name. See the gettext manual, section Names.
#: src/nproc.c:32
msgid "Giuseppe Scrivano"
msgstr ""

#: src/nproc.c:57 src/pwd.c:57 src/tty.c:65 src/uname.c:122 src/whoami.c:46
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "Usage: %s [OPTION]...\n"

#: src/nproc.c:58
msgid ""
"Print the number of processing units available to the current process,\n"
"which may be less than the number of online processors\n"
"\n"
msgstr ""

#: src/nproc.c:63
msgid ""
"     --all       print the number of installed processors\n"
"     --ignore=N  if possible, exclude N processing units\n"
msgstr ""

#: src/nproc.c:107
#, fuzzy, c-format
msgid "%s: invalid number to ignore"
msgstr "%s: nombre de lignes invalide."

#: src/od.c:308
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n"
"  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.]"
"[b]]\n"
msgstr ""
"Usage: %s [OPTION]... [FICHIER]...\n"
"   ou: %s [-abcdfilosx]... [FICHIER] [[+]DÉCALAGE[.][b]]\n"
"   ou: %s --traditional [OPTION]... [FICHIER] [[+]DÉCALAGE[.][b] [+]"
"[ÉTIQUETTE][.][b]]\n"

#: src/od.c:314
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"\n"
"Afficher le contenu du FICHIER selon une représentation non ambiguë\n"
"par un affichage des octets en octal par défaut sur la sortie standard.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/od.c:321
msgid "All arguments to long options are mandatory for short options.\n"
msgstr ""
"Tous les arguments obligatoires pour les options de formes longues\n"
"le sont aussi pour les options de formes courtes.\n"

#: src/od.c:324
msgid ""
"  -A, --address-radix=RADIX   decide how file offsets are printed\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=BASE    afficher les octets selon un adressage\n"
"                              relatif dans la BASE sélectionnée\n"
"  -j, --skip-bytes=N          escamoter les N premiers octets de chaque\n"
"                              fichier\n"

#: src/od.c:328
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -S, --strings[=BYTES]       output strings of at least BYTES graphic "
"chars\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w, --width[=BYTES]         output BYTES bytes per output line\n"
"      --traditional           accept arguments in traditional form\n"
msgstr ""
"  -N, --read-bytes=N          limiter la vidange à N octets lus à l'entrée\n"
"  -s, --strings[=N]           afficher les chaînes d'au moins N caractères "
"graphiques\n"
"  -t, --format=TYPE           sélectionner les formats de sortie\n"
"  -v, --output-duplicates     ne pas utiliser * pour marquer la\n"
"                              suppression de ligne\n"
"  -w, --width[=N]             afficher N octets par ligne de sortie\n"
"      --traditional           accepter les arguments selon la forme "
"traditionnelle\n"

#: src/od.c:338
msgid ""
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters, ignoring high-order bit\n"
"  -b   same as -t o1, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal 2-byte units\n"
msgstr ""
"\n"
"Les spécifications de format traditionnel peuvent être entremêlées;\n"
"ils s'accumulent :\n"
"  -a   identique à -t a,    sélectionne les caractères nommés, ignore le bit "
"de haut poids\n"
"  -b   identique à -t o1,   sélectionne les octets en octal\n"
"  -c   identique à -t c,    sélectionne les caractères ASCII ou\n"
"                              les échappements obliques inverses\n"
"  -d   identique à -t u2,   sélectionne les décimales non signées sur 2 "
"octets\n"

#: src/od.c:346
msgid ""
"  -f   same as -t fF, select floats\n"
"  -i   same as -t dI, select decimal ints\n"
"  -l   same as -t dL, select decimal longs\n"
"  -o   same as -t o2, select octal 2-byte units\n"
"  -s   same as -t d2, select decimal 2-byte units\n"
"  -x   same as -t x2, select hexadecimal 2-byte units\n"
msgstr ""
"  -f   identique à -t fF,   identifier en nombre flottant\n"
"  -i   identique à -t dI,   identifier en entier décimal\n"
"  -l   identique à -t dL,   identifier en décimal long\n"
"  -o   identique à -t o2,   identifier en octal les unités de 2 octets\n"
"  -s   identique à -t d2,   identifier en décimal les unités de 2 octets\n"
"  -x   identique à -t x2,   identifier en hexadécimal les unités de 2 "
"octets\n"

#: src/od.c:354
msgid ""
"\n"
"If first and second call formats both apply, the second format is assumed\n"
"if the last operand begins with + or (if there are 2 operands) a digit.\n"
"An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n"
"at first byte printed, incremented when dump is progressing.\n"
"For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n"
"suffixes may be . for octal and b for multiply by 512.\n"
msgstr ""
"\n"
"Si les formats du 1er et du second appel s'appliquent, le 2e format est "
"retenu\n"
"si le dernier opérande débute par + ou (si il y a 2 opérandes) un chiffre.\n"
"Un opérande de décalage signifie -j SAUT.  ÉTIQUETTE est la pseudo adresse\n"
"affichée dès le 1er octet, incrémentée lorsque le vidage mémoire "
"s'effectue.\n"
"Pour SAUT et ÉTIQUETTE, un préfixe 0x ou 0X indique de l'hexadécimal ;\n"
"les suffixes peuvent être . pour l'octal et b pour multiple de 512.\n"

#: src/od.c:363
msgid ""
"\n"
"TYPE is made up of one or more of these specifications:\n"
"\n"
"  a          named character, ignoring high-order bit\n"
"  c          ASCII character or backslash escape\n"
msgstr ""
"\n"
"TYPE est fait de une ou plus de ces specifications :\n"
"\n"
"  a          caractère nommé, ignore le bit de plus haut poids\n"
"  c          caractère ASCII  ou backslash inhibé\n"

#: src/od.c:370
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[N]       décimal signé, N octets par entier\n"
"  f[N]       point flottant, N octets par entier\n"
"  o[N]       octal, N octets par entier\n"
"  u[N]       décimal non signé N octets par entier\n"
"  x[N]       hexadécimal, N octets par entier\n"

#: src/od.c:377
msgid ""
"\n"
"SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"N est un nombre.  Le TYPE est soit d, o, u ou x, N peut être aussi C pour\n"
"sizeof(char), S pour sizeof(short), I pour sizeof(int) ou L pour\n"
"sizeof(long).  Si le TYPE est f, N peut aussi être F pour sizeof(float),\n"
"D pour sizeof(double) ou L pour sizeof(long double).\n"

#: src/od.c:384
msgid ""
"\n"
"RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
"BYTES is hexadecimal with 0x or 0X prefix, and may have a multiplier "
"suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Adding a z suffix to any type displays printable characters at the end of "
"each\n"
"output line.\n"
msgstr ""
"\n"
"BASE est d pour décimal, o pour octal, x pour hexadécimal ou n pour aucun.\n"
"OCTETS est hexadécimal préfixé par 0x ou 0X, et peut avoir un suffixe "
"multiplicateur :\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"L'ajout du suffixe « z » à l'un de ces types affiche des caractères\n"
"imprimables à la fin de chaque ligne de résultat.\n"

#: src/od.c:393
msgid ""
"Option --string without a number implies 3; option --width without a number\n"
"implies 32.  By default, od uses -A o -t oS -w16.\n"
msgstr ""
"--string sans nombre implique 3.  --width sans \n"
"nombre implique 32.  Par défaut, od utilise -A o -t oS -w16.\n"

#: src/od.c:635 src/od.c:754
#, c-format
msgid "invalid type string %s"
msgstr "type de chaîne %s invalide"

#: src/od.c:645
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"type de chaîne %s invalide;\n"
"ce système ne permet pas le type entier %lu-byte"

#: src/od.c:764
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"type de chaîne invalide %s;\n"
"ce système ne supporte pas le type en point flottant %lu-byte"

#: src/od.c:822
#, c-format
msgid "invalid character `%c' in type string %s"
msgstr "caractère « %c » est invalide dans le type de chaîne %s"

#: src/od.c:1048
#, c-format
msgid "cannot skip past end of combined input"
msgstr "Ne peut aller au delà de la fin combinée des fichiers."

#: src/od.c:1603
#, c-format
msgid "invalid output address radix `%c'; it must be one character from [doxn]"
msgstr ""
"La base numérique de sortie est invalide « %c »:\n"
"une seule des options doit être sélectionnée parmi les choix [doxn]."

#: src/od.c:1729
#, c-format
msgid "no type may be specified when dumping strings"
msgstr "Aucun type ne peut être spécifié lors de l'affichage brut des chaînes."

#: src/od.c:1804
msgid "compatibility mode supports at most one file"
msgstr "mode de compatibilité supporte au plus un fichier."

#: src/od.c:1825
#, c-format
msgid "skip-bytes + read-bytes is too large"
msgstr "octets escamotés + le nombre d'octets lus est trop grand"

#: src/od.c:1868
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "AVERTISSEMENT: largeur invalide %lu; utilise %d à la place."

#: src/operand2sig.c:78
#, c-format
msgid "%s: invalid signal"
msgstr "%s: signal invalide"

#: src/paste.c:218
#, c-format
msgid "standard input is closed"
msgstr "L'entrée standard est fermée."

#: src/paste.c:437
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Coller séquentiellement les lignes correspondantes de chaque\n"
"FICHIER, séparé par des tabulations, vers la sortie standard.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/paste.c:446
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=LISTE  utiliser les caractères de la LISTE au lieu\n"
"                           de tabulations\n"
"  -s, --serial            copier un fichier à la fois au lieu de\n"
"                           le faire en parallèle\n"

#: src/paste.c:507
#, c-format
msgid "delimiter list ends with an unescaped backslash: %s"
msgstr "la liste des délimiteurs finit avec un slash inversé non inhibé : %s"

#: src/pathchk.c:98
msgid ""
"Diagnose invalid or unportable file names.\n"
"\n"
"  -p                  check for most POSIX systems\n"
"  -P                  check for empty names and leading \"-\"\n"
"      --portability   check for all POSIX systems (equivalent to -p -P)\n"
msgstr ""
"Diagnostique un nom de fichier invalide ou non portable.\n"
"\n"
"  -p                  vérifier pour la plupart des systèmes POSIX\n"
"  -P                  vérifier pour les noms vides et les \"-\" de tête\n"
"      --portability   vérifier pour tous les systèmes POSIX (équivalent à -p "
"-P)\n"

#: src/pathchk.c:178
#, c-format
msgid "leading `-' in a component of file name %s"
msgstr "`-' de tête dans un composante du nom de fichier %s"

#: src/pathchk.c:204
#, c-format
msgid "nonportable character %s in file name %s"
msgstr "caractère non portable %s dans le nom du fichier %s"

#: src/pathchk.c:280
#, c-format
msgid "empty file name"
msgstr "nom de fichier vide"

#: src/pathchk.c:322
#, c-format
msgid "%s: unable to determine maximum file name length"
msgstr "%s: incapable de déterminer la longueur maximale d'un nom de fichier"

#: src/pathchk.c:333
#, c-format
msgid "limit %lu exceeded by length %lu of file name %s"
msgstr "la limite %lu est dépassée par la longueur %lu du nom de fichier %s"

#: src/pathchk.c:419
#, c-format
msgid "limit %lu exceeded by length %lu of file name component %s"
msgstr ""
"la limite %lu est dépassée par la longueur %lu du composant du nom de "
"fichier %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:36 src/uptime.c:45 src/users.c:35 src/who.c:44
msgid "Joseph Arceneaux"
msgstr "Joseph Arceneaux"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:38 src/uptime.c:47
msgid "Kaveh Ghazi"
msgstr "Kaveh Ghazi"

#. TRANSLATORS: Real name is unknown; at most 19 characters.
#: src/pinky.c:254
msgid "        ???"
msgstr "        ???"

#. TRANSLATORS: Idle time is unknown; at most 5 characters.
#: src/pinky.c:278
msgid "?????"
msgstr "?????"

#: src/pinky.c:327
#, c-format
msgid "Login name: "
msgstr "Nom du compte: "

#: src/pinky.c:330
#, c-format
msgid "In real life: "
msgstr "En réalité: "

#. TRANSLATORS: Real name is unknown; no hard limit.
#: src/pinky.c:334
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:354
#, c-format
msgid "Directory: "
msgstr "Répertoire"

#: src/pinky.c:356
#, c-format
msgid "Shell: "
msgstr "Shell: "

#: src/pinky.c:375
#, c-format
msgid "Project: "
msgstr "Projet: "

#: src/pinky.c:399
#, c-format
msgid "Plan:\n"
msgstr "Plan:\n"

#: src/pinky.c:418
msgid "Login"
msgstr "Login"

#: src/pinky.c:420
msgid "Name"
msgstr "Nom"

#: src/pinky.c:421
msgid " TTY"
msgstr " TTY"

#: src/pinky.c:423
msgid "Idle"
msgstr "Inactivité"

#: src/pinky.c:424
msgid "When"
msgstr "Quand"

#: src/pinky.c:427
msgid "Where"
msgstr "Où"

#: src/pinky.c:507
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "Usage: %s [OPTION]... [USAGER]...\n"

#: src/pinky.c:508
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l              afficher en format long\n"
"  -b              omettre le répertoire d'attache de l'usager\n"
"                  et son shell en format long\n"
"  -h              omettre le fichier de projet de l'usager en\n"
"                  format long\n"
"  -p              omettre le fichier de plan de l'usager en\n"
"                  format long\n"

#: src/pinky.c:516
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f              omettre la ligne de l'en-tête des colonnes\n"
"                  en format court\n"
"  -w              omettre le nom complet de l'usager en format court\n"
"  -i              omettre le nom complet de l'usager et le nom de l'hôte\n"
"                  en format court\n"
"  -q              omettre le nom complet de l'usager, le nom de l'hôte\n"
"                  et le temps d'inactivité en format court\n"

#: src/pinky.c:525
#, c-format
msgid ""
"\n"
"A lightweight `finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"Une version allégée du programme « finger »;  afficher les informations "
"relatives à un usager.\n"
"Le fichier utmp sera %s.\n"

#: src/pinky.c:609
#, c-format
msgid "no username specified; at least one must be specified when using -l"
msgstr ""
"aucun nom d'usager spécifié; au moins doit être spécifié lorsque -l est "
"utilisée"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:329
msgid "Pete TerMaat"
msgstr "Pete TerMaat"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:330
msgid "Roland Huebner"
msgstr "Roland Huebner"

#: src/pr.c:912
#, c-format
msgid "`--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "« --pages=PREMIÈRE_PAGE[:DERNIÈRE_PAGE] » argument manquant"

#: src/pr.c:914
#, c-format
msgid "invalid page range %s"
msgstr "plage de pages invalide %s"

#: src/pr.c:979
#, c-format
msgid "`-l PAGE_LENGTH' invalid number of lines: %s"
msgstr "« -l PAGE_LENGTH » nombre invalide de lignes: %s"

#: src/pr.c:1003
#, c-format
msgid "`-N NUMBER' invalid starting line number: %s"
msgstr "« -N NUMBER » nombre de début de ligne invalide: %s"

#: src/pr.c:1015
#, c-format
msgid "`-o MARGIN' invalid line offset: %s"
msgstr "« -o MARGIN » saut de ligne invalide: %s"

#: src/pr.c:1056
#, c-format
msgid "`-w PAGE_WIDTH' invalid number of characters: %s"
msgstr "« -w PAGE_WIDTH » nombre invalide de caractères: %s"

#: src/pr.c:1070
#, c-format
msgid "`-W PAGE_WIDTH' invalid number of characters: %s"
msgstr "« -W PAGE_WIDTH » nombre invalide de caractères: %s"

#: src/pr.c:1100
#, c-format
msgid "cannot specify number of columns when printing in parallel"
msgstr "Ne peut spécifier le nombre de colonnes lorsqu'on imprime en parallèle"

#: src/pr.c:1104
#, c-format
msgid "cannot specify both printing across and printing in parallel"
msgstr "impossible de spécifier un affichage à la fois croisé et en parallèle"

#: src/pr.c:1200
#, c-format
msgid "`-%c' extra characters or invalid number in the argument: %s"
msgstr "« -%c': caractères superflus ou nombre invalide dans l'argument: %s"

#: src/pr.c:1304
#, c-format
msgid "page width too narrow"
msgstr "La largeur de page est trop petite."

#: src/pr.c:2368
#, c-format
msgid "starting page number %<PRIuMAX> exceeds page count %<PRIuMAX>"
msgstr ""
"numéro %<PRIuMAX> de page de départ dépasse le compteur de page %<PRIuMAX>"

#: src/pr.c:2395
#, c-format
msgid "page number overflow"
msgstr "débordement du numéro de page"

#: src/pr.c:2400
#, c-format
msgid "Page %<PRIuMAX>"
msgstr "Page %<PRIuMAX>"

#: src/pr.c:2773
msgid ""
"Paginate or columnate FILE(s) for printing.\n"
"\n"
msgstr ""
"Paginer ou mettre en colonne les FICHIERS pour impression.\n"
"\n"

#: src/pr.c:2780
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page.\n"
msgstr ""
"  +PREMIÈRE_PAGE[:DERNIÈRE_PAGE], \n"
"      --pages=PREMIÈRE_PAGE[:DERNIÈRE_PAGE]\n"
"                       débuter [stopper] l'impression à la PREMIÈRE_PAGE\n"
"                       ou à la DERNIÈRE_PAGE\n"
"  -COLUMN\n"
"      --columns=COLONNES\n"
"                       produire une sortie en COLONNES et imprimer les\n"
"                       les colonnes vers le bas à moins que -a ne soit\n"
"                       utilisé.  Équilibrer le nombre de lignes de chaque\n"
"                       colonne sur chaque page.\n"

#: src/pr.c:2788
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across         imprimer les colonnes horizontalement au lieu de\n"
"                       verticalement, utilisé ensemble avec -COLUMN\n"
"  -c, --show-control-chars\n"
"                       utiliser une notation par chapeau (^G) et octale\n"
"                       avec barre oblique inverse\n"
"  -d, --double-space\n"
"                       produire une sortie avec double espacement\n"

#: src/pr.c:2796
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=FORMAT\n"
"                          utiliser le FORMAT pour l'en-tête de la date\n"
"  -e[CAR[LARGEUR]], --expand-tabs[=CAR[LARGEUR]]\n"
"                       faire l'expansion des CARactères (ou de tabulation)\n"
"                       selon la LARGEUR de tabulation (par défaut 8)\n"
"  -F, -f,\n"
"      --form-feed\n"
"                       utiliser des sauts de page au lieu des sauts de \n"
"                       lignes pour séparer les pages (3 lignes par en-tête\n"
"                       avec -f ou 5 lignes par en-tête et bas de page sans -"
"f) \n"

#: src/pr.c:2806
msgid ""
"  -h, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h, --header=ENTÊTE\n"
"                       utilise une ENTÊTE centrée au lieu du nom de fichier "
"dans\n"
"                       l'entête de page, \n"
"                        -h \"\" imprime une ligne blanche, ne pas utiliser -h"
"\"\"\n"
"  -i[CAR[LARGEUR]], --output-tabs[=CAR[LARGEUR]]\n"
"                       remplacer les blancs par des CARactères (ou TABs) "
"selon la tabulation LARGEUR (8 par défaut)\n"
"  -J, --join-lines  fait la fusion des lignes pleines, inhiber la \n"
"                       troncature des lignes -W, sans alignement des\n"
"                       colonnes, --sep-string[=CHAÎNE] établit les "
"séparateurs\n"

#: src/pr.c:2815
msgid ""
"  -l, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63)\n"
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -l, --length=LONGUEUR_DE_PAGE\n"
"                       positionne LONGUEUR_DE_PAGE à 66 lignes\n"
"                       (nombre de lignes de texte par défaut à 56, et avec -"
"F 63\n"
"  -m, --merge          imprime tous les fichiers en parallèle un par\n"
"                       colonne, tronque les lignes, mais joint les\n"
"                       lignes de pleine longueur avec -J\n"

#: src/pr.c:2822
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                       numéroter les lignes, par les chiffres DIGITS (5), "
"suivi de SEParateur (TAB)\n"
"                        par défaut le compteur débute avec la première ligne "
"du fichier d'entrée\n"
"  -N, --first-line-number=VALEUR\n"
"                       débute le compteur avec la VALEUR avec la 1ère ligne\n"
"                       de la 1ère page imprimée (voir +FIRST_PAGE)\n"

#: src/pr.c:2830
msgid ""
"  -o, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o, --indent=MARGE\n"
"                       décale chaque ligne avec MARGE (zéro) d'espaces,\n"
"                       n'affecte pas -w ou -W, MARGE est ajouté à "
"PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                       inhibe l'avertissement lorsqu'un fichier ne peut être "
"ouvert\n"

#: src/pr.c:2837
msgid ""
"  -s[CHAR],--separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -w\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[CAR], --separator[=CHAÎNE]\n"
"                       séparer les colonnes à l'aide d'un simple CARactère\n"
"                       par défaut le caractère de TABulation sans -w et 'no "
"char»\n"
"                       avec -w et -s[CAR] inhibe la troncation de ligne des "
"3 colonnes\n"
"                       options de 3 colonnes (-COLUMN|-a - COLUMN|-m) sauf "
"si -w est utilisé\n"

#: src/pr.c:2844
msgid ""
"  -SSTRING, --sep-string[=STRING]\n"
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
"  -t, --omit-header  omit page headers and trailers\n"
msgstr ""
"  -SSTRING, --sep-string[=STRING]\n"
"                       sépare les colonnes avec STRING,\n"
"                       sans -S : séparateur par défaut < TAB > avec -J et "
"< ESPACE >\n"
"                       autrement (identique à -S\" \"), sans effet sur les "
"options\n"
"                       de colonne\n"
"  -t, --omit-header  escamote l'en-tête et l'empied\n"

#: src/pr.c:2851
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                       inhibe l'en-tête et l'empied, élimine la pagination\n"
"                       par saut de page indiqués dans les fichiers d'entrée\n"
"  -v, --show-nonprinting\n"
"                       utilise la notation octale avec slash inversé\n"
"  -w, --width=LARGEUR_DE_PAGE\n"
"                       utilise LARGEUR_DE_PAGE (72) seulement pour un "
"affichage de\n"
"                       colonnes texte multiples, -s[char] inhibe (72)\n"

#: src/pr.c:2861
msgid ""
"  -W, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W, --page-width=LARGEUR_DE_PAGE\n"
"                       utilise toujours une LARGEUR_DE_PAGE de 72 "
"caractères,\n"
"                       tronque les lignes, sauf lorsque l'option -J est "
"activée,\n"
"                       sans interférence avec -S ou -s\n"

#: src/pr.c:2869
msgid ""
"\n"
"-t is implied if PAGE_LENGTH <= 10.  With no FILE, or when\n"
"FILE is -, read standard input.\n"
msgstr ""
"\n"
"-t est implicite si PAGE_LENGTH <= 10.  Sans FICHIER, ou quand\n"
"FICHIER est -, lit l'entrée standard.\n"

#: src/printenv.c:63
#, fuzzy, c-format
msgid ""
"Usage: %s [OPTION]... [VARIABLE]...\n"
"Print the values of the specified environment VARIABLE(s).\n"
"If no VARIABLE is specified, print name and value pairs for them all.\n"
"\n"
msgstr ""
"Usage : %s [VARIABLE]...\n"
"  ou :  %s OPTION\n"
"Affiche les valeurs de(s) VARIABLE(s) d'environnement spécifiées.\n"
"Si aucune VARIABLE n'est spécifiée, les affiche toutes avec nom et valeur.\n"
"\n"

#: src/printenv.c:70
#, fuzzy
msgid "  -0, --null     end each output line with 0 byte rather than newline\n"
msgstr ""
"  -z, --zero-terminated     terminer les lignes avec l'octet 0, \n"
"                            et non pas par un retour de chariot\n"

#: src/printf.c:79
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr ""
"AVERTISSEMENT: %s: caractère(s) suivant le caractère de constante ignoré(s)"

#: src/printf.c:89
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"   ou: %s OPTION\n"

#: src/printf.c:94
msgid ""
"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n"
"\n"
msgstr ""
"Affiche les ARGUMENTS selon le FORMAT, ou exécute selon OPTION :\n"
"\n"

#: src/printf.c:100
#, fuzzy
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
msgstr ""
"\n"
"Le FORMAT contrôle la sortie comme la fonction printf() en C.\n"
"Les séquences interprétées sont:\n"
"\n"
"  \\\"      guillemets\n"
"  \\0NNN   caractère ayant la valeur octale NNN (1 à 3 chiffres)\n"
"  \\\\      barre oblique inverse\n"

#: src/printf.c:118
#, fuzzy
msgid ""
"  \\NNN    byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
"  \\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n"
"  \\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n"
msgstr ""
"  \\xHH        caractère ayant la valeur hexadécimale HH (1 à 2 chiffres)\n"
"\n"
"  \\uHHHH      caractère Unicode (ISO/IEC 10646) ayant la valeur "
"hexadécimale HHHH (4 chiffres)\n"
"  \\UHHHHHHHH  caractère Unicode ayant la valeur hexadécimal HHHHHHHH (8 "
"chiffres)\n"

#: src/printf.c:124
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with `\\' escapes interpreted,\n"
"          except that octal escapes are of the form \\0 or \\0NNN\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""
"  %%      un simple %\n"
"  %b      ARGUMENT en tant que chaîne avec « \\ » d'échappement interprétés,\n"
"          sauf que l'échappement en octal est de la forme \\0 or \\0NNN\n"
"\n"
"ainsi que toutes les spécifications de format C se terminant par une des\n"
"options diouxXfeEgGcs, avec ARGUMENT converti d'abord au type approprié.\n"
"Les largeurs variables sont supportées.\n"

#: src/printf.c:149
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s: valeur numérique attendue."

#: src/printf.c:151
#, c-format
msgid "%s: value not completely converted"
msgstr "%s: valeur pas complètement convertie."

#: src/printf.c:248 src/printf.c:275
#, c-format
msgid "missing hexadecimal number in escape"
msgstr "Nombre hexadécimal manquant dans l'échappement."

#: src/printf.c:287
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "nom de caractère universel invalide \\%c%0*x"

#: src/printf.c:548
#, c-format
msgid "invalid field width: %s"
msgstr "largeur de champ invalide: %s"

#: src/printf.c:583
#, c-format
msgid "invalid precision: %s"
msgstr "précision invalide: %s"

#: src/printf.c:610
#, c-format
msgid "%.*s: invalid conversion specification"
msgstr "%.*s: spécification invalide de conversion"

#: src/printf.c:693
#, c-format
msgid "warning: ignoring excess arguments, starting with %s"
msgstr "AVERTISSEMENT:  arguments superflus ignorés, débutant avec %s"

#. TRANSLATORS: Please translate "F. Pinard" to "François Pinard"
#. if "ç" (c-with-cedilla) is available in the translation's character
#. set and encoding.
#. This is a proper name. See the gettext manual, section Names.
#: src/ptx.c:40
msgid "F. Pinard"
msgstr "F. Pinard"

#: src/ptx.c:421
#, c-format
msgid "%s (for regexp %s)"
msgstr "%s (pour regexp %s)"

#: src/ptx.c:1884
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Usage: %s [OPTION]... [ENTRÉE]...   (sans l'option -G)\n"
"   ou: %s -G [OPTION]... [ÉNTRÉE [SORTIE]]\n"

#: src/ptx.c:1888
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
"\n"
msgstr ""
"Produire un index permuté, incluant le contexte des mots des fichiers "
"d'entrée.\n"
"\n"

#: src/ptx.c:1895
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -G, --traditional              behave more like System V `ptx'\n"
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations\n"
msgstr ""
"  -A, --auto-reference           affiche les références générées "
"automatiquement\n"
"  -G, --traditional              se comporte plutôt comme en System V "
"« ptx »\n"
"  -F, --flag-truncation=CHAÎNE   utilise CHAÎNE pour indiquer la troncation\n"
"                                 de ligne\n"

#: src/ptx.c:1900
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=CHAÎNE        nom de la macro à utiliser au lieu de « xx "
"»\n"
"  -O, --format=roff              générer la sortie comme des directives "
"roff\n"
"  -R, --right-side-refs          placer les références à droite, sans "
"décompte -w\n"
"  -S, --sentence-regexp=REGEXP   pour la fin des lignes ou des phrases\n"
"  -T, --format=tex               générer la sortie comme des directives TeX\n"

#: src/ptx.c:1907
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=REGEXP       utiliser REGEXP pour établir la concordance "
"avec chaque mot\n"
"  -b, --break-file=FICHIER       utiliser les coupures de mots de ce "
"FICHIER\n"
"  -f, --ignore-case              ramener les minuscules en majuscules pour "
"le trie\n"
"  -g, --gap-size=N               espacer de N blancs les colonnes entre les "
"champs\n"
"  -i, --ignore-file=FICHIER      lire la liste des mots à ignorer de ce "
"FICHIER\n"
"  -o, --only-file=FICHIER        lire la liste des mots uniquement de ce "
"FICHIER\n"

#: src/ptx.c:1915
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references               donner la référence du 1er champ de chaque "
"ligne\n"
"  -t, --typeset-mode               - option non implanté -\n"
"  -w, --width=N                  largeur des colonnes, références exclues\n"

#: src/ptx.c:1922
msgid ""
"\n"
"With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
msgstr ""
"\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard. -F par "
"défaut.\n"

#: src/ptx.c:2016
#, c-format
msgid "invalid gap width: %s"
msgstr "largeur de saut invalide: %s"

#: src/pwd.c:58
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"Afficher le nom complet du fichier du répertoire courant.\n"
"\n"

#: src/pwd.c:62
msgid ""
"  -L, --logical   use PWD from environment, even if it contains symlinks\n"
"  -P, --physical  avoid all symlinks\n"
msgstr ""

#: src/pwd.c:167
#, c-format
msgid "failed to chdir to %s"
msgstr "échec de chdir vers %s"

#: src/pwd.c:171 src/pwd.c:278
#, c-format
msgid "failed to stat %s"
msgstr "échec d'évaluation par stat() de %s"

#: src/pwd.c:236
#, c-format
msgid "couldn't find directory entry in %s with matching i-node"
msgstr ""
"ne peut repérer l'entrée du répertoire dans %s concordant avec le inode"

#: src/pwd.c:363
#, c-format
msgid "ignoring non-option arguments"
msgstr "rejet des arguments qui ne sont pas des options reconnues"

#. This is a proper name. See the gettext manual, section Names.
#: src/readlink.c:33
msgid "Dmitry V. Levin"
msgstr "Dmitry V. Levin"

#: src/readlink.c:63
#, c-format
msgid "Usage: %s [OPTION]... FILE\n"
msgstr "Usage: %s [OPTION]... FICHIER\n"

#: src/readlink.c:64
#, fuzzy
msgid ""
"Print value of a symbolic link or canonical file name\n"
"\n"
msgstr ""
"Afficher la valeur d'un lien symbolique sur la sortie standard.\n"
"\n"

#: src/readlink.c:66
msgid ""
"  -f, --canonicalize            canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively;\n"
"                                all but the last component must exist\n"
"  -e, --canonicalize-existing   canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                all components must exist\n"
msgstr ""
"  -f, --canonicalize            canonise en suivant récursivement chaque "
"symlink de\n"
"                                  chaque composant du nom donné ;\n"
"                                  mais où au moins le dernier composant doit "
"exister\n"
"  -e, --canonicalize-existing   canonise en suivant récursivement tous les "
"symlink\n"
"                                  de chaque composant du nom donné,\n"
"                                  où tous les composants doivent exister\n"

#: src/readlink.c:74
msgid ""
"  -m, --canonicalize-missing    canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                without requirements on components "
"existence\n"
"  -n, --no-newline              do not output the trailing newline\n"
"  -q, --quiet,\n"
"  -s, --silent                  suppress most error messages\n"
"  -v, --verbose                 report error messages\n"
msgstr ""
"  -m, --canonicalize-missing    canonise en suivant récursivement chaque "
"symlink\n"
"                                  de chaque composant du nom donné,\n"
"                                  sans que l'existence des composants soit "
"obligatoire\n"
"  -n, --no-newline              ne génère pas une nouvelle ligne en fin\n"
"  -q, --quiet,\n"
"  -s, --silent                  supprime la plupart des messages d'erreur\n"
"  -v, --verbose                 affiche les messages d'erreur\n"

#: src/remove.c:311
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s: descendre dans un répertoire protégé en écriture %s?"

#: src/remove.c:312
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s: descendre dans le répertoire %s?"

#. TRANSLATORS: You may find it more convenient to
#. translate "%s: remove %s (write-protected) %s? "
#. instead.  It should avoid grammatical problems
#. with the output of file_type.
#: src/remove.c:328
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s: détruire un fichier protégé en écriture %s %s? "

#: src/remove.c:329
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s: détruire %s %s? "

#: src/remove.c:434
#, c-format
msgid "removed directory: %s\n"
msgstr "détruire le répertoire: %s\n"

#: src/remove.c:498
#, fuzzy, c-format
msgid "cannot remove directory: %s"
msgstr "ne peut détruire le répertoire %s"

#: src/remove.c:554
#, c-format
msgid "skipping %s, since it's on a different device"
msgstr "saute %s, du fait qu'il est sur un périphérique différent"

#: src/remove.c:574
#, fuzzy, c-format
msgid "traversal failed: %s"
msgstr "Échec de lecture"

#: src/remove.c:580
#, c-format
msgid ""
"unexpected failure: fts_info=%d: %s\n"
"please report to %s"
msgstr ""

#: src/rm.c:119
#, c-format
msgid "Try `%s ./%s' to remove the file %s.\n"
msgstr "Essayer `%s ./%s' pour enlever le fichier %s.\n"

#: src/rm.c:136 src/shred.c:158 src/stat.c:962 src/touch.c:215
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "Usage: %s [OPTION]... FICHIER...\n"

#: src/rm.c:137
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -f, --force           ignore nonexistent files, never prompt\n"
"  -i                    prompt before every removal\n"
msgstr ""
"Supprime (défait le lien) les FILE(s).\n"
"\n"
"  -f, --force           ignore les fichiers inexistants, n'interroge jamais\n"
"  -i                    interroge avant chaque suppression\n"

#: src/rm.c:143
msgid ""
"  -I                    prompt once before removing more than three files, "
"or\n"
"                          when removing recursively.  Less intrusive than -"
"i,\n"
"                          while still giving protection against most "
"mistakes\n"
"      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n"
"                          always (-i).  Without WHEN, prompt always\n"
msgstr ""
"  -I                    interroge une fois avant de supprimer plus de 3 "
"fichiers, ou\n"
"                          lors de suppresion recursive.  Moins intrusif que -"
"i,\n"
"                          tout en protégeant contre la plupart des erreurs\n"
"      --interactive[=WHEN]  interroge selon WHEN : never, once (-I), ou\n"
"                          always (-i).  sans WHEN, interroge tout le temps\n"

#: src/rm.c:150
msgid ""
"      --one-file-system  when removing a hierarchy recursively, skip any\n"
"                          directory that is on a file system different from\n"
"                          that of the corresponding command line argument\n"
msgstr ""
"      --one-file-system  quand une hiérarchie est supprimée récursivement, "
"saute\n"
"                          tout répertoire qui est sur un système de fichiers "
"différent de celui\n"
"                          de l'argument en question de la ligne de commande\n"

#: src/rm.c:155
msgid ""
"      --no-preserve-root  do not treat `/' specially\n"
"      --preserve-root   do not remove `/' (default)\n"
"  -r, -R, --recursive   remove directories and their contents recursively\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""
"      --no-preserve-root ne traite `/' de manière spéciale\n"
"      --preserve-root   n'escamote pas `/' (par défaut)\n"
"  -r, -R, --recursive   supprime les répertoires et leur contenu "
"récursivement\n"
"  -v, --verbose         explique ce qui va être fait\n"

#: src/rm.c:163
msgid ""
"\n"
"By default, rm does not remove directories.  Use the --recursive (-r or -R)\n"
"option to remove each listed directory, too, along with all of its "
"contents.\n"
msgstr ""
"\n"
"Par défaut, rm n'enlève pas les répertoires.  Utilisez l'option --recursive "
"(-r ou -R)\n"
"pour enlever les répertoires, ainsi que tout leur contenu.\n"

#: src/rm.c:168
#, c-format
msgid ""
"\n"
"To remove a file whose name starts with a `-', for example `-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""
"\n"
"Pour enlever un fichier dont le nom début par « - », par exemple « -foo »,\n"
"utiliser une de ces commandes:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"

#: src/rm.c:177
msgid ""
"\n"
"Note that if you use rm to remove a file, it is usually possible to recover\n"
"the contents of that file.  If you want more assurance that the contents "
"are\n"
"truly unrecoverable, consider using shred.\n"
msgstr ""
"\n"
"Noter que si vous utilisez « rm » pour détruire un fichier, il est "
"habituellement possible\n"
"de récupérer le contenu de ce fichier. Si vous désirez plus d'assurance à "
"l'effet\n"
"de ne pas pouvoir récupérer le contenu, considérez shred.\n"

#: src/rm.c:344
#, c-format
msgid "%s: remove all arguments recursively? "
msgstr "%s : supprimer tous les arguments récursivement ? "

#: src/rm.c:345
#, c-format
msgid "%s: remove all arguments? "
msgstr "%s : enlève tous les arguments ? "

#: src/rmdir.c:134 src/rmdir.c:233
#, c-format
msgid "removing directory, %s"
msgstr "destruction du répertoire %s"

#: src/rmdir.c:148
#, c-format
msgid "failed to remove directory %s"
msgstr "échec de destruction du répertoire %s"

#: src/rmdir.c:166
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore each failure that is solely because a directory\n"
"                    is non-empty\n"
msgstr ""
"Enlever les RÉPERTOIRES, s'ils sont vides.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore les échecs qui sont causées uniquement\n"
"                  du fait d'un répertoire pas vide\n"

#: src/rmdir.c:173
msgid ""
"  -p, --parents   remove DIRECTORY and its ancestors; e.g., `rmdir -p a/b/c' "
"is\n"
"                    similar to `rmdir a/b/c a/b a'\n"
"  -v, --verbose   output a diagnostic for every directory processed\n"
msgstr ""
"  -p, --parents   détruit le RÉPERTOIRE et ses parent; (ie. `rmdir -p a/b/c' "
"is\n"
"                  identique à `rmdir a/b/c a/b a'.)\n"
"  -v, --verbose   affiche un diagnostic pour chaque répertoire traité\n"

#: src/rmdir.c:242
#, c-format
msgid "failed to remove %s"
msgstr "échec de suppression de %s"

#: src/runcon.c:84
#, c-format
msgid ""
"Usage: %s CONTEXT COMMAND [args]\n"
"  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"
msgstr ""
"Usage : %s CONTEXT COMMAND [args]\n"
"  ou :  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"

#: src/runcon.c:88
msgid ""
"Run a program in a different security context.\n"
"With neither CONTEXT nor COMMAND, print the current security context.\n"
"\n"
"  CONTEXT            Complete security context\n"
"  -c, --compute      compute process transition context before modifying\n"
"  -t, --type=TYPE    type (for same role as parent)\n"
"  -u, --user=USER    user identity\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
"\n"
msgstr ""
"Lance un programme dans un contexte de sécurité différent.\n"
"Sans CONTEXT ni COMMAND, affiche le contexte de sécurité courant.\n"
"\n"
"  CONTEXT            Réalise le contexte de sécurité\n"
"  -c, --compute      calcul le contexte de transition de process avant de "
"modifier\n"
"  -t, --type=TYPE    type (pour le même role que le parent)\n"
"  -u, --user=USER    identité USER\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
"\n"

#: src/runcon.c:141
#, c-format
msgid "multiple roles"
msgstr "multiples roles"

#: src/runcon.c:146
#, c-format
msgid "multiple types"
msgstr "types multiples"

#: src/runcon.c:151
#, c-format
msgid "multiple users"
msgstr "multiples usagers"

#: src/runcon.c:156
#, c-format
msgid "multiple levelranges"
msgstr "multiples intervalles de niveaux"

#: src/runcon.c:174 src/runcon.c:210
#, c-format
msgid "failed to get current context"
msgstr "échec de récupération du contexte courant"

#: src/runcon.c:184
#, c-format
msgid "you must specify -c, -t, -u, -l, -r, or context"
msgstr "vous devez spécifier -c, -t, -u, -l, -r, ou le contexte"

#: src/runcon.c:192
#, c-format
msgid "no command specified"
msgstr "aucune commande spécifiée"

#: src/runcon.c:198
#, fuzzy, c-format
msgid "%s may be used only on a SELinux kernel"
msgstr "runcon ne peut être utilisé que sur un noyau SELinux"

#: src/runcon.c:224
#, c-format
msgid "failed to compute a new context"
msgstr "échec de création d'un nouveau contexte"

#: src/runcon.c:238
#, c-format
msgid "failed to set new user %s"
msgstr "échec de création de nouvel usager %s"

#: src/runcon.c:240
#, c-format
msgid "failed to set new type %s"
msgstr "échec à la création d'un nouveau type %s"

#: src/runcon.c:242
#, c-format
msgid "failed to set new range %s"
msgstr "échec à la création d'un nouvel intervalle %s"

#: src/runcon.c:244
#, c-format
msgid "failed to set new role %s"
msgstr "échec à la création d'un nouveau rôle %s"

#: src/runcon.c:252
#, c-format
msgid "unable to set security context %s"
msgstr "incapable d'établir le contexte de sécurité %s"

#: src/seq.c:70
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"Usage: %s [OPTION]... DERNIER\n"
"   ou: %s [OPTION]... PERMIER DERNIER\n"
"   ou: %s [OPTION]... PREMIER INCRÉMENT DERNIER\n"

#: src/seq.c:75
msgid ""
"Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
"\n"
"  -f, --format=FORMAT      use printf style floating-point FORMAT\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""
"Affiche les nombres de PREMIER jusqu'à DERNIER,\n"
"selon le PAS d'incrémentation.\n"
"\n"
"  -f, --format=FORMAT      utilise FORMAT de style virgule flottante printf\n"
"  -s, --separator=CHAÎNE   utilise CHAÎNE pour séparer les nombres (défaut : "
"\\n)\n"
"  -w, --equal-width        équilibre la largeur en remplissant de zéros de "
"tête\n"

#: src/seq.c:84
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n"
"omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
msgstr ""
"\n"
"Si PREMIER ou PAS est omis, il prend la valeur 1 par défaut.\n"
"La valeur PAS par défaut est 1 même lorsque DERNIER est plus petit que "
"PREMIER.\n"
"PREMIER, PAS et DERNIER sont interprétés en notation flottante.\n"
"PAS est habituellement positif si PREMIER est plus petit que DERNIER, et\n"
"PAS est habituellement négatif si PREMIER est plus grand que DERNIER.\n"

#: src/seq.c:92
msgid ""
"FORMAT must be suitable for printing one argument of type `double';\n"
"it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n"
"decimal numbers with maximum precision PREC, and to %g otherwise.\n"
msgstr ""
"FORMAT doit permettre d'afficher un argument de type `double' ;\n"
"il est par défaut à %.PRECf si PREMIER, PAS, et DERNIER sont tous décimaux "
"en\n"
"notation fixe avec une précision maximum PREC, et à %g sinon.\n"

#: src/seq.c:138
#, c-format
msgid "invalid floating point argument: %s"
msgstr "arguement en virgule flottante invalide: %s"

#: src/seq.c:195
#, c-format
msgid "format %s has no %% directive"
msgstr "format %s n'a pas de directive %%"

#: src/seq.c:212
#, c-format
msgid "format %s ends in %%"
msgstr "format %s finit en %%"

#: src/seq.c:215
#, c-format
msgid "format %s has unknown %%%c directive"
msgstr "format %s a une directive %%%c inconnue"

#: src/seq.c:219
#, c-format
msgid "format %s has too many %% directives"
msgstr "format %s a trop de directives %%"

#: src/seq.c:433
#, c-format
msgid "format string may not be specified when printing equal width strings"
msgstr ""
"format de chaîne ne peut pas être spécifié quand l'impression est égal à la "
"largeur des chaînes"

#: src/setuidgid.c:50
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... USER COMMAND [ARGUMENT]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"Usage : %s [SHORT-OPTION]... USER COMMAND [ARGUMENT]...\n"
"  ou :  %s LONG-OPTION\n"

#: src/setuidgid.c:56
msgid ""
"Drop any supplemental groups, assume the user-ID and group-ID of the "
"specified\n"
"USER (numeric ID or user name), and run COMMAND with any specified "
"ARGUMENTs.\n"
"Exit with status 111 if unable to assume the required user and group ID.\n"
"Otherwise, exit with the exit status of COMMAND.\n"
"This program is useful only when run by root (user ID zero).\n"
"\n"
msgstr ""
"Élimine tous groupes supplémentaires, admet le user-ID et le group-ID de\n"
"USER spécifique(ID numérique ou nom), et exécute COMMAND avec les ARGUMENTs "
"spécifiés.\n"
"Quitte avec le statut 111 si incapable d'admettre les UID et GID requis.\n"
"Autrement quitte avec le statut d'exécution de COMMAND.\n"
"Ce programme est utile lorsqu'exécuté par root (UID usager est zéro).\n"
"\n"

#: src/setuidgid.c:64
msgid ""
"  -g GID[,GID1...]  also set the primary group-ID to the numeric GID, and\n"
"                    (if specified) supplemental group IDs to GID1, ...\n"
msgstr ""
"  -g GID[,GID1...]  établit aussi le group-ID primaire à GID numérique, et\n"
"                    (si spécifié) d'autres group-IDs à GID1, ...\n"

#: src/setuidgid.c:163
#, c-format
msgid "unknown user-ID: %s"
msgstr "user-ID inconnu : %s"

#: src/setuidgid.c:174
#, c-format
msgid "to use user-ID %s you need to use -g too"
msgstr "pour employer user-ID %s vous devez employer aussi -g"

#: src/setuidgid.c:191
#, c-format
msgid "failed to set supplemental group(s)"
msgstr "ne peut établir de groupe(s) supplémentaire(s)"

#: src/setuidgid.c:201
#, c-format
msgid "cannot set group-ID to %lu"
msgstr "ne peut fixer le group-ID à %lu"

#: src/setuidgid.c:205
#, c-format
msgid "cannot set user-ID to %lu"
msgstr "ne peut fixer le user-ID à %lu"

#. This is a proper name. See the gettext manual, section Names.
#: src/shred.c:85
msgid "Colin Plumb"
msgstr "Colin Plumb"

#: src/shred.c:159
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
"\n"
msgstr ""
"Écraser un fichier de façon répétitive, afin de rendre difficile\n"
"toute récupération des données par du matériel même coûteux.\n"
"\n"

#: src/shred.c:167
#, fuzzy, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  overwrite N times instead of the default (%d)\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force    modifie les permissions pour permettre l'écriture si "
"nécessaire\n"
"  -n, --iterations=N  écrase N fois au lieu du nombre par défaut (%d)\n"
"      --random-source=FICHIER  obtient des octets aléatoires du FICHIER "
"(défaut /dev/urandom)\n"
"  -s, --size=N   découpe N octets (les suffixes K, M, G sont acceptés)\n"

#: src/shred.c:173
msgid ""
"  -u, --remove   truncate and remove file after overwriting\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
msgstr ""
"  -u, --remove        tronquer et détruire le fichier après l'avoir écraser\n"
"  -v, --verbose       afficher un indicateur de progrès\n"
"  -x, --exact         ne pas arrondir la taille des fichiers\n"
"                        jusqu'au prochain bloc complet;\n"
"                        comportement par défaut pour les fichiers non "
"réguliers\n"
"  -z, --zero          ajouter une réécriture finale avec des zéros\n"
"                        pour camoufler le déchiquetage du fichier\n"

#: src/shred.c:182
msgid ""
"\n"
"If FILE is -, shred standard output.\n"
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.  When operating on regular\n"
"files, most people use the --remove option.\n"
"\n"
msgstr ""
"\n"
"Si le FICHIER est -, déchiqueter à partir de l'entrée standard.\n"
"\n"
"Détruire le FICHIER si --remove (-u) est spécifié. Le défaut est de ne pas "
"détruire\n"
"les fichiers parce qu'il est commun d'opérer sur le fichier du périphérique "
"comme /dev/hda,\n"
"et habituellement ces fichiers ne sont pas détruits.  Sur des fichier "
"réguliers,\n"
"la plupart des gens utilise l'option --remove.\n"
"\n"

#: src/shred.c:192
msgid ""
"CAUTION: Note that shred relies on a very important assumption:\n"
"that the file system overwrites data in place.  This is the traditional\n"
"way to do things, but many modern file system designs do not satisfy this\n"
"assumption.  The following are examples of file systems on which shred is\n"
"not effective, or is not guaranteed to be effective in all file system "
"modes:\n"
"\n"
msgstr ""
"ATTENTION: noter que shred s'appuie sur l'importante supposition que \n"
"le système de fichiers écrasera les données en place. Cela est la manière\n"
"traditionnelle de faire les choses, mais plusieurs systèmes modernes\n"
"de fichiers ne se satisfont pas de cette supposition. Les exemples suivants "
"de systèmes\n"
"de fichiers sont ceux où le déchiquetage n'est pas effectif dans tous les "
"modes de systèmes de fichiers:\n"
"\n"

#: src/shred.c:200
msgid ""
"* log-structured or journaled file systems, such as those supplied with\n"
"AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\n"
"\n"
"* file systems that write redundant data and carry on even if some writes\n"
"fail, such as RAID-based file systems\n"
"\n"
"* file systems that make snapshots, such as Network Appliance's NFS server\n"
"\n"
msgstr ""
"* systèmes de fichiers à journalisation ou à structure de journalisation,\n"
" comme ceux fournis avec AIX et Solaris (et JFS, ReiserFS, XFS, Ext3, etc.)\n"
"\n"
"* systèmes de fichiers avec données redondantes et soutenant les écritures\n"
"  même lorsqu'il y a erreur d'écriture comme sur les systèmes de fichiers "
"RAID\n"
"\n"
"* systèmes de fichiers qui prennent des instantanés, comme\n"
"  le serveur NFS de Network Appliance\n"
"\n"

#: src/shred.c:210
msgid ""
"* file systems that cache in temporary locations, such as NFS\n"
"version 3 clients\n"
"\n"
"* compressed file systems\n"
"\n"
msgstr ""
"* systèmes de fichiers qui enregistre en cache temporairement, tel que\n"
"les clients NFS version 3\n"
"\n"
"* systèmes de fichiers compressés\n"
"\n"

#: src/shred.c:217
msgid ""
"In the case of ext3 file systems, the above disclaimer applies\n"
"(and shred is thus of limited effectiveness) only in data=journal mode,\n"
"which journals file data in addition to just metadata.  In both the\n"
"data=ordered (default) and data=writeback modes, shred works as usual.\n"
"Ext3 journaling modes can be changed by adding the data=something option\n"
"to the mount options for a particular file system in the /etc/fstab file,\n"
"as documented in the mount man page (man mount).\n"
"\n"
msgstr ""
"Dans le cas du système de fichier ext3, la déclaration ci-avant s'applique\n"
"(et shred a une efficacité limitée) seulement en mode data=journal,\n"
"dans lequel les journaux enregistrent les données en plus des métadonnées.\n"
"Dans les deux modes data=ordered (par défaut) et data=writeback, shred "
"travaille comme d'habitude.\n"
"Les modes de journalisation Ext3 peuvent être changés en ajoutant\n"
"data=something aux options de montage pour un système de fichiers "
"particulier\n"
"dans le fichier /etc/fstab, tel que documenté dans la page man de mount (man "
"mount).\n"
"\n"

#: src/shred.c:227
msgid ""
"In addition, file system backups and remote mirrors may contain copies\n"
"of the file that cannot be removed, and that will allow a shredded file\n"
"to be recovered later.\n"
msgstr ""
"En plus, l'archivage des système de fichiers et les miroirs à distance "
"peuvent\n"
"contenir des copies des fichiers qui ne peuvent être enlevés et qui "
"permettront\n"
"à un fichier mutilé d'être récupérés plus tard.\n"

#: src/shred.c:307
#, c-format
msgid "%s: fdatasync failed"
msgstr "%s : échec de fdatasync"

#: src/shred.c:318
#, c-format
msgid "%s: fsync failed"
msgstr "%s : échec de fsync"

#: src/shred.c:395
#, c-format
msgid "%s: cannot rewind"
msgstr "%s : ne peut rembobiner"

#: src/shred.c:414
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s : pass %lu/%lu (%s)..."

#: src/shred.c:464
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s: erreur d'écriture au décalage %s"

#: src/shred.c:482
#, c-format
msgid "%s: lseek failed"
msgstr "%s: échec de lseek"

#: src/shred.c:493
#, c-format
msgid "%s: file too large"
msgstr "%s: fichier trop gros"

#: src/shred.c:516
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s: passes %lu/%lu (%s)...%s"

#: src/shred.c:532
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s: passes %lu/%lu (%s)...%s/%s %d%%"

#: src/shred.c:779
#, c-format
msgid "%s: fstat failed"
msgstr "%s: échec de fstat"

#: src/shred.c:790
#, c-format
msgid "%s: invalid file type"
msgstr "%s: type de fichier invalide"

#: src/shred.c:809
#, c-format
msgid "%s: file has negative size"
msgstr "%s: le fichier a une taille négative."

#: src/shred.c:876
#, c-format
msgid "%s: error truncating"
msgstr "%s: erreur de troncation"

#: src/shred.c:892
#, c-format
msgid "%s: fcntl failed"
msgstr "%s: échec de fcntl"

#: src/shred.c:897
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s: ne peut déchiqueter "

#: src/shred.c:975
#, c-format
msgid "%s: removing"
msgstr "destruction de « %s »"

#: src/shred.c:999
#, c-format
msgid "%s: renamed to %s"
msgstr "%s: renommé à %s"

#: src/shred.c:1021
#, c-format
msgid "%s: failed to remove"
msgstr "%s: échec à enlever"

#: src/shred.c:1025
#, c-format
msgid "%s: removed"
msgstr "%s: détruit"

#: src/shred.c:1032 src/shred.c:1075
#, c-format
msgid "%s: failed to close"
msgstr "%s: échec de fermeture"

#: src/shred.c:1068
#, c-format
msgid "%s: failed to open for writing"
msgstr "%s: échec d'ouverture en écriture"

#: src/shred.c:1133
#, c-format
msgid "%s: invalid number of passes"
msgstr "%s: nombre de passes invalide"

#: src/shred.c:1142 src/shuf.c:329 src/sort.c:3450
#, c-format
msgid "multiple random sources specified"
msgstr "multiples sources aléatoires spécifiées"

#: src/shred.c:1156
#, c-format
msgid "%s: invalid file size"
msgstr "%s: longueur de fichier invalide"

#: src/shuf.c:47
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"  or:  %s -e [OPTION]... [ARG]...\n"
"  or:  %s -i LO-HI [OPTION]...\n"
msgstr ""
"Usage : %s [OPTION]... [FILE]\n"
"  ou :  %s -e [OPTION]... [ARG]...\n"
"  ou :  %s -i LO-HI [OPTION]...\n"

#: src/shuf.c:53
msgid ""
"Write a random permutation of the input lines to standard output.\n"
"\n"
msgstr ""
"Affiche une permutation aléatoire des lignes entrées sur la sortie "
"standard.\n"
"\n"

#: src/shuf.c:60
#, fuzzy
msgid ""
"  -e, --echo                treat each ARG as an input line\n"
"  -i, --input-range=LO-HI   treat each number LO through HI as an input "
"line\n"
"  -n, --head-count=COUNT    output at most COUNT lines\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr ""
"  -e, --echo                traite chaque ARG comme une ligne entrée\n"
"  -i, --input-range=LO-HI   traite chaque nombre de LO à HI comme une ligne "
"entrée\n"
"  -n, --head-count=COUNT    affiche au plus COUNT lignes\n"
"  -o, --output=FILE         écrit le résultat dans FILE au lieu de la sortie "
"standard\n"
"      --random-source=FILE  obtient aléatoirement des octets de FILE "
"(défaut /dev/urandom)\n"
"  -z, --zero-terminated     finit les lignes avec l'octet 0, et pas retour "
"chariot\n"

#: src/shuf.c:283
#, c-format
msgid "multiple -i options specified"
msgstr "multiples options -l spécifiées"

#: src/shuf.c:303
#, c-format
msgid "invalid input range %s"
msgstr "intervalle d'entrée invalide %s"

#: src/shuf.c:316
#, c-format
msgid "invalid line count %s"
msgstr "compteur ligne invalide %s"

#: src/shuf.c:323 src/sort.c:3444
#, c-format
msgid "multiple output files specified"
msgstr "options multiples fichiers de sortie spécifiées"

#: src/shuf.c:349
#, c-format
msgid "cannot combine -e and -i options"
msgstr "ne peut combiner les options -e et -i"

#: src/shuf.c:358
#, c-format
msgid "extra operand %s\n"
msgstr "opérande suplémentaire %s\n"

#: src/sleep.c:46
#, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be `s' for seconds (the default),\n"
"`m' for minutes, `h' for hours or `d' for days.  Unlike most "
"implementations\n"
"that require NUMBER be an integer, here NUMBER may be an arbitrary floating\n"
"point number.  Given two or more arguments, pause for the amount of time\n"
"specified by the sum of their values.\n"
"\n"
msgstr ""
"Usage : %s NOMBRE[SUFFIXE]...\n"
"   ou : %s OPTION\n"
"Effectue une pause de NOMBRE secondes. Le SUFFIXE peut être « s » pour des\n"
"secondes (par défaut), « m » pour minutes, « h » pour heures ou « d »\n"
"pour jours. Contrairement à la plupart des implantations qui requièrent un\n"
"nombre entier, ici NOMBRE peut être un nombre arbitraire en virgule "
"flottante.\n"
"Avec 2 ou plus arguments, la pause se fait selon la somme des valeurs.\n"
"\n"

#: src/sleep.c:137 src/timeout.c:260
#, c-format
msgid "invalid time interval %s"
msgstr "intervalle de temps invalide %s"

#: src/sleep.c:148 src/tail.c:1148
#, c-format
msgid "cannot read realtime clock"
msgstr "ne peut lire l'horloge en temps réel"

#: src/sort.c:323
msgid ""
"Write sorted concatenation of all FILE(s) to standard output.\n"
"\n"
msgstr ""
"Afficher la concaténation triée de tous les FICHIERS sur la sortie "
"standard.\n"
"\n"

#: src/sort.c:330
msgid ""
"Ordering options:\n"
"\n"
msgstr ""
"Options de tri:\n"
"\n"

#: src/sort.c:334
msgid ""
"  -b, --ignore-leading-blanks  ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks ignorer les blancs de tête\n"
"  -d, --dictionary-order      considérer seulement les blancs et les "
"caractères alphanumériques\n"
"  -f, --ignore-case           suivre les caractères minuscules et "
"majuscules\n"

#: src/sort.c:339
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < `JAN' < ... < `DEC'\n"
msgstr ""
"  -g, --general-numeric-sort  compare selon la valeur numérique générale\n"
"  -i, --ignore-nonprinting    considère seulement les caractères "
"affichables\n"
"  -M, --month-sort            compare (inconnu) < `JAN' < ... < `DEC'\n"

#: src/sort.c:344
msgid ""
"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n"
msgstr ""

#: src/sort.c:347
#, fuzzy
msgid ""
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -R, --random-sort           sort by random hash of keys\n"
"      --random-source=FILE    get random bytes from FILE\n"
"  -r, --reverse               reverse the result of comparisons\n"
msgstr ""
"  -n, --numeric-sort          compare selon une valeur numérique de type "
"chaîne\n"
"  -R, --random-sort           tri par clé de hachage aléatoire\n"
"      --random-source=FICHIER    obtient les octets aléatoires du FICHIER "
"(défaut /dev/urandom)\n"
"  -r, --reverse               inverse le résultat de comparaisons\n"

#: src/sort.c:353
#, fuzzy
msgid ""
"      --sort=WORD             sort according to WORD:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          natural sort of (version) numbers within text\n"
"\n"
msgstr ""
"      --sort=MOT             tri selon MOT :\n"
"                                general-numeric -g, month -M, numeric -n,\n"
"                                random -R, version -V\n"
"  -V, --version-sort          tri par version numérique\n"
"\n"

#: src/sort.c:360
msgid ""
"Other options:\n"
"\n"
msgstr ""
"Autres Options :\n"
"\n"

#: src/sort.c:364
msgid ""
"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
"                            for more use temp files\n"
msgstr ""
"      --batch-size=NMERGE   fusionne au plus NMERGE entrée à la fois;\n"
"                            pour plus, employer des fichiers temporaires\n"

#: src/sort.c:368
msgid ""
"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
"  -C, --check=quiet, --check=silent  like -c, but do not report first bad "
"line\n"
"      --compress-program=PROG  compress temporaries with PROG;\n"
"                              decompress them with PROG -d\n"
"      --files0-from=F       read input from the files specified by\n"
"                            NUL-terminated names in file F;\n"
"                            If F is - then read names from standard input\n"
msgstr ""
"  -c, --check, --check=diagnose-first  valide le tri de l'entrée ; ne trie "
"pas\n"
"  -C, --check=quiet, --check=silent  comme -c, mais n'affiche pas la 1ère "
"ligne erronée\n"
"      --compress-program=PROG  compresse les temporaires avec PROG;\n"
"                              les décompresse avec PROG -d\n"
"      --files0-from=F       lit l'entrée depuis les fichiers spécifiés par "
"des\n"
"                            noms NUL-terminated dans le fichier F\n"
"                            si F est - alors lit les noms depuis l'entrée "
"standard\n"

#: src/sort.c:377
msgid ""
"  -k, --key=POS1[,POS2]     start a key at POS1 (origin 1), end it at POS2\n"
"                            (default end of line)\n"
"  -m, --merge               merge already sorted files; do not sort\n"
msgstr ""
"  -k, --key=POS1[,POS2]     la clé démarre à POS1(origine 1), finit à POS2\n"
"                            (défault fin de ligne)\n"
"  -m, --merge               fusionne les fichiers déjà triés ; ne trie pas\n"

#: src/sort.c:382
msgid ""
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"  -o, --output=FICHIER      écrit le résultat dans FICHIER au lieu de la "
"sortie standard\n"
"  -s, --stable              stabilise le tri en inhibant last-resort, la "
"comparaison de dernier recours\n"
"  -S, --buffer-size=TAILLE  utilise TAILLE pour le tampon mémoire principal\n"

#: src/sort.c:387
#, fuzzy, c-format
msgid ""
"  -t, --field-separator=SEP  use SEP instead of non-blank to blank "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %"
"s;\n"
"                              multiple options specify multiple directories\n"
"  -u, --unique              with -c, check for strict ordering;\n"
"                              without -c, output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=SEP      utiliser le SÉParateur au lieu de non-blanc "
"pour les transitions d'espace\n"
"  -T, --temporary-directory=RÉP  utiliser le RÉPertoire pour les fichiers "
"temporaires, non pas $TMPDIR ou %s\n"
"                                   avec options multiples pour spécifier de "
"multiples répertoires\n"
"  -u, --unique                   avec -c: vérifier l'ordonnancement strict\n"
"                                 sans -c: afficher les premiers d'une passe "
"équivalente\n"

#: src/sort.c:394
msgid "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr ""
"  -z, --zero-terminated     terminer les lignes avec l'octet 0, \n"
"                            et non pas par un retour de chariot\n"

#: src/sort.c:399
msgid ""
"\n"
"POS is F[.C][OPTS], where F is the field number and C the character "
"position\n"
"in the field; both are origin 1.  If neither -t nor -b is in effect, "
"characters\n"
"in a field are counted from the beginning of the preceding whitespace.  OPTS "
"is\n"
"one or more single-letter ordering options, which override global ordering\n"
"options for that key.  If no key is given, use the entire line as the key.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"POS est F[.C][OPTS], où F est le numéro de champ et C la position du "
"caractère\n"
"dans le champ ;  chacun à origine 1. Si ni -t ni -b est actif, les "
"caractères d'un\n"
"champs sont comptés depuis le début de l'espace précédant. OPTS se compose "
"d'une\n"
"option de tri d'une ou plusieurs lettres simples, laquelle écrase\n"
"l'ordonnancement global pour cette clé. Si aucune clé n'est donnée,\n"
"la ligne entière est utilisée comme clé.\n"
"\n"
"TAILLE peut être suivi d'un des suffixes multiplicatifs suivants :\n"

#: src/sort.c:409
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% 1% de mémoire, b 1, k 1024 (par défaut), et ainsi de suite pour M, G, T, "
"P, E, Z, Y.\n"
"\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"
"*** AVERTISSEMENT ***\n"
"La localisation utilisée dans l'environnement affecte l'ordre du tri.\n"
"Utiliser LC_ALL=C pour obtenir un tri selon un ordre traditionnel qui "
"utilise la valeur\n"
"native des octets.\n"

#: src/sort.c:611
#, c-format
msgid "waiting for %s [-d]"
msgstr "en attente de %s [-d]"

#: src/sort.c:616
#, c-format
msgid "%s [-d] terminated abnormally"
msgstr "%s [-d] a terminé anormalement"

#: src/sort.c:787 src/tac.c:458
#, c-format
msgid "cannot create temporary file in %s"
msgstr "ne peut créer le fichier temporaire dans %s"

#: src/sort.c:824 src/sort.c:2548 src/sort.c:2828 src/sort.c:2831
#: src/sort.c:3641
msgid "open failed"
msgstr "Échec d'ouverture"

#: src/sort.c:844
msgid "fflush failed"
msgstr "échec de fflush"

#: src/sort.c:849 src/sort.c:3696
msgid "close failed"
msgstr "Échec de fermeture"

#: src/sort.c:858
#, c-format
msgid "dup2 failed"
msgstr "dup2 a échoué"

#: src/sort.c:967
#, c-format
msgid "couldn't execute %s"
msgstr "n'a pu exécuter %s"

#: src/sort.c:976
msgid "couldn't create temporary file"
msgstr "N'a pu créer le fichier temporaire"

#: src/sort.c:1016
#, c-format
msgid "couldn't create process for %s -d"
msgstr "n'a pu créer le process pour %s -d"

#: src/sort.c:1030
#, c-format
msgid "couldn't execute %s -d"
msgstr "n'a pu exécuter %s -d"

#: src/sort.c:1054
msgid "write failed"
msgstr "Echec d'écriture."

#: src/sort.c:1091
#, c-format
msgid "warning: cannot remove: %s"
msgstr "AVERTISSEMENT: ne peut enlever: %s"

#: src/sort.c:1177
#, c-format
msgid "invalid --%s argument %s"
msgstr "argument -- %s invalide %s"

#: src/sort.c:1180
#, c-format
msgid "minimum --%s argument is %s"
msgstr "l'argument minimum --%s est %s"

#: src/sort.c:1195
#, c-format
msgid "--%s argument %s too large"
msgstr "--%s argument %s'trop grand"

#: src/sort.c:1198
#, c-format
msgid "maximum --%s argument with current rlimit is %s"
msgstr "l'argument maximum --%s avec la rlimit actuelle est %s"

#: src/sort.c:1343
msgid "stat failed"
msgstr "Échec de stat()"

#: src/sort.c:1604
msgid "read failed"
msgstr "Échec de lecture"

#: src/sort.c:1694
#, c-format
msgid "both SI and IEC prefixes present on units"
msgstr ""

#: src/sort.c:2257
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: désordre: "

#: src/sort.c:2261
msgid "standard error"
msgstr "erreur standard"

#: src/sort.c:2983
#, c-format
msgid "%s: invalid field specification %s"
msgstr "%s: spécification invalide du champ %s"

#: src/sort.c:2994
#, c-format
msgid "options `-%s' are incompatible"
msgstr "les options `-%s' sont incompatibles"

#: src/sort.c:3063
#, c-format
msgid "%s: invalid count at start of %s"
msgstr "%s: compteur invalide au départ de %s"

#: src/sort.c:3323
msgid "invalid number after `-'"
msgstr "nombre invalide après « - »"

#: src/sort.c:3326 src/sort.c:3397 src/sort.c:3425
msgid "invalid number after `.'"
msgstr "nombre invalide après « . »"

#: src/sort.c:3329 src/sort.c:3430
msgid "stray character in field spec"
msgstr "caractère égaré dans le champ de spécification"

#: src/sort.c:3375
#, c-format
msgid "multiple compress programs specified"
msgstr "multiples programmes de compression spécifiés"

#: src/sort.c:3388
msgid "invalid number at field start"
msgstr "nombre invalide dans le champ de départ"

#: src/sort.c:3392 src/sort.c:3420
msgid "field number is zero"
msgstr "numéro de champ est zéro"

#: src/sort.c:3401
msgid "character offset is zero"
msgstr "adresse relative du caractère est zéro"

#: src/sort.c:3416
msgid "invalid number after `,'"
msgstr "nombre invalide après « , »"

#: src/sort.c:3555 src/wc.c:680
#, c-format
msgid "cannot read file names from %s"
msgstr "ne peut lire les noms de fichiers à partir de %s"

#: src/sort.c:3577
#, c-format
msgid "%s:%lu: invalid zero-length file name"
msgstr "%s:%lu : invalide, longueur zéro du nom de fichier"

#: src/sort.c:3583
#, c-format
msgid "no input from %s"
msgstr "pas d'entrée depuis %s"

#: src/sort.c:3666
#, c-format
msgid "extra operand %s not allowed with -%c"
msgstr "opérande suplémentaire « %s » non permise avec -%c"

#: src/split.c:103
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [PREFIX]]\n"
msgstr "Usage : %s [OPTION]... [ENTRÉE [PRÉFIXE]]\n"

#: src/split.c:107
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"size is 1000 lines, and default PREFIX is `x'.  With no INPUT, or when "
"INPUT\n"
"is -, read standard input.\n"
"\n"
msgstr ""
"Afficher sur la sortie des morceaux de l'ENTRÉE de taille fixe selon\n"
"PRÉFIXEaa, PRÉFIXEab, ...; par défaut la taille est de 1000 lignes et\n"
"le préfixe par défaut est « x ».\n"
"Sans ENTRÉE ou quand l'ENTRÉE est -, la lecture se fait sur l'entrée "
"standard.\n"
"\n"

#: src/split.c:116
#, c-format
msgid ""
"  -a, --suffix-length=N   use suffixes of length N (default %d)\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -d, --numeric-suffixes  use numeric suffixes instead of alphabetic\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
msgstr ""
"  -a, --suffix-length=N   utiliser les suffixes de longueur N (par défaut %"
"d)\n"
"  -b, --bytes=N           écrire N octets par fichier de sortie\n"
"  -C, --line-bytes=N      écrire au plus N octets par ligne\n"
"                          par fichier de sortie\n"
"  -d, --numeric-suffixes  utiliser des suffixess numériques au lieu "
"d'alphabétiques\n"
"  -l, --lines=N           écrire N lignes par fichier de sortie\n"

#: src/split.c:123
msgid ""
"      --verbose           print a diagnostic just before each\n"
"                            output file is opened\n"
msgstr ""
"      --verbose           affiche un diagnostic juste avant chaque\n"
"                            ouverture de fichier de sortie\n"

#: src/split.c:187
#, c-format
msgid "output file suffixes exhausted"
msgstr "les suffixes des fichiers de sortie sont épuisés"

#: src/split.c:205
#, c-format
msgid "creating file %s\n"
msgstr "création du fichier %s\n"

#: src/split.c:368
#, c-format
msgid "cannot split in more than one way"
msgstr "Ne peut segmenter plus d'une façon."

#: src/split.c:419
#, c-format
msgid "%s: invalid suffix length"
msgstr "%s: longueur de suffixe invalide"

#: src/split.c:433 src/split.c:457
#, c-format
msgid "%s: invalid number of bytes"
msgstr "%s: nombre d'octets invalide."

#: src/split.c:445
#, c-format
msgid "%s: invalid number of lines"
msgstr "%s: nombre de lignes invalide."

#: src/split.c:486
#, c-format
msgid "line count option -%s%c... is too large"
msgstr "l'option compteur de ligne -%s%c est trop grande"

#: src/split.c:517
#, c-format
msgid "invalid number of lines: 0"
msgstr "nombre invalide de lignes: 0"

#. This is a proper name. See the gettext manual, section Names.
#: src/stat.c:152
msgid "Michael Meskes"
msgstr "Michael Meskes"

#: src/stat.c:748
#, c-format
msgid "warning: unrecognized escape `\\%c'"
msgstr "AVERTISSEMENT: séquence d'échappement non reconnue `\\%c'"

#: src/stat.c:792
#, c-format
msgid "%s: invalid directive"
msgstr "%s : directive invalide"

#: src/stat.c:838
#, c-format
msgid "warning: backslash at end of format"
msgstr "AVERTISSEMENT: barre oblique inverse invalide à la fin du format"

#: src/stat.c:867
#, c-format
msgid "using %s to denote standard input does not work in file system mode"
msgstr ""

#: src/stat.c:874
#, c-format
msgid "cannot read file system information for %s"
msgstr "ne peut lire les informations du système de fichier pour %s"

#: src/stat.c:904
#, fuzzy, c-format
msgid "cannot stat standard input"
msgstr "fermeture de l'entrée standard"

#: src/stat.c:963
msgid ""
"Display file or file system status.\n"
"\n"
"  -L, --dereference     follow links\n"
"  -f, --file-system     display file system status instead of file status\n"
msgstr ""
"Afficher l'état d'un fichier ou d'un système de fichiers.\n"
"\n"
"  -L, --dereference     suivre les liens\n"
"  -f, --file-system     afficher l'état du système de fichiers au lieu de "
"l'état du fichier\n"

#: src/stat.c:969
msgid ""
"  -c  --format=FORMAT   use the specified FORMAT instead of the default;\n"
"                          output a newline after each use of FORMAT\n"
"      --printf=FORMAT   like --format, but interpret backslash escapes,\n"
"                          and do not output a mandatory trailing newline.\n"
"                          If you want a newline, include \\n in FORMAT.\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""
"  -c  --format=FORMAT   utiliser le FORMAT spécifié au lieu de celui par "
"défaut;\n"
"                          afficher un saut de ligne après l'utilisation du "
"FORMAT\n"
"      --printf=FORMAT   identique à --format mais interprète les séquences "
"d'échappements,\n"
"                          et ne fait pas l'affichage d'un saut de ligne.\n"
"                          Si vous désiréz un saut de ligne, inclure \\n dans "
"le FORMAT.\n"
"  -t, --terse           afficher l'information dans un format "
"compréhensible\n"

#: src/stat.c:980
msgid ""
"\n"
"The valid format sequences for files (without --file-system):\n"
"\n"
"  %a   Access rights in octal\n"
"  %A   Access rights in human readable form\n"
"  %b   Number of blocks allocated (see %B)\n"
"  %B   The size in bytes of each block reported by %b\n"
"  %C   SELinux security context string\n"
msgstr ""
"\n"
"Le format valide pour les séquences de fichiers (sans --file-system) :\n"
"\n"
"  %a   Droits d'accès en octal\n"
"  %A   Droits d'accès en format lisible par un humain\n"
"  %b   Nombre de blocs alloués (voir %B)\n"
"  %B   La taille en octets de chaque bloc rapportée par `%b'\n"
"  %C   La chaîne de contexte de sécurité SELinux\n"

#: src/stat.c:989
msgid ""
"  %d   Device number in decimal\n"
"  %D   Device number in hex\n"
"  %f   Raw mode in hex\n"
"  %F   File type\n"
"  %g   Group ID of owner\n"
"  %G   Group name of owner\n"
msgstr ""
"  %d   numéro de périphérique en décimal\n"
"  %D   numéro de périphéque en hexadécimal\n"
"  %f   mode brut en hexadécimal\n"
"  %F   type de fichier\n"
"  %g   identificateur de groupe du propriétaire\n"
"  %G   nom de groupe du propriétaire\n"

#: src/stat.c:997
msgid ""
"  %h   Number of hard links\n"
"  %i   Inode number\n"
"  %n   File name\n"
"  %N   Quoted file name with dereference if symbolic link\n"
"  %o   I/O block size\n"
"  %s   Total size, in bytes\n"
"  %t   Major device type in hex\n"
"  %T   Minor device type in hex\n"
msgstr ""
"  %h - nombre de liens directs (hard)\n"
"  %i - numéro d'inode\n"
"  %n - nom de fichier\n"
"  %N - nom de fichier en citation avec référence si avec lien symbolique\n"
"  %o - taille de bloc d'entrée/sortie\n"
"  %s - taille totale, en octets\n"
"  %t - type majeur de périphérique en hexadécimal\n"
"  %T - type mineur de périphérique en hexadécimal\n"

#: src/stat.c:1007
msgid ""
"  %u   User ID of owner\n"
"  %U   User name of owner\n"
"  %x   Time of last access\n"
"  %X   Time of last access as seconds since Epoch\n"
"  %y   Time of last modification\n"
"  %Y   Time of last modification as seconds since Epoch\n"
"  %z   Time of last change\n"
"  %Z   Time of last change as seconds since Epoch\n"
"\n"
msgstr ""
"  %u - identificateur du propriétaire\n"
"  %U - nom de l'usager du propriétaire\n"
"  %x - date du dernier accès\n"
"  %X - date du dernier accès en seconded depuis l'Époque\n"
"  %y - date de la dernière modification\n"
"  %Y - date de la dernière modification en secondes depuis l'Époque\n"
"  %z - date du dernier changement\n"
"  %Z - date du dernier changement en secondes depuis l'Époque\n"
"\n"

#: src/stat.c:1019
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   Free blocks available to non-superuser\n"
"  %b   Total data blocks in file system\n"
"  %c   Total file nodes in file system\n"
"  %d   Free file nodes in file system\n"
"  %f   Free blocks in file system\n"
"  %C   SELinux security context string\n"
msgstr ""
"Séquences valides de format pour les systèmes de fichiers :\n"
"\n"
"  %a   Blocs libres disponibles pour un non super-usager\n"
"  %b   Total des blocs de données dans le système de fichiers\n"
"  %c   Total des noeuds de fichiers dans le système de fichiers\n"
"  %d   Noeuds de fichiers libres dans le système de fichiers\n"
"  %f   Blocs libres dans le système de fichiers\n"
"  %C   Chaîne de contexte de sécurité SELinux\n"

#: src/stat.c:1029
msgid ""
"  %i   File System ID in hex\n"
"  %l   Maximum length of filenames\n"
"  %n   File name\n"
"  %s   Block size (for faster transfers)\n"
"  %S   Fundamental block size (for block counts)\n"
"  %t   Type in hex\n"
"  %T   Type in human readable form\n"
msgstr ""
"  %i   identificateur du sytème de fichiers en hexadécimal\n"
"  %l   longueur maximum des noms de fichiers\n"
"  %n   nom de fichier\n"
"  %s   taille optimale de bloc de transfert\n"
"  %S   taille fondamentale de bloc (pour le décompte de blocs)\n"
"  %t   afficher en hexadécimal\n"
"  %T   afficher en format lisible pour un humain\n"

#: src/stat.c:1095
#, c-format
msgid ""
"the --context (-Z) option is obsolete and will be removed\n"
"in a future release"
msgstr ""
"l'option --context (-Z) est obsolète et sera supprimée\n"
"dans une future version"

#: src/stdbuf.c:92
#, fuzzy, c-format
msgid "Usage: %s OPTION... COMMAND\n"
msgstr "Usage: %s [OPTION]...\n"

#: src/stdbuf.c:93
msgid ""
"Run COMMAND, with modified buffering operations for its standard streams.\n"
"\n"
msgstr ""

#: src/stdbuf.c:100
msgid ""
"  -i, --input=MODE   Adjust standard input stream buffering\n"
"  -o, --output=MODE  Adjust standard output stream buffering\n"
"  -e, --error=MODE   Adjust standard error stream buffering\n"
msgstr ""

#: src/stdbuf.c:107
msgid ""
"\n"
"If MODE is `L' the corresponding stream will be line buffered.\n"
"This option is invalid with standard input.\n"
msgstr ""

#: src/stdbuf.c:110
msgid ""
"\n"
"If MODE is `0' the corresponding stream will be unbuffered.\n"
msgstr ""

#: src/stdbuf.c:113
#, fuzzy
msgid ""
"\n"
"Otherwise MODE is a number which may be followed by one of the following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
"In this case the corresponding stream will be fully buffered with the "
"buffer\n"
"size set to MODE bytes.\n"
msgstr ""
"\n"
"TAILLE est un nombre qui peut être suivi par un de ces suffixes :\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024 et ainsi de suite pour G, T, P, "
"E, Z, Y.\n"

#: src/stdbuf.c:119
msgid ""
"\n"
"NOTE: If COMMAND adjusts the buffering of its standard streams (`tee' does\n"
"for e.g.) then that will override corresponding settings changed by "
"`stdbuf'.\n"
"Also some filters (like `dd' and `cat' etc.) don't use streams for I/O,\n"
"and are thus unaffected by `stdbuf' settings.\n"
msgstr ""

#: src/stdbuf.c:247 src/stdbuf.c:279
#, fuzzy, c-format
msgid "failed to update the environment with %s"
msgstr "échec de changement de contexte de sécurité de  %s à %s"

#: src/stdbuf.c:321
#, c-format
msgid "line buffering stdin is meaningless"
msgstr ""

#: src/stty.c:514
#, c-format
msgid ""
"Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n"
msgstr ""
"Usage : %s [-F PÉRIPHÉRIQUE] | --file=DEVICE] [SETTING]...\n"
"   ou : %s [-F PÉRIPHÉRIQUE | --file=PÉRIPHÉRIQUE] [-a|--all]\n"
"   ou : %s [-F PÉRIPHÉRIQUE | --file=PÉRIPHÉRIQUE] [-g|--save]\n"

#: src/stty.c:520
msgid ""
"Print or change terminal characteristics.\n"
"\n"
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""
"Afficher ou modifier les caractéristiques du terminal.\n"
"\n"
"  -a, --all       afficher toutes les caractéristiques courantes dans\n"
"                  un format humainement lisible\n"
"  -g, --save      afficher toutes les caractéristiques dans un format\n"
"                  lisible par « stty »\n"
"  -F, --file=PÉRIPHÉRIQUE\n"
"                  utiliser le périphérique spécifié au lieu de stdin\n"

#: src/stty.c:529
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"Un « - » optionnel avant SÉLECTION indique une négation.  Un * indique une\n"
"SÉLECTION non-POSIX.  Le système détermine les options applicables.\n"

#: src/stty.c:534
msgid ""
"\n"
"Special characters:\n"
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""
"\n"
"Caractères spéciaux:\n"
"* dsusp CAR     CAR émettra un signal d'arrêt de terminal une\n"
"                    fois le tampon d'entrée vidé\n"
"  eof CAR       CAR transmettra une fin de fichier\n"
"                    (pour stopper l'ingestion à l'entrée)\n"
"  eol CAR       CAR terminera la ligne\n"

#: src/stty.c:541
msgid ""
" * eol2 CHAR     alternate CHAR for ending the line\n"
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""
"* eol2 CAR      CAR servira de caractère alternatif de fin de ligne\n"
"  erase CAR     CAR servira de touche d'effacement sur le dernier\n"
"                    caractère entrée\n"
"  intr CAR      CAR transmettra un signal d'interruption\n"
"  kill CAR      CAR effacera la ligne courante\n"

#: src/stty.c:547
msgid ""
" * lnext CHAR    CHAR will enter the next character quoted\n"
"   quit CHAR     CHAR will send a quit signal\n"
" * rprnt CHAR    CHAR will redraw the current line\n"
"   start CHAR    CHAR will restart the output after stopping it\n"
msgstr ""
"* lnext CAR     CAR entrera le prochain caractère entre guillemets\n"
"  quit CAR      CAR transmettra un signal de fin\n"
"* rprnt CAR     CAR servira à ré-afficher la dernière ligne\n"
"  start CAR     CAR permettra la poursuite de l'affichage de\n"
"                    sortie après avoir été stoppé\n"

#: src/stty.c:553
msgid ""
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
" * swtch CHAR    CHAR will switch to a different shell layer\n"
" * werase CHAR   CHAR will erase the last word typed\n"
msgstr ""
"  stop CAR      CAR stoppera l'affichage de sortie\n"
"  susp CAR      CAR transmettra un signal d'arrêt de terminal\n"
"* swtch CAR     CAR permettra de passer à une couche différente de shell\n"
"* werase CAR    CAR effacera le dernier mot tapé\n"

#: src/stty.c:559
msgid ""
"\n"
"Special settings:\n"
"   N             set the input and output speeds to N bauds\n"
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""
"\n"
"Configurations spéciales :\n"
"   N             initialise les vitesses d'entrée et de sortie à N bauds\n"
"* cols N        indique au kernel que le terminal a N colonnes\n"
"* columns N     identique à cols N\n"

#: src/stty.c:566
msgid ""
"   ispeed N      set the input speed to N\n"
" * line N        use line discipline N\n"
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""
"  ispeed N      initialiser la vitesse d'entrée à N\n"
"* line N        utiliser le conditionnement propre de la ligne N\n"
"  min N         avec -icanon, initialiser à N le nombre de caractères\n"
"                nécessaires pour obtenir une lecture complète\n"
"  ospeed N      initialiser la vitesse de sortie à N\n"

#: src/stty.c:572
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""
"* rows N        indiquer au kernel que le terminal a N lignes\n"
"* size          afficher le nombre de lignes et de colonnes\n"
"                selon les paramètres du kernel\n"
"  speed         afficher la vitesse du terminal\n"
"  time N        avec -icanon, initialiser le délai\n"
"                d'inactivité de lecture à N dizièmes de seconde\n"

#: src/stty.c:578
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
" * [-]crtscts    enable RTS/CTS handshaking\n"
"   csN           set character size to N bits, N in [5..8]\n"
msgstr ""
"\n"
"Configurations de contrôle:\n"
"  [-]clocal     inhiber les signaux de contrôle du modem\n"
"  [-]cread      autoriser la réception sur l'entrée\n"
"* [-]crtscts    autoriser RTS/CTS handshaking\n"
"  csN           initialiser la taille des caractères à N bits,\n"
"                N variant entre [5..8]\n"

#: src/stty.c:586
msgid ""
"   [-]cstopb     use two stop bits per character (one with `-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (even with `-')\n"
msgstr ""
"  [-]cstopb     utiliser 2 bits d'arrêt par caractère (un avec « - »)\n"
"  [-]hup        transmettre un signal de raccrochement quand le\n"
"                dernier processus ferme le lien tty\n"
"  [-]hupcl      identique à [-]hup\n"
"  [-]parenb     génèrer le bit de parité pour la sortie et\n"
"                traiter l'entrée avec un bit de parité implicite\n"
"  [-]parodd     utiliser une parité impaire (paire avec « - »)\n"

#: src/stty.c:593
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
msgstr ""
"\n"
"Configurations d'entrée:\n"
"  [-]brkint     le « break » provoque un signal d'interruption\n"
"  [-]icrnl      traduire le retour de chariot en saut de ligne\n"
"  [-]ignbrk     ignorer le caractère break\n"
"  [-]igncr      ignorer le retour de chariot\n"

#: src/stty.c:601
msgid ""
"   [-]ignpar     ignore characters with parity errors\n"
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""
"  [-]ignpar     ignorer les caractères ayant des erreurs de parité\n"
"* [-]imaxbel    indiquer par un bip sonore et ne pas vider le tampon\n"
"                d'entrée lors de l'arrivée d'un caractère\n"
"  [-]inlcr      traduire le saut de ligne en retour de chariot\n"
"  [-]inpck      autoriser la vérification de la parité à l'entrée\n"
"  [-]istrip     mettre à zéro le bit du haut (8e) d'un caractère de "
"l'entrée\n"

#: src/stty.c:608
msgid " * [-]iutf8      assume input characters are UTF-8 encoded\n"
msgstr ""
" * [-]iutf8      assumer que les caractères d'entrées sont encodés en UTF-8\n"

#: src/stty.c:611
msgid ""
" * [-]iuclc      translate uppercase characters to lowercase\n"
" * [-]ixany      let any character restart output, not only start character\n"
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""
"* [-]iuclc      traduire les majuscles en minuscules\n"
"* [-]ixany      permettre à n'importe quel caractère de relancer "
"l'affichage\n"
"                sur la sortie, pas uniquement le caractère de redémarrage\n"
"  [-]ixoff      autoriser l'envoie d'un caractère d'arrêt/départ\n"
"  [-]ixon       autoriser le contrôle de flux XON/XOFF\n"
"  [-]parmrk     indiquer les erreur de parité par une séquence\n"
"                de caractères (255-0)\n"
"  [-]tandem     identique à [-]ixoff\n"

#: src/stty.c:619
msgid ""
"\n"
"Output settings:\n"
" * bsN           backspace delay style, N in [0..1]\n"
" * crN           carriage return delay style, N in [0..3]\n"
" * ffN           form feed delay style, N in [0..1]\n"
" * nlN           newline delay style, N in [0..1]\n"
msgstr ""
"\n"
"Configurations de sortie:\n"
"* bsN           style du délai de retour arrière, N parmi [0..1]\n"
"* crN           style du délai du retour de chariot, N parmi [0..3]\n"
"* ffN           style du délai du saut de page, N parmi [0..1]\n"
"* nlN           style du délai du saut de ligne, N parmi [0..1]\n"

#: src/stty.c:627
msgid ""
" * [-]ocrnl      translate carriage return to newline\n"
" * [-]ofdel      use delete characters for fill instead of null characters\n"
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
" * [-]olcuc      translate lowercase characters to uppercase\n"
" * [-]onlcr      translate newline to carriage return-newline\n"
" * [-]onlret     newline performs a carriage return\n"
msgstr ""
"* [-]ocrnl      traduire un retour de chariot par un saut de ligne\n"
"* [-]ofdel      utiliser des caractères d'effacement comme caractère\n"
"                de remplissage au lieu de caractères nuls\n"
"* [-]ofill      utiliser le remplissage de caractères au lieu du délai\n"
"                par minuterie\n"
"* [-]olcuc      traduire les minuscules en majuscules\n"
"* [-]onlcr      traduire le saut de ligne en retour de chariot-saut de "
"ligne\n"
"* [-]onlret     le saut de ligne provoque un retour de chariot\n"

#: src/stty.c:635
msgid ""
" * [-]onocr      do not print carriage returns in the first column\n"
"   [-]opost      postprocess output\n"
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
" * vtN           vertical tab delay style, N in [0..1]\n"
msgstr ""
"* [-]onocr      ne pas afficher un retour de chariot en première colonne\n"
"  [-]opost      exécuter un post-traitement de sortie\n"
"* tabN          style du délai de tabulation horizontale, N parmi [0..3]\n"
"* tabs          identique à tab0\n"
"* -tabs         identique à tab3\n"
"* vtN           style du délai de tabulation verticale, N parmi [0..1]\n"

#: src/stty.c:643
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""
"\n"
"Configurations locales:\n"
"  [-]crterase   faire l'écho du caractère « erase » selon la séquence\n"
"                retour arrière-espace-retour arrière\n"
"* crtkill       annuler les ligne respectant la configuration\n"
"                « echoprt » et « echoe »\n"
"* -crtkill      annuler les lignes respectant la configuration\n"
"                « echoctl » et « echok »\n"

#: src/stty.c:650
msgid ""
" * [-]ctlecho    echo control characters in hat notation (`^c')\n"
"   [-]echo       echo input characters\n"
" * [-]echoctl    same as [-]ctlecho\n"
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""
"* [-]ctlecho    faire l'écho des caractères de contrôle par une notation\n"
"                en chapeau (« ^c »)\n"
"  [-]echo       faire l'écho des caractères à l'entrée\n"
"* [-]echoctl    identique à [-]ctlecho\n"
"  [-]echoe      identique à [-]crterase\n"
"  [-]echok      faire l'écho d'un saut de ligne après un caractère "
"d'annulation\n"

#: src/stty.c:657
msgid ""
" * [-]echoke     same as [-]crtkill\n"
"   [-]echonl     echo newline even if not echoing other characters\n"
" * [-]echoprt    echo erased characters backward, between `\\' and '/'\n"
"   [-]icanon     enable erase, kill, werase, and rprnt special characters\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""
"* [-]echoke     identique à [-]crtkill\n"
"  [-]echonl     faire l'écho d'un saut de ligne même s'il n'y pas\n"
"                d'écho des autres caractères\n"
"* [-]echoprt    faire l'écho des caractères d'effacement par retour "
"arrière,\n"
"                entre « \\ » et « / »\n"
"  [-]icanon     autoriser les caractères spéciaux\n"
"                « erase », « kill », « werase », et « rprnt »\n"
"  [-]iexten     autoriser les caractères spéciaux non-POSIX\n"

#: src/stty.c:664
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
" * [-]prterase   same as [-]echoprt\n"
" * [-]tostop     stop background jobs that try to write to the terminal\n"
" * [-]xcase      with icanon, escape with `\\' for uppercase characters\n"
msgstr ""
"  [-]isig       autoriser les caractères spéciaux\n"
"                « interrupt », « quit », et « suspend »\n"
"  [-]noflsh     inhiber la vidange après réception des caractères\n"
"                « interrupt » et « quit »\n"
"* [-]prterase   identique à [-]echoprt\n"
"* [-]tostop     stopper les tâches d'arrière plan qui essaient d'écrire\n"
"                sur le terminal\n"
"* [-]xcase      avec « icanon », faire l'échappement avec « \\ »\n"
"                pour les majuscules\n"

#: src/stty.c:671
msgid ""
"\n"
"Combination settings:\n"
" * [-]LCASE      same as [-]lcase\n"
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""
"\n"
"Configuration par combinaison:\n"
"* [-]LCASE      identique à [-]lcase\n"
"  cbreak        identique à -icanon\n"
"  -cbreak       identique à icanon\n"

#: src/stty.c:678
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
"   crt           same as echoe echoctl echoke\n"
msgstr ""
"  cooked        identique à brkint ignpar istrip icrnl ixon opost isig\n"
"                icanon, eof et eol selon leur valeur par défaut\n"
"  -cooked       identique à raw\n"
"  crt           identique à echoe echoctl echoke\n"

#: src/stty.c:684
msgid ""
"   dec           same as echoe echoctl echoke -ixany intr ^c erase 0177\n"
"                 kill ^u\n"
" * [-]decctlq    same as [-]ixany\n"
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
msgstr ""
"  dec           identique à echoe echoctl echoke -ixany intr ^c erase 0177\n"
"                kill ^u\n"
"* [-]decctlq    identique à [-]ixany\n"
"  ek            réinitialiser les caractères erase et kill à leur valeur\n"
"                par défaut\n"
"  evenp         identique à parenb -parodd cs7\n"

#: src/stty.c:691
msgid ""
"   -evenp        same as -parenb cs8\n"
" * [-]lcase      same as xcase iuclc olcuc\n"
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
"   nl            same as -icrnl -onlcr\n"
"   -nl           same as icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"
msgstr ""
"  -evenp        identique à -parenb cs8\n"
"* [-]lcase      identique à xcase iuclc olcuc\n"
"  litout        identique à -parenb -istrip -opost cs8\n"
"  -litout       identique à parenb istrip opost cs7\n"
"  nl            identique à -icrnl -onlcr\n"
"  -nl           identique à icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"

#: src/stty.c:699
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"  oddp          identique à parenb parodd cs7\n"
"  -oddp         identique à -parenb cs8\n"
"  [-]parity     identique à [-]evenp\n"
"  pass8         identique à -parenb -istrip cs8\n"
"  -pass8        identique à parenb istrip cs7\n"

#: src/stty.c:706
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ixany\n"
"                 -imaxbel -opost -isig -icanon -xcase min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""
"  raw           identique à -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ixany\n"
"                -imaxbel -opost -isig -icanon -xcase min 1 fois 0\n"
"  -raw          identique à cooked\n"

#: src/stty.c:712
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl -iutf8\n"
"                 -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
"                 -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
"                 isig icanon iexten echo echoe echok -echonl -noflsh\n"
"                 -xcase -tostop -echoprt echoctl echoke, all special\n"
"                 characters to their default values\n"
msgstr ""
"   sane          identique à cread -ignbrk brkint -inlcr -igncr icrnl -"
"iutf8\n"
"                  -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
"                  -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
"                  isig icanon iexten echo echoe echok -echonl -noflsh\n"
"                  -xcase -tostop -echoprt echoctl echoke, tous les "
"caractères\n"
"                  spéciaux avec leur valeur par défaut.\n"

#: src/stty.c:720
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"Prendre en charge la ligne « tty » reliée à l'entrée standard.  Sans "
"argument,\n"
"afficher la vitesse, le conditionnement de ligne et les modifications "
"appliquées\n"
"par 'stty sane'.  Dans les configurations,\n"
"CARactère est pris littéralement, ou codé comme ^c, 0x37, 0177 ou 127;\n"
"les valeurs spéciales comme ^- ou indéfinies sont utilisées pour inhiber\n"
"les caractères spéciaux.\n"

#: src/stty.c:792
#, c-format
msgid "only one device may be specified"
msgstr "un seul périphérique peut être spécifié"

#: src/stty.c:822
#, c-format
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr ""
"les options pour le mode bavard et les styles de sortie de stty-readable\n"
"sont mutuellement exclusives"

#: src/stty.c:828
#, c-format
msgid "when specifying an output style, modes may not be set"
msgstr ""
"Lors de la spécification d'un style de sortie, \n"
"les mode peuvent ne pas être initialisés."

#: src/stty.c:843
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s: n'a pu réinitialiser en mode non par bloc"

#: src/stty.c:888 src/stty.c:998
#, c-format
msgid "invalid argument %s"
msgstr "argument invalide %s"

#: src/stty.c:899 src/stty.c:916 src/stty.c:928 src/stty.c:941 src/stty.c:953
#: src/stty.c:973
#, c-format
msgid "missing argument to %s"
msgstr "argument manquant pour %s"

#: src/stty.c:979
#, c-format
msgid "invalid line discipline %s"
msgstr "discipline de ligne invalide %s"

#: src/stty.c:1049
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s: incapable d'exécuter toutes les opérations demandées."

#: src/stty.c:1395
#, c-format
msgid "%s: no size information for this device"
msgstr "%s: aucune information sur la taille pour ce périphérique."

#: src/stty.c:1909
#, c-format
msgid "invalid integer argument %s"
msgstr "argument numérique invalide %s"

#: src/su.c:226
msgid "Password:"
msgstr "Mot de passe:"

#: src/su.c:229
#, c-format
msgid "getpass: cannot open /dev/tty"
msgstr "getpass(): ne peut ouvrir /dev/tty"

#: src/su.c:287
#, c-format
msgid "cannot set groups"
msgstr "ne peut initialiser les groupes"

#: src/su.c:291
#, c-format
msgid "cannot set group id"
msgstr "ne peut initialiser l'identificateur de groupe"

#: src/su.c:293
#, c-format
msgid "cannot set user id"
msgstr "ne peut initialiser l'identificateur de l'usager"

#: src/su.c:369
#, c-format
msgid "Usage: %s [OPTION]... [-] [USER [ARG]...]\n"
msgstr "Usage: %s [OPTION]... [-] [USAGER [ARG]...]\n"

#: src/su.c:370
msgid ""
"Change the effective user id and group id to that of USER.\n"
"\n"
"  -, -l, --login               make the shell a login shell\n"
"  -c, --command=COMMAND        pass a single COMMAND to the shell with -c\n"
"  -f, --fast                   pass -f to the shell (for csh or tcsh)\n"
"  -m, --preserve-environment   do not reset environment variables\n"
"  -p                           same as -m\n"
"  -s, --shell=SHELL            run SHELL if /etc/shells allows it\n"
msgstr ""
"Établit l'identificateur effectif de l'usager et de groupe à USER\n"
"\n"
"  -, -l, --login               établit ce shell comme celui de la session de "
"travail\n"
"  -c, --command=COMMANDE       passe une seule COMMANDE au shell avec -c\n"
"  -f, --fast                   passe -f au shell (valable pour csh ou tcsh)\n"
"  -m, --preserve-environment   pas réinitialiser les variables "
"d'environnement\n"
"  -p                           identique à -m\n"
"  -s, --shell=SHELL            lance le SHELL si /etc/shells le permet\n"

#: src/su.c:382
msgid ""
"\n"
"A mere - implies -l.   If USER not given, assume root.\n"
msgstr ""
"\n"
"Un tiret - implique -l.   Si l'argument USAGER n'est pas fourni,\n"
"l'usager « root » est utilisé.\n"

#: src/su.c:459
#, c-format
msgid "user %s does not exist"
msgstr "L'usager %s n'existe pas."

#: src/su.c:482
#, c-format
msgid "incorrect password"
msgstr "Mot de passe incorrect."

#: src/su.c:499
#, c-format
msgid "using restricted shell %s"
msgstr "Utilisation du shell %s restreint."

#: src/su.c:507
#, c-format
msgid "warning: cannot change directory to %s"
msgstr "AVERTISSEMENT: ne peut changer de répertoire vers %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/sum.c:37
msgid "Kayvan Aghaiepour"
msgstr "Kayvan Aghaiepour"

#: src/sum.c:63
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"Imprimer la somme de contrôle et le nombre de blocs pour chaque FICHIER.\n"
"\n"
"  -r              utilise l'algorithme de sommation BSD\n"
"                  avec des blocs de 1K octets\n"
"  -s, --sysv      utilise l'algorithme de sommation du Système V\n"
"                  avec des blocs de 512 octets\n"

#: src/sync.c:42
msgid ""
"Force changed blocks to disk, update the super block.\n"
"\n"
msgstr ""
"Forcer l'écriture des blocs modifiés sur disque et\n"
"la mise à jour du super bloc.\n"

#: src/sync.c:70
#, c-format
msgid "ignoring all arguments"
msgstr "tous les arguments sont ignorés"

#: src/system.h:384
#, c-format
msgid ""
"\n"
"NOTE: your shell may have its own version of %s, which usually supersedes\n"
"the version described here.  Please refer to your shell's documentation\n"
"for details about the options it supports.\n"
msgstr ""
"\n"
"NOTE: votre shell peut avoir sa propre version de %s, lequel habituellement "
"remplace\n"
"la version décrite ici.  SVP référer à la documentation de votre shell\n"
"pour les détail concernant les options supportées.\n"

#: src/system.h:390
msgid "      --help     display this help and exit\n"
msgstr "      --help      afficher l'aide-mémoire\n"

#: src/system.h:392
msgid "      --version  output version information and exit\n"
msgstr "      --version   afficher le nom et la version du logiciel\n"

#: src/system.h:569
#, fuzzy
msgid ""
"\n"
"SIZE may be (or may be an integer optionally followed by) one of following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
msgstr ""
"\n"
"TAILLE peut être (ou peut être un entier optionnellement suivi par) un de "
"ceux qui suivent:\n"
"kB 1000, K 1024, MB 1000*1000, M 1024*1024 et ainsi de suite pour G, T, P, "
"E, Z, Y.\n"
"\n"

#: src/system.h:578
#, c-format
msgid ""
"\n"
"Display values are in units of the first available SIZE from --block-size,\n"
"and the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\n"
"Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"
msgstr ""

#: src/system.h:588
#, c-format
msgid ""
"\n"
"Report %s bugs to %s\n"
msgstr ""
"\n"
"Signaler %s bugs à %s\n"

#. TRANSLATORS: Replace LANG_CODE in this URL with your language code
#. <http://translationproject.org/team/LANG_CODE.html> to form one of
#. the URLs at http://translationproject.org/team/.  Otherwise, replace
#. the entire URL with your translation team's email address.
#: src/system.h:604
#, c-format
msgid "Report %s translation bugs to <http://translationproject.org/team/>\n"
msgstr ""
"Rapporter %s les erreurs de traduction à <http://translationproject.org/team/"
">\n"

#: src/system.h:608
#, c-format
msgid "For complete documentation, run: info coreutils '%s invocation'\n"
msgstr ""

#: src/system.h:678
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"AVERTISSEMENT: structure de répertoire circulaire.\n"
"Cela signifie très certainement que votre système de fichiers est corrompu.\n"
"AVISER VOTRE ADMINISTRATEUR SYSTÈME.\n"
"Le répertoire suivant fait parti du cycle:\n"
"  %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/tac.c:57
msgid "Jay Lepreau"
msgstr "Jay Lepreau"

#: src/tac.c:137
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Écrire chaque FICHIER sur la sortie standard, la dernière ligne en premier.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/tac.c:145
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before           placer le séparateur avant plutôt qu'après\n"
"  -r, --regex            interpréter le séparateur comme une expression\n"
"                          régulière\n"
"  -s, --separator=CHAÎNE utiliser la CHAÎNE comme séparateur au lieu\n"
"                          du saut de ligne\n"

#: src/tac.c:235 src/tac.c:336
#, c-format
msgid "%s: seek failed"
msgstr "%s: échec de repérage (seek)"

#: src/tac.c:264
#, c-format
msgid "record too large"
msgstr "enregistrement trop grand"

#: src/tac.c:466 src/truncate.c:395
#, c-format
msgid "cannot open %s for writing"
msgstr "ne peut ouvrir %s en écriture"

#: src/tac.c:487 src/tac.c:494
#, c-format
msgid "%s: write error"
msgstr "%s: erreur d'écriture."

#: src/tac.c:601
#, c-format
msgid "separator cannot be empty"
msgstr "Le séparateur ne peut être vide."

#. This is a proper name. See the gettext manual, section Names.
#: src/tail.c:63
msgid "Ian Lance Taylor"
msgstr "Ian Lance Taylor"

#: src/tail.c:253
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Afficher les %d dernières lignes de chaque FICHIER sur la sortie standard.\n"
"Avec plus d'un fichier FICHIER, précéder chacun d'une en-tête donnant le "
"nom.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/tail.c:262
#, fuzzy
msgid ""
"  -c, --bytes=K            output the last K bytes; alternatively, use -c "
"+K\n"
"                           to output bytes starting with the Kth of each "
"file\n"
msgstr ""
"  -c, --bytes=N            affiche les N derniers octets; alternativement, "
"employer +N pour\n"
"                           afficher les octets débutant au Nième de chaque "
"fichier\n"

#: src/tail.c:266
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                           -f, --follow, and --follow=descriptor are\n"
"                           equivalent\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={nom|descripteur}]\n"
"                           afficher les dernières données ajoutées tant\n"
"                            que le fichier s'accroît; -f, --follow, et\n"
"                           --follow=descripteur sont équivalents\n"
"  -F                        identique à --follow=nom --retry\n"

#: src/tail.c:273
#, fuzzy, c-format
msgid ""
"  -n, --lines=K            output the last K lines, instead of the last %d;\n"
"                           or use -n +K to output lines starting with the "
"Kth\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                           changed size after N (default %d) iterations\n"
"                           to see if it has been unlinked or renamed\n"
"                           (this is the usual case of rotated log files)\n"
msgstr ""
"  -n, --lines=N            affiche les N dernièreslignes, au lieu des "
"derniers %d ;\n"
"                           ou employez +N pour afficher les lignes à partir "
"de la Nième\n"
"      --max-unchanged-stats=N\n"
"                           avec l'option --follow=name, rouvre un FICHIER "
"qui n'a pas\n"
"                           changé de taille après N itérations (par défaut %"
"d)\n"
"                           afin de vérifier s'il a été détruit ou s'il a "
"changé\n"
"                           de nom (c'est le cas habituellement des fichiers "
"rotatifs\n"
"                           de journalisation)\n"

#: src/tail.c:285
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"      --retry              keep trying to open a file even when it is or\n"
"                             becomes inaccessible; useful when following by\n"
"                             name, i.e., with --follow=name\n"
msgstr ""
"      --pid=PID            avec -f, terminer après le processus ID, PID "
"s'arrête\n"
"  -q, --quiet, --silent    n'affiche jamais l'en-tête qui donne\n"
"                            les noms de fichiers\n"
"      --retry              continue d'essayer d'ouvrir un fichier même quand "
"il est ou\n"
"                             devient inaccessible; utile quand on suit par "
"le\n"
"                             nom, i.e., with --follow=name\n"

#: src/tail.c:292
#, fuzzy
msgid ""
"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
"                             (default 1.0) between iterations\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"  -s, --sleep-interval=S   avec -f, attendre S secondes (1.0 par défaut)\n"
"                            entre les itérations\n"
"  -v, --verbose            affiche toujours les en-têtes des noms de "
"fichier\n"

#: src/tail.c:299
#, fuzzy
msgid ""
"\n"
"If the first character of K (the number of bytes or lines) is a `+',\n"
"print beginning with the Kth item from the start of each file, otherwise,\n"
"print the last K items in the file.  K may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
msgstr ""
"\n"
"Si le premier caractère de N (le nombre d'octets ou de lignes) est un « + »,\n"
"affiche à partir du Nième item depuis le début de chaque fichier,\n"
"autrement, affiche les derniers N items du fichier.\n"
"N peut avoir un suffixe multiplicateur :\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, et ainsi de suite pour T, P, E, Z, Y.\n"
"\n"

# src/tail.c:290
#: src/tail.c:308
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  "
msgstr ""
"Avec l'option --follow (-f), tail utilise par défaut le descripteur de "
"fichier\n"
"qui permet de suivre l'évolution du fichier ciblé même s'il change de nom.\n"
"Tail continuera de suivre l'évolution du fichier jusqu'à la fin. "

#: src/tail.c:313
msgid ""
"This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file by reopening it periodically to see if it has been removed and\n"
"recreated by some other program.\n"
msgstr ""
"Ce comportement par défaut n'est pas désirable lorsqu'on désire suivre "
"l'évolution\n"
"d'un fichier à l'aide de son nom et non pas par le descripteur de fichier (i."
"e. cas\n"
"lors de la rotation des journaux). Utiliser --follow=nom dans ce cas.\n"
"À ce moment, tail suivra l'évolution du fichier en l'ouvrant périodiquement\n"
"afin de vérifier s'il a été détruit ou recréé par un autre programme.\n"

#: src/tail.c:371
#, c-format
msgid "closing %s (fd=%d)"
msgstr "fermeture %s (fd=%d)"

#: src/tail.c:446
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s: ne peut repérer selon le déplacement relatif %s"

#: src/tail.c:450
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s: ne peut repérer la fin selon le déplacement relatif %s"

#: src/tail.c:902
#, c-format
msgid "%s has become inaccessible"
msgstr "%s est devenu inaccessible"

#: src/tail.c:919
#, c-format
msgid "%s has been replaced with an untailable file; giving up on this name"
msgstr ""
"%s a été remplacé par un fichier dont on ne peut déterminer la taille; "
"abandon sur ce nom."

#: src/tail.c:940
#, c-format
msgid "%s has become accessible"
msgstr "%s est devenu accessible"

#: src/tail.c:948
#, c-format
msgid "%s has appeared;  following end of new file"
msgstr "%s est apparu; à la fin d'un nouveau fichier"

#: src/tail.c:959
#, c-format
msgid "%s has been replaced;  following end of new file"
msgstr "%s a été remplacé; à la fin d'un nouveau fichier"

#: src/tail.c:1060
#, c-format
msgid "%s: cannot change nonblocking mode"
msgstr "%s: n'a pu changer en mode non bloquant"

#: src/tail.c:1101 src/tail.c:1189
#, c-format
msgid "%s: file truncated"
msgstr "%s: fichier tronqué"

#: src/tail.c:1125
#, c-format
msgid "no files remaining"
msgstr "aucun fichier restant"

#: src/tail.c:1266
#, fuzzy, c-format
msgid "cannot watch parent directory of %s"
msgstr "ne peut obtenir par stat() le répertoire courant (maintenant %s)"

#: src/tail.c:1277 src/tail.c:1384
#, fuzzy, c-format
msgid "cannot watch %s"
msgstr "ne peut faire un touch sur %s"

#: src/tail.c:1339
#, fuzzy, c-format
msgid "error monitoring inotify event"
msgstr "Erreur lors de la lecture %s"

#: src/tail.c:1359
#, fuzzy, c-format
msgid "error reading inotify event"
msgstr "Erreur lors de la lecture %s"

#: src/tail.c:1633
#, c-format
msgid "%s: cannot follow end of this type of file; giving up on this name"
msgstr ""
"%s: ne peut déterminer la fin de ce type de fichier; abandon sur ce nom"

#: src/tail.c:1749
#, c-format
msgid "number in %s is too large"
msgstr "numéro dans %s est trop grand"

#: src/tail.c:1821
#, c-format
msgid "%s: invalid maximum number of unchanged stats between opens"
msgstr ""
"%s: nombre maximum invalide de changements d'états entre les ouvertures"

#: src/tail.c:1837
#, c-format
msgid "%s: invalid PID"
msgstr "%s: PID invalide."

#: src/tail.c:1856
#, c-format
msgid "%s: invalid number of seconds"
msgstr "%s: nombre de secondes invalide."

#: src/tail.c:1872
#, c-format
msgid "option used in invalid context -- %c"
msgstr "option utilisée dans un contexte invalide -- %c"

#: src/tail.c:1880
#, c-format
msgid "warning: --retry is useful mainly when following by name"
msgstr "AVERTISSEMENT : --retry est utile principalement si suivi par un nom"

#: src/tail.c:1884
#, c-format
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr ""
"AVERTISSEMENT: PID ignoré; --pid=PID est utile seulement lorsqu'il suit"

#: src/tail.c:1887
#, c-format
msgid "warning: --pid=PID is not supported on this system"
msgstr "AVERTISSEMENT: --pid=PID n'est pas supporté sur ce système"

#: src/tail.c:1988
#, c-format
msgid "cannot follow %s by name"
msgstr "ne peut suivre %s par le nom"

#: src/tail.c:1994
#, c-format
msgid "warning: following standard input indefinitely is ineffective"
msgstr "AVERTISSEMENT: suivre l'entrée standard indéfiniment est inefficace"

#: src/tail.c:2031
#, c-format
msgid "inotify cannot be used, reverting to polling"
msgstr ""

#: src/tee.c:63
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"Copier de l'entrée standard vers chaque FICHIER, \n"
"et également vers la sortie standard.\n"
"\n"
"  -a, --append              accoler la sortie au(x) FICHIER(s),\n"
"                            sans les écraser\n"
"  -i, --ignore-interrupts   ignorer les signaux d'interruption\n"

#: src/tee.c:71
msgid ""
"\n"
"If a FILE is -, copy again to standard output.\n"
msgstr ""
"\n"
"Si le FICHIER est -, copier à nouveau sur la sortie standard.\n"

#: src/test.c:117
#, c-format
msgid "missing argument after %s"
msgstr "argument manquant après %s"

#: src/test.c:153
#, c-format
msgid "invalid integer %s"
msgstr "entier invalide %s"

#: src/test.c:234
msgid "')' expected"
msgstr "« ) » attendu"

#: src/test.c:237
#, c-format
msgid "')' expected, found %s"
msgstr "')' attendu, trouvé %s"

#: src/test.c:253 src/test.c:598
#, c-format
msgid "%s: unary operator expected"
msgstr "%s : opérateur unaire attendu"

#: src/test.c:322
msgid "-nt does not accept -l"
msgstr "-nt ne permet pas -l"

#: src/test.c:335
msgid "-ef does not accept -l"
msgstr "-ef ne permet pas -l"

#: src/test.c:351
msgid "-ot does not accept -l"
msgstr "-ot ne permet pas -l"

#: src/test.c:360
msgid "unknown binary operator"
msgstr "opérateur binaire inconnu"

#: src/test.c:626
#, c-format
msgid "%s: binary operator expected"
msgstr "%s : opérateur binaire attendu"

#: src/test.c:685
msgid ""
"Usage: test EXPRESSION\n"
"  or:  test\n"
"  or:  [ EXPRESSION ]\n"
"  or:  [ ]\n"
"  or:  [ OPTION\n"
msgstr ""
"Usage: test EXPRESSION\n"
"   ou: test\n"
"   ou: [ EXPRESSION ]\n"
"   ou: [ ]\n"
"   ou: %s OPTION ]\n"

#: src/test.c:692
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr ""
"Terminer l'exécution avec l'état déterminé par l'EXPRESSION.\n"
"\n"

#: src/test.c:698
msgid ""
"\n"
"An omitted EXPRESSION defaults to false.  Otherwise,\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"Une EXPRESSION omise est par défaut fausse. Autrement,\n"
"l'EXPRESSION est vraie ou fausse et initialise l'état de fin d'exécution.\n"
"selon une des options:\n"

#: src/test.c:703
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( EXPRESSION )               EXPRESSION est vraie\n"
"  ! EXPRESSION                 EXPRESSION est fausse\n"
"  EXPRESSION1 -a EXPRESSION2   si les deux EXPRESSION1 et EXPRESSION2\n"
"                               sont vraies\n"
"  EXPRESSION1 -o EXPRESSION2   si l'une ou l'autre des expressions:\n"
"                               EXPRESSION1 ou EXPRESSION2 est vraie\n"

#: src/test.c:710
msgid ""
"\n"
"  -n STRING            the length of STRING is nonzero\n"
"  STRING               equivalent to -n STRING\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  -n CHAÎNE               si la longueur de la CHAÎNE n'est pas nulle\n"
"  CHAÎNE                  équivalenet à -n CHAÎNE\n"
"  -z CHAÎNE               si la longueur de la CHAÎNE est nulle\n"
"  CHAÎNE1 = CHAÎNE2       si les chaînes sont identiques\n"
"  CHAÎNE1 != CHAÎNE2      si les chaînes sont différentes\n"

#: src/test.c:718
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  ENTIER1 -eq ENTIER2     si ENTIER1 est égal à ENTIER2\n"
"  ENTIER1 -ge ENTIER2     si ENTIER1 est plus grand ou égal à ENTIER2\n"
"  ENTIER1 -gt ENTIER2     si ENTIER1 est plus grand que ENTIER2\n"
"  ENTIER1 -le ENTIER2     si ENTIER1 est plus petit ou égal à ENTIER2\n"
"  ENTIER1 -lt ENTIER2     si ENTIER1 est plus petit que ENTIER2\n"
"  ENTIER1 -ne ENTIER2     si ENTIER1 n'est pas égal à ENTIER2\n"

#: src/test.c:727
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  FICHIER1 -ef FICHIER2   FICHIER1 et FICHIER2 ont les mêmes numéros\n"
"                          de périphérique et d'inode\n"
"  FICHIER1 -nt FICHIER2   FICHIER1 est plus récent (date de modification)\n"
"                          que FICHIER2\n"
"  FICHIER1 -ot FICHIER2   FICHIER1 est plus vieux que FICHIER2\n"

#: src/test.c:733
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b FICHIER     FICHIER existe et est de type à blocage spécial\n"
"  -c FICHIER     FICHIER existe et est de type caractère spécial\n"
"  -d FICHIER     FICHIER existe et est un répertoire\n"
"  -e FICHIER     FICHIER existe\n"

#: src/test.c:740
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f FICHIER     FICHIER existe et est de type régulier\n"
"  -g FICHIER     FICHIER existe et le bit « set-group-ID », est initialisé\n"
"  -G FICHIER     FICHIER existe et appartient au groupe effectif ID\n"
"  -h FICHIER     FICHIER existe et est un lien symbolique (identique à -L)\n"
"  -k FICHIER     FICHIER existe et le bit « sticky » est initialisé\n"

#: src/test.c:747
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and read permission is granted\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L FICHIER     FICHIER existe et est un lien symbolique (identique à -h)\n"
"  -O FICHIER     FICHIER existe et appartient à l'usager effectif ID\n"
"  -p FICHIER     FICHIER existe et est un relais nommé (named pipe)\n"
"  -r FICHIER     FICHIER existe et les permissions en lecture sont données\n"
"  -s FICHIER     FICHIER existe et a une taille plus grande que zéro\n"

#: src/test.c:754
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t FD       file descriptor FD is opened on a terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and write permission is granted\n"
"  -x FILE     FILE exists and execute (or search) permission is granted\n"
msgstr ""
"  -S FICHIER     FICHIER existe et est de type « socket »\n"
"  -t DF          descripteur de fichier DF est ouvert sur le terminal\n"
"  -u FICHIER     FICHIER existe et le bit « set-user-ID », est initialisé\n"
"  -w FICHIER     FICHIER existe et les permissions en écriture sont données\n"
"  -x FICHIER     FICHIER existe et exécutable\n"

#: src/test.c:761
msgid ""
"\n"
"Except for -h and -L, all FILE-related tests dereference symbolic links.\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"Excepté pour -h et -L, tous les tests relatifs aux fichiers dé-reéférence "
"les liens symboliques.\n"
"Portez attention au fait que les parenthèses doivent être précédées par des\n"
"barres obliques inverses (pour éviter l'échappement vers un shell).\n"
"Un ENTIER peut être évalué par la notation -l CHAÎNE laquelle\n"
"évalue alors la longueur de la chaîne.\n"

#: src/test.c:767
msgid ""
"\n"
"NOTE: [ honors the --help and --version options, but test does not.\n"
"test treats each of those as it treats any other nonempty STRING.\n"
msgstr ""
"\n"
"NOTE : [reconnaît les options --help et --version, mais test ne le fait "
"pas.\n"
"test traite chacun de ceux-ci comme il traite n'importe quelle STRING non "
"vide.\n"

#: src/test.c:772
msgid "test and/or ["
msgstr "test et/ou ["

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:784
msgid "Kevin Braunsdorf"
msgstr "Kevin Braunsdorf"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:785
msgid "Matthew Bradburn"
msgstr "Matthew Bradburn"

#: src/test.c:839
msgid "missing `]'"
msgstr "« ] » manquant"

#: src/test.c:853
#, c-format
msgid "extra argument %s"
msgstr "argument surnuméraire %s"

#: src/timeout.c:127
#, c-format
msgid ""
"Usage: %s [OPTION] NUMBER[SUFFIX] COMMAND [ARG]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Usage : %s [OPTION] NUMBER[SUFFIX] COMMAND [ARG]...\n"
"  ou :  %s [OPTION]\n"

#: src/timeout.c:131
msgid ""
"Start COMMAND, and kill it if still running after NUMBER seconds.\n"
"SUFFIX may be `s' for seconds (the default), `m' for minutes,\n"
"`h' for hours or `d' for days.\n"
"\n"
msgstr ""
"Lance COMMAND, et la tue si elle toujours en cours après NUMBER secondes.\n"
"SUFFIX peut être `s' pour secondes (par défaut), `m' pour minutes,\n"
"`h' pour heures ou `d' pour jours.\n"
"\n"

#: src/timeout.c:141
msgid ""
"  -s, --signal=SIGNAL\n"
"                   specify the signal to be sent on timeout.\n"
"                   SIGNAL may be a name like `HUP' or a number.\n"
"                   See `kill -l` for a list of signals\n"
msgstr ""
"  -s, --signal=SIGNAL\n"
"                   spécifie le signal à envoyer lors d'un timeout.\n"
"                   SIGNAL peut être un nom comme `HUP' ou un nombre.\n"
"                   Voir `kill -l` pour une liste de signaux\n"

#: src/timeout.c:149
#, fuzzy
msgid ""
"\n"
"If the command times out, then exit with status 124.  Otherwise, exit\n"
"with the status of COMMAND.  If no signal is specified, send the TERM\n"
"signal upon timeout.  The TERM signal kills any process that does not\n"
"block or catch that signal.  For other processes, it may be necessary to\n"
"use the KILL (9) signal, since this signal cannot be caught.\n"
msgstr ""
"\n"
"Si la commande dépasse le temps imparti, alors on quitte avec le status "
"124,\n"
"sinon le status normal de la commande est renvoyé.\n"
"Si aucun signal n'est spécifié, le signal TERM est envoyé. Le signal TERM\n"
"tuera tous les process qui n'attrape pas ce signal. Pour les autres "
"process,\n"
"il peut être nécessaire d'employer le signal KILL(9), puisque ce signal ne "
"peut\n"
"être attrapé.\n"

#: src/timeout.c:317
#, fuzzy, c-format
msgid "error waiting for command"
msgstr "Erreur lors de l'écriture %s"

#: src/timeout.c:329
#, c-format
msgid "unknown status from command (0x%X)"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:44
msgid "Jim Kingdon"
msgstr "Jim Kingdon"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:46
msgid "Randy Smith"
msgstr "Randy Smith"

#: src/touch.c:117 src/touch.c:318
#, c-format
msgid "invalid date format %s"
msgstr "format de date invalide %s"

#: src/touch.c:193
#, c-format
msgid "cannot touch %s"
msgstr "ne peut faire un touch sur %s"

#: src/touch.c:199
#, c-format
msgid "setting times of %s"
msgstr "initialisation des dates de %s"

#: src/touch.c:216
#, fuzzy
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
"A FILE argument that does not exist is created empty, unless -c or -h\n"
"is supplied.\n"
"\n"
"A FILE argument string of - is handled specially and causes touch to\n"
"change the times of the file associated with standard output.\n"
"\n"
msgstr ""
"Établit la date d'accès et de modification de chaque FILE à l'heure "
"présente.\n"
"\n"
"Un argument de FILE qui n'existe pas est crée vide.\n"
"\n"
"Une chaîne d'argument de FILE à - est géré spécifiquement et fait que touch\n"
"change la date du fichier associé avec la sortie standard.\n"
"\n"

#: src/touch.c:229
#, fuzzy
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
msgstr ""
"  -a                   modifier seulement la date d'accès\n"
"  -c, --no-create      ne créer aucun fichier\n"
"  -d, --date=CHAÎNE    analyser la CHAÎNE et l'utiliser au lieu\n"
"                       de la date courante\n"
"  -f                   (ignorée)\n"
"  -m                   modifier seulement la date de modification\n"

#: src/touch.c:235
#, fuzzy
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         timestamps of a symlink)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -h, --no-dereference      modifier les liens symboliques au lieu des\n"
"                            fichiers référencés (utile seulement\n"
"                             sur les systèmes permettant de changer le "
"propriétaire\n"
"                             d'un lien symbolique)\n"

#: src/touch.c:241
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"  --time=WORD            change the specified time:\n"
"                           WORD is access, atime, or use: equivalent to -a\n"
"                           WORD is modify or mtime: equivalent to -m\n"
msgstr ""
"  -r, --file=FICHIER   utiliser la date du FICHIER comme référence\n"
"                       au lieu de la date courante\n"
"  -t DATE              utiliser la DATE selon le format:\n"
"                        [[CC]AA]MMJJhhmm[.ss]\n"
"                       comme tampon date-heure au lieu de la date courante\n"
"      --time=CODE      modifier le temps selon que:\n"
"                        CODE est « access » ou « atime » équivalent à -a\n"
"                        CODE est « modify » ou « mtime » équivalent à -m\n"

#: src/touch.c:250
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"Noter que les options -d et -t acceptent différents formats de date et "
"d'heure.\n"

#: src/touch.c:309
#, c-format
msgid "warning: the --%s option is obsolete; use --reference"
msgstr "attention : l'option --%s est caduque; employer --reference"

#: src/touch.c:344
#, c-format
msgid "cannot specify times from more than one source"
msgstr "ne peut spécifier les dates pour plus d'une source"

#: src/touch.c:412
#, c-format
msgid ""
"warning: `touch %s' is obsolete; use `touch -t %04ld%02d%02d%02d%02d.%02d'"
msgstr ""
"AVERTISSEMENT: `touch %s' est obsolète; utiliser `touch -t %04ld%02d%02d%02d%"
"02d.%02d'"

#: src/tr.c:286
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Usage: %s [OPTION]... ENSEMBLE1 [ENSEMBLE2]\n"

#: src/tr.c:290
#, fuzzy
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, -C, --complement    use the complement of SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each input sequence of a repeated "
"character\n"
"                            that is listed in SET1 with a single occurrence\n"
"                            of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"Traduire, compresser et/ou éliminer des caractères de l'entrée standard,\n"
"par écriture sur la sortie standard.\n"
"\n"
"  -c, -C, --complement    complémenter à un l'ENSEMBLE1 \n"
"  -d, --delete            éliminer les caractères de l'ENSEMBLE1\n"
"                            et ne pas traduire\n"
"  -s, --squeeze-repeats   remplacer chaque séquence d'entrée de caractères "
"répétés\n"
"                            qui apparaît dans l'ENSEMBLE1 par une seule "
"occurence\n"
"                            de ce caractère\n"
"  -t, --truncate-set1     tronquer d'abord l'ENSEMBLE1 à la longueur\n"
"                            de l'ENSEMBLE2\n"

#: src/tr.c:303
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"Les ENSEMBLES sont spécifiés comme des chaînes de caractères.\n"
"La plupart se représente eux-mêmes.\n"
"Les séquences d'interprétation sont:\n"
"\n"
"  \\NNN            caractère ayant la valeur octale NNN (1 à 3 chiffres "
"octaux)\n"
"  \\\\             barre oblique inverse\n"
"  \\a              cloche sonore \n"
"  \\b              caractère d'effacement\n"
"  \\f              saut de page \n"
"  \\n              saut de ligne \n"
"  \\r              retour\n"
"  \\t              saut horizontal\n"

#: src/tr.c:317
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              saut vertical \n"
"  CAR1-CAR2       tous les caractères de CAR1 à CAR2 en ordre croissant\n"
"  [CAR*]          dans ENS2, copie de CAR jusqu'à longueur de ENS1\n"
"  [CAR*RÉP]       RÉPéter copies de CAR, RÉPéter en octal si débute par 0\n"
"  [:alnum:]       toutes les lettres et les chiffres\n"
"  [:alpha:]       toutes les lettres\n"
"  [:blank:]       tous les blancs horizontaux\n"
"  [:cntrl:]       tous les caractères de contrôle\n"
"  [:digit:]       tous les chiffres\n"

#: src/tr.c:328
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       tous les caractères imprimables, sans inclure les blancs\n"
"  [:lower:]       tous les lettres minuscules\n"
"  [:print:]       tous les caractères imprimables, incluant les blancs\n"
"  [:punct:]       tous les caractères de ponctuation\n"
"  [:space:]       tous les sauts verticaux ou horizontaux\n"
"  [:upper:]       toutes les lettres majuscules\n"
"  [:xdigit:]      tous les chiffres hexadécimaux\n"
"  [=CAR=]         tous les caractères équivalents à CAR\n"

#: src/tr.c:338
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""
"\n"
"La traduction se fait si -d n'est pas donné et SET1 et SET2 apparaissent.\n"
"-t peut être employé seulement en traduction.  SET2 est adapté à la longueur "
"de\n"
"SET1 par la répétition de son dernier caractère.  Les caratères en "
"excédents\n"
"de SET2 sont ignorés. Seulement [:lower:] et [:upper:] offre la garantie de\n"
"l'expansion dans l'ordre ascendant; utilisé dans SET2 durant la traduction, "
"ils ne\n"
"devraient être utilisés que par paires pour spécifier la conversion de "
"casse.\n"
"  -s emploie SET1 si pas de traduction, ni de suppression; sinon la "
"compression\n"
"emploie SET2 et est faite après la traduction et la suppression.\n"

#: src/tr.c:509
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, %c"
msgstr ""
"AVERTISSEMENT: l'échappement octal ambigü \\%c%c%c a été\n"
"               interprété comme une séquence de 2-octets \\0%c%c, %c"

#: src/tr.c:518
#, c-format
msgid "warning: an unescaped backslash at end of string is not portable"
msgstr ""
"AVERTISSEMENT : un backslash non inhibé (unescaped) à la fin de la chaîne "
"est incompatible"

#: src/tr.c:673
#, c-format
msgid "range-endpoints of `%s-%s' are in reverse collating sequence order"
msgstr ""
"bornes d'intervalle de « %s-%s » sont en ordre inverse de séquence\n"
"de comparaison."

#: src/tr.c:829
#, c-format
msgid "invalid repeat count %s in [c*n] construct"
msgstr "compte de répétions %s invalide dans le construit [c*n]"

#: src/tr.c:910
#, c-format
msgid "missing character class name `[::]'"
msgstr "caractères de nom de classe « [::] » manquants"

#: src/tr.c:913
#, c-format
msgid "missing equivalence class character `[==]'"
msgstr "caractères d'équivalence de classe « [==] » manquants"

#: src/tr.c:928
#, c-format
msgid "invalid character class %s"
msgstr "caractère de classe invalide %s"

#: src/tr.c:947
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: opérande d'équivalence de classe doit être un caractère simple"

#: src/tr.c:1263
#, c-format
msgid "too many characters in set"
msgstr "trop de caractères dans le jeu"

#: src/tr.c:1411
#, c-format
msgid "the [c*] repeat construct may not appear in string1"
msgstr "le construit [c*] de répétition ne peut apparaître dans la chaîne1"

#: src/tr.c:1421
#, c-format
msgid "only one [c*] repeat construct may appear in string2"
msgstr "un seul construit de répétition [c*] peut apparaître dans chaîne2"

#: src/tr.c:1429
#, c-format
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr ""
"les expressions [=c=] ne peuvent apparaître dans chaîne2 lors de traductions"

#: src/tr.c:1442
#, c-format
msgid "when not truncating set1, string2 must be non-empty"
msgstr "lorsque que l'ensemble1 n'est pas tronqué, chaîne2 ne peut être vide"

#: src/tr.c:1451
#, c-format
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"lors de traduction avec des caractères complémentées de classes,\n"
"la chaîne2 doit ramener tous les caractères du domaine à un seul"

#: src/tr.c:1458
#, c-format
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are `upper' and `lower'"
msgstr ""
"lors de traductions la seule classe de caractères pouvant apparaître\n"
"dans chaîne2 est « upper » ou « lower »"

#: src/tr.c:1467
#, c-format
msgid "the [c*] construct may appear in string2 only when translating"
msgstr ""
"le construit [c*] peut apparaître dans chaîne2 seulement lors d'une\n"
"traduction"

#: src/tr.c:1717
msgid "Two strings must be given when both deleting and squeezing repeats."
msgstr ""
"Deux chaînes doivent être données quand à la fois suppression et compression "
"se répètent."

#: src/tr.c:1719
msgid "Two strings must be given when translating."
msgstr "Deux chaînes doivent être fournies lors de la traduction."

#: src/tr.c:1729
msgid "Only one string may be given when deleting without squeezing repeats."
msgstr ""
"Seulement une chaîne peut être fournie lors d'une destruction sans\n"
"réduction des répétitions"

#: src/tr.c:1841
#, c-format
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "construit [:upper:] et/ou [:lower:] mal aligné"

#: src/true.c:38
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s [arguments de la ligne de commande ignorés]\n"
"   ou: %s OPTION\n"

#: src/true.c:45
msgid "Exit with a status code indicating success."
msgstr "Fin d'exécution avec le code de statut indiquant le succès"

#: src/true.c:46
msgid "Exit with a status code indicating failure."
msgstr "Fin d'exécution avec un code status indiquant l'échec."

#: src/truncate.c:102
#, c-format
msgid "Usage: %s OPTION... FILE...\n"
msgstr "Usage : %s [OPTION]... [FICHIER]...\n"

#: src/truncate.c:103
msgid ""
"Shrink or extend the size of each FILE to the specified size\n"
"\n"
"A FILE argument that does not exist is created.\n"
"\n"
"If a FILE is larger than the specified size, the extra data is lost.\n"
"If a FILE is shorter, it is extended and the extended part (hole)\n"
"reads as zero bytes.\n"
"\n"
msgstr ""
"Réduit ou étend la taille de chaque FILE à la taille spécifiée\n"
"\n"
"L'argument A FILE qui n'existe pas, est créé.\n"
"\n"
"Si un FILE est plus grand que la taille spécifiée, les données restantes "
"sont perdues.\n"
"Si un FILE est plus court, il est agrandit et la partie en plus (trou)\n"
"se compose d'octet à zéro.\n"
"\n"

#: src/truncate.c:116
msgid "  -c, --no-create        do not create any files\n"
msgstr "  -c, --no-create         ne crée aucun fichier\n"

#: src/truncate.c:119
msgid ""
"  -o, --io-blocks        Treat SIZE as number of IO blocks instead of bytes\n"
msgstr ""
"  -o, --io-blocks        Traite SIZE comme un nombre de blocs IO au lieu "
"d'octets\n"

#: src/truncate.c:122
msgid ""
"  -r, --reference=FILE   use this FILE's size\n"
"  -s, --size=SIZE        use this SIZE\n"
msgstr ""
"  -r, --reference=FICHIER   utilise la taille de ce FICHIER\n"
"  -s, --size=TAILLE        utilise cette TAILLE\n"

#: src/truncate.c:128
msgid ""
"\n"
"SIZE may also be prefixed by one of the following modifying characters:\n"
"`+' extend by, `-' reduce by, `<' at most, `>' at least,\n"
"`/' round down to multiple of, `%' round up to multiple of.\n"
msgstr ""
"\n"
"TAILLE peut aussi être préfixé par un de ces caractères modificateurs :\n"
"`+' agrandit de, `-' réduit de, `<' au plus, `>' au moins,\n"
"`/' arrondi au multiple inférieur de, `%' arrondi au multiple supérieur de.\n"

#: src/truncate.c:132
msgid ""
"\n"
"Note that the -r and -s options are mutually exclusive.\n"
msgstr ""
"\n"
"Noter que les options -r et -s s'excluent mutuellement.\n"

#: src/truncate.c:159
#, c-format
msgid "overflow in %<PRIdMAX> * %<PRIdMAX> byte blocks for file %s"
msgstr ""
"débordement dans %<PRIdMAX> * %<PRIdMAX> blocs d'octets pour le fichier %s"

#: src/truncate.c:181
#, c-format
msgid "%s has unusable, apparently negative size"
msgstr "%s : a une taille inutilisable, apparemment négative."

#: src/truncate.c:202
#, c-format
msgid "overflow rounding up size of file %s"
msgstr "débordement lors de l'arrondi supérieur de la taille du fichier %s"

#: src/truncate.c:212
#, c-format
msgid "overflow extending size of file %s"
msgstr "débordement lors de l'augmentation de la taille du fichier %s"

#: src/truncate.c:241
#, c-format
msgid "truncating %s at %<PRIdMAX> bytes"
msgstr "troncation %s à %<PRIdMAX> octets"

#: src/truncate.c:315
#, c-format
msgid "multiple relative modifiers specified"
msgstr "modificateurs relatifs multiples spécifiés"

#: src/truncate.c:345
#, c-format
msgid "you must specify one of %s or %s"
msgstr "vous devez spécifier l'un de %s ou %s"

#: src/truncate.c:352
#, c-format
msgid "%s was specified but %s was not"
msgstr "%s était spécifié mais pas %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/tsort.c:39
msgid "Mark Kettenis"
msgstr "Mark Kettenis"

#: src/tsort.c:82
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Usage: %s [OPTION] [FICHIER]\n"
"Afficher une liste totalement ordonnée consistante avec l'ordenancement\n"
"partiel donné dans le FICHIER.\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/tsort.c:470
#, c-format
msgid "%s: input contains an odd number of tokens"
msgstr "%s: l'entrée contient un nombre impair de jetons"

#: src/tsort.c:511
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: l'entrée contient une boucle:"

#: src/tty.c:66
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"Afficher le nom de fichier du terminal relié à l'entrée standard.\n"
"\n"
"  -s, --silent, --quiet   ne rien afficher, retourner seulement un\n"
"                          statut de fin d'exécution\n"

#: src/tty.c:121
msgid "not a tty"
msgstr "n'est pas un « tty »"

#: src/uname.c:126
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order,\n"
"                             except omit -p and -i if unknown:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"Afficher certaines informations identifiant le système.\n"
"Sans OPTION, identique à -s.\n"
"\n"
"  -a, --all                afficher toutes les informations\n"
"                             omettre si -p et -i sont inconnus:\n"
"  -s, --kernel-name        afficher le nom du kernel\n"
"  -n, --nodename           afficher le nom du noeud réseau du poste "
"(hostname)\n"
"  -r, --release            afficher la révision de la version du\n"
"                             système d'exploitation\n"

#: src/uname.c:135
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type or \"unknown\"\n"
"  -i, --hardware-platform  print the hardware platform or \"unknown\"\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version     afficher la version du kernel\n"
"  -m, --machine            afficher le nom du système d'exploitation\n"
"  -p, --processor          afficher le type de processeur ou \"unknown\" (i."
"e \"inconnu\")\n"
"  -i, --hardware-platform  afficher les infos matérielles de la plate-forme "
"ou \"unknown\" (i.e \"inconnu\")\n"
"  -o, --operating-system   afficher les infos du système d'exploitation\n"

#: src/uname.c:145
msgid ""
"Print machine architecture.\n"
"\n"
msgstr ""
"Affiche l'architecture machine.\n"
"\n"

#: src/uname.c:288
#, c-format
msgid "cannot get system name"
msgstr "ne peut obtenir le nom de système"

#: src/unexpand.c:117
msgid ""
"Convert blanks in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Convertir les blancs d'espacement de chaque FICHIER par des tabulations\n"
"lors de l'écriture sur la sortie standard.\n"
"Sans FICHIER ou quand le FICHIER est -, lire de l'entrée standard.\n"

#: src/unexpand.c:125
msgid ""
"  -a, --all        convert all blanks, instead of just initial blanks\n"
"      --first-only  convert only leading sequences of blanks (overrides -a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
"  -t, --tabs=LIST  use comma separated LIST of tab positions (enables -a)\n"
msgstr ""
"  -a, --all           convertit tout espace, plutôt que seulement les "
"espaces initiaux\n"
"      --first-only    convertit seulement les séquences de tête d'espaces "
"(écrase -a)\n"
"  -t, --tabs=N        utilise N caractères de tabulations au lieu de 8 "
"(active -a)\n"
"  -t, --tabs=LISTE    utilise LISTE de positions de tabulation séparées par "
"des virgules (active -a)\n"

#: src/unexpand.c:153
#, c-format
msgid "tabs are too far apart"
msgstr "les tabulations sont trop éloignées"

#: src/unexpand.c:504
#, c-format
msgid "tab stop value is too large"
msgstr "la valeur de  l'arrêt de tabulation est trop grand."

#: src/uniq.c:134
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Usage: %s [OPTION]... [ENTRÉE [SORTIE]]\n"

#: src/uniq.c:138
msgid ""
"Filter adjacent matching lines from INPUT (or standard input),\n"
"writing to OUTPUT (or standard output).\n"
"\n"
"With no options, matching lines are merged to the first occurrence.\n"
"\n"
msgstr ""

#: src/uniq.c:148
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
msgstr ""
"  -c, --count           préfixer les lignes par le nombre d'occurences\n"
"  -d, --repeated        afficher seulement les lignes ayant des duplicatats\n"

#: src/uniq.c:152
msgid ""
"  -D, --all-repeated[=delimit-method]  print all duplicate lines\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        Delimiting is done with blank lines.\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
"  -z, --zero-terminated  end lines with 0 byte, not newline\n"
msgstr ""
"  -D, --all-repeated[=delimit-method]  affiche toute ligne en double\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        La délimitation est faite avec des lignes blanches.\n"
"  -f, --skip-fields=N   évite de comparer les N premiers champs\n"
"  -i, --ignore-case     ignore les différences de casse à la comparaison\n"
"  -s, --skip-chars=N    évite de comparer les N premiers caractères\n"
"  -u, --unique          affiche seulement les lignes uniques\n"
"  -z, --zero-terminated  finit les lignes avec l'octer 0, et pas retour "
"charriot\n"

#: src/uniq.c:162
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr ""
"  -w, --check-chars=N   ne pas comparer plus de N caractères des lignes\n"

#: src/uniq.c:167
msgid ""
"\n"
"A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
"characters.  Fields are skipped before chars.\n"
msgstr ""
"\n"
"Un champ est une suite de blancs (souvent des espaces et/ou TABs), suivi de "
"caractères \n"
"non-blancs. Les champs sont escamotés avant les caractères.\n"

#: src/uniq.c:172
#, fuzzy
msgid ""
"\n"
"Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
"You may want to sort the input first, or use `sort -u' without `uniq'.\n"
"Also, comparisons honor the rules specified by `LC_COLLATE'.\n"
msgstr ""
"\n"
"Note :  uniq ne détecte pas les lignes répétées à moins qu'elles soient "
"adjacentes.\n"
"Vous pourriez vouloir d'abord trier l'entrée, ou employer `sort -u' "
"sans`uniq'.\n"

#: src/uniq.c:358
#, c-format
msgid "too many repeated lines"
msgstr "trop de lignes répétées"

#: src/uniq.c:521
msgid "invalid number of fields to skip"
msgstr "nombre invalide de champs à escamoter"

#: src/uniq.c:530
msgid "invalid number of bytes to skip"
msgstr "nombre invalide d'octets à escamoter"

#: src/uniq.c:539
msgid "invalid number of bytes to compare"
msgstr "nombre invalide d'octets à comparer"

#: src/uniq.c:558
#, c-format
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr ""
"afficher toutes les lignes dupliquées et le décompte de répétition\n"
"est inutile"

#: src/unlink.c:46
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s FICHIER...\n"
"   ou: %s OPTION\n"

#: src/unlink.c:49
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"Appeler la fonction unlink() pour enlever le fichier spécifié.\n"
"\n"

#: src/unlink.c:87
#, c-format
msgid "cannot unlink %s"
msgstr "ne peut enlever le lien %s"

#: src/uptime.c:125
#, c-format
msgid "couldn't get boot time"
msgstr "n'a pu obtenir la date du réamorçage"

#. TRANSLATORS: This prints the current clock time.
#: src/uptime.c:136
msgid " %H:%M%P  "
msgstr " %H:%M%P  "

#: src/uptime.c:138
#, c-format
msgid " ??:????  "
msgstr " ??:????  "

#: src/uptime.c:140
#, c-format
msgid "up ???? days ??:??,  "
msgstr "actif ???? jours ??:??,  "

#: src/uptime.c:144
#, c-format
msgid "up %ld day %2d:%02d,  "
msgid_plural "up %ld days %2d:%02d,  "
msgstr[0] "actif %ld jour %2d:%02d,  "
msgstr[1] "actif %ld jours %2d:%02d,  "

#: src/uptime.c:151
#, c-format
msgid "%lu user"
msgid_plural "%lu users"
msgstr[0] "%lu usager"
msgstr[1] "%lu usagers"

#: src/uptime.c:165
#, c-format
msgid ",  load average: %.2f"
msgstr ",  charge moyenne : %.2f"

#: src/uptime.c:202
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes."
msgstr ""
"Affiche la date courante, la durée depuis lequel le système\n"
"a été amorcé, le nombre d'usagers sur le système, et le nombre moyen\n"
"de tâches dans la file d'exécution depuis les dernières 1, 5 et 15 minutes."

#: src/uptime.c:211
#, c-format
msgid ""
"  Processes in\n"
"an uninterruptible sleep state also contribute to the load average.\n"
msgstr ""
"  Tâches en cours\n"
"un ininterruptible état dormant contribue aussi à la charge moyenne.\n"

#: src/uptime.c:215
#, c-format
msgid "\n"
msgstr "\n"

#: src/uptime.c:217
#, c-format
msgid ""
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Si FICHIER n'est pas spécifié, employer %s.  %s comme FICHIER est commun.\n"
"\n"

#: src/users.c:107
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Afficher la liste des usagers actifs selon la liste contenue dans\n"
"le FICHIER.   Si le FICHIER n'est pas spécifié, utiliser %s.\n"
"L'utilisation de %s comme FICHIER est d'usage courant.\n"
"\n"

#: src/wc.c:117
msgid ""
"Print newline, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"Afficher le décompte d'octets, de mots et de nouvelles lignes pour chaque "
"FICHIER et\n"
"le nombre total de ligne si plus d'un FICHIER est spécifié.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"  -c, --bytes            afficher le nombre d'octets\n"
"  -m, --chars            afficher le nombre de caractères\n"
"  -l, --lines            afficher le nombre de nouvelles lignes\n"

#: src/wc.c:125
msgid ""
"      --files0-from=F    read input from the files specified by\n"
"                           NUL-terminated names in file F;\n"
"                           If F is - then read names from standard input\n"
"  -L, --max-line-length  print the length of the longest line\n"
"  -w, --words            print the word counts\n"
msgstr ""
"      --files0-from=F    lit l'entrée depuis les fichiers spécifiés par\n"
"                           les noms NUL-terminated du fichier F;\n"
"                           si F est - alors lit les noms depuis l'entrée "
"standard\n"
"  -L, --max-line-length  affiche la longueur de la ligne la plus longue\n"
"  -w, --words            affiche le nombre de mots\n"

#: src/who.c:210
msgid " old "
msgstr "vieux"

#: src/who.c:430
msgid "system boot"
msgstr "Démarrage système"

#: src/who.c:437 src/who.c:439
msgid "id="
msgstr "id="

#: src/who.c:452 src/who.c:457
msgid "term="
msgstr "term="

#: src/who.c:454 src/who.c:458
msgid "exit="
msgstr "sortie="

#: src/who.c:475
msgid "LOGIN"
msgstr "LOGIN"

#: src/who.c:495
msgid "clock change"
msgstr "changement d'horloge"

#: src/who.c:507 src/who.c:508
msgid "run-level"
msgstr "niveau d'exécution"

#: src/who.c:511 src/who.c:512
msgid "last="
msgstr "dernier="

#: src/who.c:543
#, c-format
msgid ""
"\n"
"# users=%lu\n"
msgstr ""
"\n"
"# usager=%lu\n"

#: src/who.c:549
msgid "NAME"
msgstr "NOM"

#: src/who.c:549
msgid "LINE"
msgstr "LIGNE"

#: src/who.c:549
msgid "TIME"
msgstr "HEURE"

#: src/who.c:549
msgid "IDLE"
msgstr "OSIF"

#: src/who.c:550
msgid "PID"
msgstr "PID"

#: src/who.c:550
msgid "COMMENT"
msgstr "COMMENTAIRE"

#: src/who.c:550
msgid "EXIT"
msgstr "EXIT"

#: src/who.c:631
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "Usage: %s [OPTION]... [ FICHIER | ARG1 ARG2]\n"

#: src/who.c:632
msgid "Print information about users who are currently logged in.\n"
msgstr "Affiche des infos au sujet des utilisateurs qui sont connectés.\n"

#: src/who.c:635
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all        afficher toutes les informations\n"
"  -b, --boot       afficher l'heure du dernier amorçage\n"
"  -d, --dead       afficher la liste des processus morts\n"
"  -H, --heading    afficher les lignes d'en-tête\n"

#: src/who.c:642
msgid "  -l, --login       print system login processes\n"
msgstr "  -l, --login       afficher le processus de login du système\n"

#: src/who.c:645
msgid ""
"      --lookup      attempt to canonicalize hostnames via DNS\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"      --lookup      utiliser la forme canonique des noms des hôtes\n"
"                    via le DNS (-l est déprécié, utiliser --lookup)\n"
"  -m                seulement du poste (hostname) et\n"
"                    de l'usager associé à « stdin »\n"
"  -p, --process     afficher la liste des processus lancés par init\n"

#: src/who.c:650
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count       afficher tous les comptes actifs et le nombre d'usagers\n"
"                    présents sur le système\n"
"  -r, --runlevel    afficher le niveau d'exécution courant\n"
"  -s, --short       afficher seulement le nom, la ligne et l'heure (par "
"défaut)\n"
"  -t, --time        afficher l'heure du dernier changement d'heure de "
"l'horloge\n"

#: src/who.c:656
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg    ajouter le statut du message usager avec +, - ou ?\n"
"  -u, --users       afficher la liste des usagers actifs\n"
"      --message     identique à -T\n"
"      --writeable   identique à -T\n"

#: src/who.c:664
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: `am i' or `mom likes' are usual.\n"
msgstr ""
"\n"
"Si FICHIER n'est pas spécifié, utilise %s.  %s comme FICHIER\n"
"est d'usage courant.  Si PARAM1 et PARAM2 sont fournis, -m est assumé:\n"
"« am i » ou « mom likes » sont d'usage courant.\n"

#: src/whoami.c:47
msgid ""
"Print the user name associated with the current effective user ID.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"Afficher le nom de l'usager associé à l'identificateur effectif\n"
"courant de l'usager.  Identique à: id -un.\n"
"\n"

#: src/whoami.c:91
#, c-format
msgid "%s: cannot find name for user ID %lu\n"
msgstr "%s: ne peut trouver le nom de l'usager ID %lu\n"

#: src/yes.c:42
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Usage: %s [CHAÎNE]...\n"
"   ou: %s OPTION\n"

#: src/yes.c:48
msgid ""
"Repeatedly output a line with all specified STRING(s), or `y'.\n"
"\n"
msgstr ""
"Afficher à répétition une ligne de caractères telle que spécifiée\n"
"par CHAÎNE ou par « y ».\n"

#~ msgid "invalid argument: %s"
#~ msgstr "argument invalide: %s"

#, fuzzy
#~ msgid "Report %s bugs to <%s>.\n"
#~ msgstr ""
#~ "\n"
#~ "Signaler un bug à <%s>.\n"

#~ msgid "%s home page: <http://www.gnu.org/software/%s/>.\n"
#~ msgstr "%s page d'accueil : <http://www.gnu.org/software/%s/>.\n"

#~ msgid "General help using GNU software: <http://www.gnu.org/gethelp/>.\n"
#~ msgstr ""
#~ "Aide générale sur l'usage de logiciel GNU : <http://www.gnu.org/gethelp/"
#~ ">.\n"

#~ msgid "  -d, --directory  create a directory, not a file\n"
#~ msgstr "  -d, --directory  crée un répertoire, et non un fichier\n"

#~ msgid ""
#~ "  -q, --quiet      suppress diagnostics about file/dir-creation failure\n"
#~ msgstr ""
#~ "  -q, --quiet      supprime le diagnostic du fichier/dir-creation échec\n"

#~ msgid ""
#~ "  -u, --dry-run    do not create anything; merely print a name (unsafe)\n"
#~ msgstr ""
#~ "  -u, --dry-run    ne crée rien; affiche simplement un nom(peu sûr)\n"

#~ msgid "  -p DIR           use DIR as a prefix; implies -t [deprecated]\n"
#~ msgstr ""
#~ "  -p DIR           emploie DIR comme préfixe ; implique -t [caduc]\n"

#~ msgid "the --megabytes option is deprecated; use -m instead"
#~ msgstr "l'option --megabytes est désuète; utiliser -m à la place"

#~ msgid ""
#~ "\n"
#~ "If -e is in effect, the following sequences are recognized:\n"
#~ "\n"
#~ "  \\0NNN   the character whose ASCII code is NNN (octal)\n"
#~ "  \\\\     backslash\n"
#~ "  \\a     alert (BEL)\n"
#~ "  \\b     backspace\n"
#~ msgstr ""
#~ "\n"
#~ "Avec l'option -E, les séquences suivantes sont reconnues:\n"
#~ "\n"
#~ "  \\ONNN  le caractère dont le code ASCII est NNN (en octal)\n"
#~ "  \\\\     barre oblique inverse\n"
#~ "  \\a     bip sonore d'alerte\n"
#~ "  \\b     retour arrière\n"

#~ msgid ""
#~ "  \\a      alert (BEL)\n"
#~ "  \\b      backspace\n"
#~ "  \\c      produce no further output\n"
#~ "  \\f      form feed\n"
#~ msgstr ""
#~ "  \\a      bip sonore d'alerte\n"
#~ "  \\b      retour arrière\n"
#~ "  \\c      ne pas afficher d'autres informations sur la sortie\n"
#~ "  \\f      saut de page\n"

#~ msgid ""
#~ "  \\n      new line\n"
#~ "  \\r      carriage return\n"
#~ "  \\t      horizontal tab\n"
#~ "  \\v      vertical tab\n"
#~ msgstr ""
#~ "  \\n      saut de ligne\n"
#~ "  \\r      retour de chariot\n"
#~ "  \\t      tabulation horizontale\n"
#~ "  \\v      tabulation verticale\n"

#~ msgid "creating %s"
#~ msgstr "création de %s"

#~ msgid "FATAL: failed to close directory %s"
#~ msgstr "FATAL : échec de fermeture de répertoire %s"

#~ msgid "FATAL: cannot open .. from %s"
#~ msgstr "FATA : ne peut ouvrir .. depuis %s"

#~ msgid "FATAL: cannot ensure %s (returned to via ..) is safe"
#~ msgstr "FATAL : ne peut certifier que %s (retourné à via ..) est sûr"

#~ msgid "FATAL: directory %s changed dev/ino"
#~ msgstr "FATAL : répertoire %s changé dev/ino"

#~ msgid "FATAL: cannot enter directory %s"
#~ msgstr "FATAL : ne peut entrer dans le répertoire %s"

#~ msgid "FATAL: just-changed-to directory %s changed dev/ino"
#~ msgstr ""
#~ "FATAL :  just-change-to(celui qui vient juste d'être changé) répertoire %"
#~ "s a modifié dev/ino"

#~ msgid "failed to close directory %s"
#~ msgstr "échec de fermeture du répertoire %s"

#~ msgid "FATAL: cannot return to .. from %s"
#~ msgstr "FATAL : ne peut retourner à .. depuis %s"

#~ msgid "cannot remove %s directory %s"
#~ msgstr "ne peut détruire %s le répertoire %s"

#~ msgid "cannot remove root directory %s"
#~ msgstr "ne peut détruire le répertoire racine %s"

#~ msgid "cannot remove relative-named %s"
#~ msgstr "ne peut supprimer relative-named %s"

#~ msgid "cannot restore current working directory"
#~ msgstr "ne peut restaurer le répertoire courant de travail"

#~ msgid ""
#~ "\n"
#~ "SIZE may have a multiplier suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ msgstr ""
#~ "\n"
#~ "SIZE peut avoir un suffixe multiplicateur :\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, et ainsi de suite pour T, P, E, Z, "
#~ "Y.\n"

#~ msgid ""
#~ "\n"
#~ "SIZE is a number which may be followed by one of the following suffixes:\n"
#~ "KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, "
#~ "Y.\n"
#~ msgstr ""
#~ "\n"
#~ "TAILLE est un nombre qui peut être suivi par un de ces suffixes :\n"
#~ "KB 1000, K 1024, MB 1000*1000, M 1024*1024 et ainsi de suite pour G, T, "
#~ "P, E, Z, Y.\n"

#~ msgid "%s: warning: making a hard link to a symbolic link is not portable"
#~ msgstr ""
#~ "%s: AVERTISSEMENT: créer un lien direct vers un lien symbolique n'est pas "
#~ "portable"

#, fuzzy
#~ msgid "cannot find group %s"
#~ msgstr "ne peut initialiser les groupes"

#~ msgid ""
#~ "Discard all but one of successive identical lines from INPUT (or\n"
#~ "standard input), writing to OUTPUT (or standard output).\n"
#~ "\n"
#~ msgstr ""
#~ "Exclure toutes les lignes successives identiques sauf une du FICHIER\n"
#~ "(ou de l'entrée standard), lors de l'écriture dans un FICHIER\n"
#~ "(ou vers la sortie standard).\n"
#~ "\n"

#~ msgid "couldn't open temporary file"
#~ msgstr "N'a pu ouvrir le fichier temporaire"
